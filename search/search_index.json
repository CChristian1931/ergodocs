{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Ergo Platform Documentation! Ergo uses continous integration, meaning best practices dictate that the majority of the documentation should be kept on the assosciated repositories themselves. this site aims to serve as a directory that guides the user on their development journey. Documentation within the naviation tabs above is split into four distinct categories. Tutorials How-To Guides Explanations References Read more about the format used on this website. Other resources awesome-ergo ergonaut.space ergosites.github","title":"Home"},{"location":"#welcome-to-the-ergo-platform-documentation","text":"Ergo uses continous integration, meaning best practices dictate that the majority of the documentation should be kept on the assosciated repositories themselves. this site aims to serve as a directory that guides the user on their development journey. Documentation within the naviation tabs above is split into four distinct categories. Tutorials How-To Guides Explanations References Read more about the format used on this website.","title":"Welcome to the Ergo Platform Documentation!"},{"location":"#other-resources","text":"awesome-ergo ergonaut.space ergosites.github","title":"Other resources"},{"location":"About/events/","text":"ERGOHACK ERGOHACK I Hackerthon Jun 12th! ERGOHACK II ERGOHACK III ErgoSummit ErgoSummit I ErgoSummit Timestamps 00:00:00 - The Summit 00:01:00 - Ergo 101: The Basics 00:40:00 - Cardano & Ergo\u2019s UTXO Model 01:11:30 - DeFi Services: How Yoroi Wallet will be the gateway to Ergo dApps and what\u2019s to come 01:32:30 - Auction House 01:49:30 - Announcing The Release Of The AgeUSD Stablecoin Protocol 02:18:00 - An IOHK Perspective: Designing The AgeUSD Stablecoin Protocol - An Economic Analysis (with Special Guest IOHK\u2019s Bruno) 03:02:00 - AgeUSD Smart Contracts: A Technical Perspective 03:41:00 - Enter Into The Sigmaverse - Uncovering What Lays Within Ergo\u2019s dApp Ecosystem 03:47:30 - Ergo-Bootstrap - Streamlining Ergo dApp Infrastructure With One Simple Tool 03:59:30 - Headless dApps: A Novel Technical & Business Model for the dApp Industry 04:28:00 - Ergo - Cardano Collaboration 04:38:00 - Understanding dApp Developer Tooling: An Introduction To Kiosk [05:13:00] (https://www.youtube.com/watch?v=zG-rxMCDIa0&t=18780s) - The Upcoming Ergo Hardening Upgrade - How It Will Change The Ecosystem From Top To Bottom 05:26:30 - Oracle Pools Update - How Deviation Checking Consensus Improves Assurance 05:57:00 - Updatable dApps In The EUTXO Model 06:10:00 - Blockchain 2020: A DeFi Odyssey 06:51:00 - The Ergo Vision 07:03:00 - ZK Treasury 07:07:00 - Understanding dApp Developer Tooling: An Introduction To Json dApp Environment 07:45:30 - The Ergo Foundation\u2019s Grant-Based Approach To Developing The UTXO-Based dApp Ecosystem 08:05:30 - 2021 Ergo Roadmap reveal ErgoSummit II Q4 2021","title":"Events"},{"location":"About/events/#ergohack","text":"","title":"ERGOHACK"},{"location":"About/events/#ergohack-i","text":"Hackerthon Jun 12th!","title":"ERGOHACK I"},{"location":"About/events/#ergohack-ii","text":"","title":"ERGOHACK II"},{"location":"About/events/#ergohack-iii","text":"","title":"ERGOHACK III"},{"location":"About/events/#ergosummit","text":"","title":"ErgoSummit"},{"location":"About/events/#ergosummit-i","text":"","title":"ErgoSummit I"},{"location":"About/events/#ergosummit-timestamps","text":"00:00:00 - The Summit 00:01:00 - Ergo 101: The Basics 00:40:00 - Cardano & Ergo\u2019s UTXO Model 01:11:30 - DeFi Services: How Yoroi Wallet will be the gateway to Ergo dApps and what\u2019s to come 01:32:30 - Auction House 01:49:30 - Announcing The Release Of The AgeUSD Stablecoin Protocol 02:18:00 - An IOHK Perspective: Designing The AgeUSD Stablecoin Protocol - An Economic Analysis (with Special Guest IOHK\u2019s Bruno) 03:02:00 - AgeUSD Smart Contracts: A Technical Perspective 03:41:00 - Enter Into The Sigmaverse - Uncovering What Lays Within Ergo\u2019s dApp Ecosystem 03:47:30 - Ergo-Bootstrap - Streamlining Ergo dApp Infrastructure With One Simple Tool 03:59:30 - Headless dApps: A Novel Technical & Business Model for the dApp Industry 04:28:00 - Ergo - Cardano Collaboration 04:38:00 - Understanding dApp Developer Tooling: An Introduction To Kiosk [05:13:00] (https://www.youtube.com/watch?v=zG-rxMCDIa0&t=18780s) - The Upcoming Ergo Hardening Upgrade - How It Will Change The Ecosystem From Top To Bottom 05:26:30 - Oracle Pools Update - How Deviation Checking Consensus Improves Assurance 05:57:00 - Updatable dApps In The EUTXO Model 06:10:00 - Blockchain 2020: A DeFi Odyssey 06:51:00 - The Ergo Vision 07:03:00 - ZK Treasury 07:07:00 - Understanding dApp Developer Tooling: An Introduction To Json dApp Environment 07:45:30 - The Ergo Foundation\u2019s Grant-Based Approach To Developing The UTXO-Based dApp Ecosystem 08:05:30 - 2021 Ergo Roadmap reveal","title":"ErgoSummit Timestamps"},{"location":"About/events/#ergosummit-ii","text":"Q4 2021","title":"ErgoSummit II"},{"location":"About/faq/","text":"Basics What is the teams background? | Ergo is designed and implemented by a team of experienced developers and researchers, who hold publications and PhDs in cryptography, compiler theory, blockchain technology, and cryptographic e-cash. The team also has a solid background in core development with such cryptocurrencies and blockchain frameworks as Nxt, Scorex and Waves. Alexander 'kushti' Chepurnoy, was a co-founder of smartcontract.com (now Chainlink), a core developer at NXT (first PoS), and one of the first employees at IOHK, where he was a Research Fellow and Team Scorex Manager. The full team can be seen on Ergo's Hall of Fame . Why 'Ergo'? | \u201cErgo means \u201ctherefore\u201d in Latin, but \u201cwork\u201d in Greek. Initially, the name was chosen to point to the fact that the design of the cryptocurrency is ERGOnomical. What is the emission schedule? | Emission Schedule with a maximum supply of 97,739,925 Ergs, to be completed in 8 years after launch. When was Ergo launched? | July, 2019. The previous price spike was a different token (Ergo-First-Year-Token), if you view the chart by market-cap it is accurate. Where can I buy Erg? | KuCoin, CoinEx, TradeOgre, gate.io. Where can I store Erg? | Yoroi or the Android Wallet. Is there mobile support? | Android only currently, iOS in development Can we use a hardware wallet? | Ledger support underway. Workaround: You can move your Erg to waves.exchange and stake your erg through that. Can I stake ERG? | No, Ergo is a Proof of Work coin - you can however provide liquidity on either the CoinEx AMM pool (watch out for impermanent loss!), or SigmaUSD. However, dApp tokenisation is coming - A Solution for staking Ergo Foundation What is the Ergo Foundation? | The Ergo Foundation is a community-driven entity focused on: Promoting non-breaking development of Ergo Platform protocol; Promoting the widespread adoption and use of Ergo Platform and its native token (ERG); Developing the ecosystem around the Ergo Platform; Promoting the use of Ergo Platform and blockchain technology for social good; Supporting truly decentralized infrastructure, and; Supporting privacy as a basic human right. Deep Dives Ergo: Road to Top 10 ergonaut.space Infographics \u201cIt's one of the most revolutionary cryptocurrencies ever built. Got so many crazy ideas like sigma protocols and pruning the blockchain and roller chains. All this crazy stuff. Even has a proof of no premine. So really a technological marvel in many respects, and it reflects about 8 years of knowledge that Alex has amassed as both a researcher and a developer. Super concise code and it blows my mind that the market cap is where it's at. It should be a top 10 coin or top 15 coin\" \u2014 Charles Hoskinson Get some perspective Proof of Work Ergo was created for regular people, PoW allows for a fair start and true decentralistion. It's also widely studied, and has very high-security guarantees - which are essential for having useful contractual, programmable money that's ready today. Here's CH talking a bit about consensus Why Proof-of-Work? | It's tried and tested (the Lindy effect), and has some advantages over PoS. What about 51% attacks? | Not a significant problem, more pools are being added. Ergo's Efficiency and interplay with PoS - Discussion Can I mine ERG? | To mine, you will need a dedicated GPU (AMD/Intel), see this page on mining What will Erg bring to ADA? Features Storage Rent | After four years, miners can charge fees for unmoved erg. Stabilising miner income and preventing lost coins as we see in BTC. Sigma Protocols | Ergo\u2019s smart contracts and DeFi functionality are built on Sigma protocols \u2013 a powerful, flexible class of zero-knowledge proofs. Find out more about why they\u2019re so important, and how they put Ergo head and shoulders above the competition. eUTxO | Based on the UTXO model of Bitcoin, similar extended-UTXO model as Cardano, allowing interoperability. NiPoPoWs | Verify proof of work without downloading the headers. Enables light-clients during in places with poor internet - and light mining (not having to download the entire chain) dApps Ergo already has several functional decentralised applications | sigmaverse.io ErgoMixer | the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space . SigmaUSD | DAI-like Stablecoin - without liquidations. AuctionHouse | Working NFT marketplace. Oracle-Pools | More efficient and programmable than using multiple single oracle data points such as in Chainlink\u2019s oracle design. We build hierarchies of confidence using oracle pools and pools of oracle pools in Ergo. It\u2019s faster, cheaper, and more beneficial to the end-user. In-Development ErgoDex | Decentralised exchange that runs ontop ADA & ERG. ErgoFund | Crowdfunding on Ergo Use cases Ergo is one of the most sophisticated protocols in the space with stateless clients, NiPoPoWS for light clients, and easy miner-voting on parameter changes (e.g, block size) Ergo aims to provide an efficient, secure, and easy way to implement financial contracts that will be useful and survivable in the long term. There is plenty of uniqueness in Ergo but the most significant is probably Sigma protocols. These allow a true P2P system with privacy in mind. No one at the moment is able to build a trustless LETS system, multisig with no signers disclosure, trustless payment networks or has real ring signatures that preserve zero knowledge. Local Exchange Trading System - a local mutual credit association which members are allowed to create common credit money individually, with all the deals in the system written into a common ledger. To the best of our knowledge, this is the first implementation of such kind of community currency on top of a blockchain. LETS can be thought of as a mechanism to facilitate the velocity of trade, goods, and services out-with the existing monetary system, allowing us to create sustainable local economies. Smart contracts without gas fees. Ergo\u2019s native programming language \u2014 aka ErgoScript \u2014 enables the development of Turing complete contracts that completely bypass the need for any gas fee while providing other peripheral benefits such as estimation of script complexity before execution, a facet that helps in the active prevention of DoS attacks. Ergo.Meta - a unified set of design patterns for off-chain and sidechain solutions ErgoScript : a new advanced transactional language built from scratch by the team. Tutorials are available on the website /docs/AdvancedErgoScriptTutorial.pdf. It is a more advanced scripting language than Bitcoin while maintaining security and not introducing blockchain bloat problems. Scripting language in itself is non-Turing complete but applications ran on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper https://arxiv.org/pdf/1806.10116v1.pdf. Rigorous research and scientific approach : Ergo is based on original research, published at known peer-reviewed conferences. A list of scientific papers is available at here , but Ergo is not limited by research and it also implements other novel scientific ideas. Trustless Light Clients with Minimal Resource Requirements: Ergo block header supports NiPoPoWs that enable synchronizing network by downloading < 1Mb of data. This is further made possible by the fact Ergo state is authenticated as detailed in this paper from 2017 New Economic Model : Key feature of the new model is miners charge users a fee for any UTXO that remains unmoved for 4 years (\u201cstorage rent fee\u201d). This accomplishes stable mining revenue to secure the network, prevents \u201cstate bloat\u201d and enables a short release schedule \u2013 Ergo emission fully completes in just 8 years. Details in this paper Mined from Zero via PoW with no ICO or Pre-mine . It is about a hope to achieve a fair distribution of Ergs as possible to enhance decentralization. Decentralization First : Core commitment of Development team and community. Top item in \u201cErgo Vision\u201d section of white paper. Many of the above features\u2019 main purpose is to achieve this goal. Resiliency and Survivability : Decentralization First is to accomplish this goal. Ergo should be alive and operational for an indefinite amount of time and Contractual Money contracts on Ergo should be able to survive for at least the length of a person\u2019s lifetime despite a changing external environment. Privacy : Privacy is optional in Ergo, but it still beats a lot of privacy coins by default. You can actually put XMR on top, but Ergo itself can achieve privacy of early Monero if there are enough users of the mixers. Actually, it can be far better, as no inference scenarios are possible as described in this paper . Related: ErgoMixer Other : Ergo offers anyone the ability to issue their own tokens (non-native tokens) on the platform and leverage off its security and decentralization. Advanced on-chain governance is built with miners being able to vote on a number of parameters including simple items like block size \u2013 gradual changes only to ensure stability. Ergo follows a soft-forkability approach --- if an overwhelming majority of the network accepts a new feature, it is activated, however, old nodes which do not upgrade continue to operate normally and just skip over this feature validation. Thus disruptive hard forks should not be required in Ergo. Ergo mining will always be stable, unlike Bitcoin and other PoW currencies, in which mining may become unstable after the emission period. To achieve survivability, Ergo provides economic improvements in addition to the technical ones, most central of which is a storage fee component which plays an important role for Ergo\u2018s stability. Scalability The blocks in the Ergo Network are aimed to be produced at an interval of approx. 2 minutes. TPS itself doesn't matter much for Ergo in the long run since it has smart contracts in which you can chain hundreds of transactions within one. Ergo\u2019s solutions to transaction congestion are as follows: L0: A lot of efficiency improvements in the node have been completed starting from v4.0.8, 20-50x gains are still possible here. Quick bootstrapping using NiPoPoWs proofs and UTXO set snapshots are also planned L1: Ergo has an extension section in its code that allows the implementation of a wide variety of scaling solutions such as Sharding, Hydra, or BitcoinNG-style macroblocks. This even lets us do generic sidechains with velvet or soft forks. L2 (off-chain) - Ergo should be compatible with the Lightning Network, Rainbow Network, and many more. The implementation here will depend on the needs of the applications being built on Ergo. Ergo has stateless clients, NiPoPoWs - can put full nodes on Raspberry Pi's, make ultra-efficient SPV clients and other means to survive in the long-term even under the load. Storage rent helps to prevent spam & dust and stabilize mining income. Other benefits from having the storage rent fee include prevention of \"state bloat\", the building of an economy around the state (users must pay to keep unspent boxes in miners' memory for the long\u2010term) and a gradual return of any lost coins back into circulation. Partnerships / Business Development Yoroi dApp Connector | In Testing! Waves Partners with Ergo to foster Interoperability solutions | In Testing! Cryptocurrencycheckout: Supports both SigUSD and Ergo. Roadmap","title":"FAQ"},{"location":"About/faq/#basics","text":"What is the teams background? | Ergo is designed and implemented by a team of experienced developers and researchers, who hold publications and PhDs in cryptography, compiler theory, blockchain technology, and cryptographic e-cash. The team also has a solid background in core development with such cryptocurrencies and blockchain frameworks as Nxt, Scorex and Waves. Alexander 'kushti' Chepurnoy, was a co-founder of smartcontract.com (now Chainlink), a core developer at NXT (first PoS), and one of the first employees at IOHK, where he was a Research Fellow and Team Scorex Manager. The full team can be seen on Ergo's Hall of Fame . Why 'Ergo'? | \u201cErgo means \u201ctherefore\u201d in Latin, but \u201cwork\u201d in Greek. Initially, the name was chosen to point to the fact that the design of the cryptocurrency is ERGOnomical. What is the emission schedule? | Emission Schedule with a maximum supply of 97,739,925 Ergs, to be completed in 8 years after launch. When was Ergo launched? | July, 2019. The previous price spike was a different token (Ergo-First-Year-Token), if you view the chart by market-cap it is accurate. Where can I buy Erg? | KuCoin, CoinEx, TradeOgre, gate.io. Where can I store Erg? | Yoroi or the Android Wallet. Is there mobile support? | Android only currently, iOS in development Can we use a hardware wallet? | Ledger support underway. Workaround: You can move your Erg to waves.exchange and stake your erg through that. Can I stake ERG? | No, Ergo is a Proof of Work coin - you can however provide liquidity on either the CoinEx AMM pool (watch out for impermanent loss!), or SigmaUSD. However, dApp tokenisation is coming - A Solution for staking","title":"Basics"},{"location":"About/faq/#ergo-foundation","text":"What is the Ergo Foundation? | The Ergo Foundation is a community-driven entity focused on: Promoting non-breaking development of Ergo Platform protocol; Promoting the widespread adoption and use of Ergo Platform and its native token (ERG); Developing the ecosystem around the Ergo Platform; Promoting the use of Ergo Platform and blockchain technology for social good; Supporting truly decentralized infrastructure, and; Supporting privacy as a basic human right.","title":"Ergo Foundation"},{"location":"About/faq/#deep-dives","text":"Ergo: Road to Top 10 ergonaut.space Infographics \u201cIt's one of the most revolutionary cryptocurrencies ever built. Got so many crazy ideas like sigma protocols and pruning the blockchain and roller chains. All this crazy stuff. Even has a proof of no premine. So really a technological marvel in many respects, and it reflects about 8 years of knowledge that Alex has amassed as both a researcher and a developer. Super concise code and it blows my mind that the market cap is where it's at. It should be a top 10 coin or top 15 coin\" \u2014 Charles Hoskinson Get some perspective","title":"Deep Dives"},{"location":"About/faq/#proof-of-work","text":"Ergo was created for regular people, PoW allows for a fair start and true decentralistion. It's also widely studied, and has very high-security guarantees - which are essential for having useful contractual, programmable money that's ready today. Here's CH talking a bit about consensus Why Proof-of-Work? | It's tried and tested (the Lindy effect), and has some advantages over PoS. What about 51% attacks? | Not a significant problem, more pools are being added. Ergo's Efficiency and interplay with PoS - Discussion Can I mine ERG? | To mine, you will need a dedicated GPU (AMD/Intel), see this page on mining What will Erg bring to ADA?","title":"Proof of Work"},{"location":"About/faq/#features","text":"Storage Rent | After four years, miners can charge fees for unmoved erg. Stabilising miner income and preventing lost coins as we see in BTC. Sigma Protocols | Ergo\u2019s smart contracts and DeFi functionality are built on Sigma protocols \u2013 a powerful, flexible class of zero-knowledge proofs. Find out more about why they\u2019re so important, and how they put Ergo head and shoulders above the competition. eUTxO | Based on the UTXO model of Bitcoin, similar extended-UTXO model as Cardano, allowing interoperability. NiPoPoWs | Verify proof of work without downloading the headers. Enables light-clients during in places with poor internet - and light mining (not having to download the entire chain)","title":"Features"},{"location":"About/faq/#dapps","text":"Ergo already has several functional decentralised applications | sigmaverse.io ErgoMixer | the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space . SigmaUSD | DAI-like Stablecoin - without liquidations. AuctionHouse | Working NFT marketplace. Oracle-Pools | More efficient and programmable than using multiple single oracle data points such as in Chainlink\u2019s oracle design. We build hierarchies of confidence using oracle pools and pools of oracle pools in Ergo. It\u2019s faster, cheaper, and more beneficial to the end-user.","title":"dApps"},{"location":"About/faq/#in-development","text":"ErgoDex | Decentralised exchange that runs ontop ADA & ERG. ErgoFund | Crowdfunding on Ergo","title":"In-Development"},{"location":"About/faq/#use-cases","text":"Ergo is one of the most sophisticated protocols in the space with stateless clients, NiPoPoWS for light clients, and easy miner-voting on parameter changes (e.g, block size) Ergo aims to provide an efficient, secure, and easy way to implement financial contracts that will be useful and survivable in the long term. There is plenty of uniqueness in Ergo but the most significant is probably Sigma protocols. These allow a true P2P system with privacy in mind. No one at the moment is able to build a trustless LETS system, multisig with no signers disclosure, trustless payment networks or has real ring signatures that preserve zero knowledge. Local Exchange Trading System - a local mutual credit association which members are allowed to create common credit money individually, with all the deals in the system written into a common ledger. To the best of our knowledge, this is the first implementation of such kind of community currency on top of a blockchain. LETS can be thought of as a mechanism to facilitate the velocity of trade, goods, and services out-with the existing monetary system, allowing us to create sustainable local economies. Smart contracts without gas fees. Ergo\u2019s native programming language \u2014 aka ErgoScript \u2014 enables the development of Turing complete contracts that completely bypass the need for any gas fee while providing other peripheral benefits such as estimation of script complexity before execution, a facet that helps in the active prevention of DoS attacks. Ergo.Meta - a unified set of design patterns for off-chain and sidechain solutions ErgoScript : a new advanced transactional language built from scratch by the team. Tutorials are available on the website /docs/AdvancedErgoScriptTutorial.pdf. It is a more advanced scripting language than Bitcoin while maintaining security and not introducing blockchain bloat problems. Scripting language in itself is non-Turing complete but applications ran on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper https://arxiv.org/pdf/1806.10116v1.pdf. Rigorous research and scientific approach : Ergo is based on original research, published at known peer-reviewed conferences. A list of scientific papers is available at here , but Ergo is not limited by research and it also implements other novel scientific ideas. Trustless Light Clients with Minimal Resource Requirements: Ergo block header supports NiPoPoWs that enable synchronizing network by downloading < 1Mb of data. This is further made possible by the fact Ergo state is authenticated as detailed in this paper from 2017 New Economic Model : Key feature of the new model is miners charge users a fee for any UTXO that remains unmoved for 4 years (\u201cstorage rent fee\u201d). This accomplishes stable mining revenue to secure the network, prevents \u201cstate bloat\u201d and enables a short release schedule \u2013 Ergo emission fully completes in just 8 years. Details in this paper Mined from Zero via PoW with no ICO or Pre-mine . It is about a hope to achieve a fair distribution of Ergs as possible to enhance decentralization. Decentralization First : Core commitment of Development team and community. Top item in \u201cErgo Vision\u201d section of white paper. Many of the above features\u2019 main purpose is to achieve this goal. Resiliency and Survivability : Decentralization First is to accomplish this goal. Ergo should be alive and operational for an indefinite amount of time and Contractual Money contracts on Ergo should be able to survive for at least the length of a person\u2019s lifetime despite a changing external environment. Privacy : Privacy is optional in Ergo, but it still beats a lot of privacy coins by default. You can actually put XMR on top, but Ergo itself can achieve privacy of early Monero if there are enough users of the mixers. Actually, it can be far better, as no inference scenarios are possible as described in this paper . Related: ErgoMixer Other : Ergo offers anyone the ability to issue their own tokens (non-native tokens) on the platform and leverage off its security and decentralization. Advanced on-chain governance is built with miners being able to vote on a number of parameters including simple items like block size \u2013 gradual changes only to ensure stability. Ergo follows a soft-forkability approach --- if an overwhelming majority of the network accepts a new feature, it is activated, however, old nodes which do not upgrade continue to operate normally and just skip over this feature validation. Thus disruptive hard forks should not be required in Ergo. Ergo mining will always be stable, unlike Bitcoin and other PoW currencies, in which mining may become unstable after the emission period. To achieve survivability, Ergo provides economic improvements in addition to the technical ones, most central of which is a storage fee component which plays an important role for Ergo\u2018s stability.","title":"Use cases"},{"location":"About/faq/#scalability","text":"The blocks in the Ergo Network are aimed to be produced at an interval of approx. 2 minutes. TPS itself doesn't matter much for Ergo in the long run since it has smart contracts in which you can chain hundreds of transactions within one. Ergo\u2019s solutions to transaction congestion are as follows: L0: A lot of efficiency improvements in the node have been completed starting from v4.0.8, 20-50x gains are still possible here. Quick bootstrapping using NiPoPoWs proofs and UTXO set snapshots are also planned L1: Ergo has an extension section in its code that allows the implementation of a wide variety of scaling solutions such as Sharding, Hydra, or BitcoinNG-style macroblocks. This even lets us do generic sidechains with velvet or soft forks. L2 (off-chain) - Ergo should be compatible with the Lightning Network, Rainbow Network, and many more. The implementation here will depend on the needs of the applications being built on Ergo. Ergo has stateless clients, NiPoPoWs - can put full nodes on Raspberry Pi's, make ultra-efficient SPV clients and other means to survive in the long-term even under the load. Storage rent helps to prevent spam & dust and stabilize mining income. Other benefits from having the storage rent fee include prevention of \"state bloat\", the building of an economy around the state (users must pay to keep unspent boxes in miners' memory for the long\u2010term) and a gradual return of any lost coins back into circulation.","title":"Scalability"},{"location":"About/faq/#partnerships-business-development","text":"Yoroi dApp Connector | In Testing! Waves Partners with Ergo to foster Interoperability solutions | In Testing! Cryptocurrencycheckout: Supports both SigUSD and Ergo. Roadmap","title":"Partnerships / Business Development"},{"location":"About/format/","text":"Format Tutorials learning-oriented. Tutorial are lessons that take the reader by the hand through a series of steps to complete a project. Most important part of documentation, rarely done well. What matters? Learn by doing. Getting Started Inspiring Confidence Repeatability Immediate sense of achievement Concreteness, not abstraction Minimum necessary explanation No distractions How To Guides problem-oriented. Guides that take the user through a series of steps to achieve a common problem. What matters? A series of steps A focus on the goal Addressing a specific question A little flexibility Practical usability Good naming Explanations Understanding-orientated Explanations that clarify and illuminate a particular topic What Matters? Giving context Explaning why Multiple examples, alternative approaches Making Connections No instruction or technical description References Technical descriptions and how to operate it. What Matters? Structure Consistency Description Accuracy","title":"About ErgoDocs"},{"location":"About/format/#format","text":"","title":"Format"},{"location":"About/format/#tutorials","text":"learning-oriented. Tutorial are lessons that take the reader by the hand through a series of steps to complete a project. Most important part of documentation, rarely done well.","title":"Tutorials"},{"location":"About/format/#what-matters","text":"Learn by doing. Getting Started Inspiring Confidence Repeatability Immediate sense of achievement Concreteness, not abstraction Minimum necessary explanation No distractions","title":"What matters?"},{"location":"About/format/#how-to-guides","text":"problem-oriented. Guides that take the user through a series of steps to achieve a common problem.","title":"How To Guides"},{"location":"About/format/#what-matters_1","text":"A series of steps A focus on the goal Addressing a specific question A little flexibility Practical usability Good naming","title":"What matters?"},{"location":"About/format/#explanations","text":"Understanding-orientated Explanations that clarify and illuminate a particular topic","title":"Explanations"},{"location":"About/format/#what-matters_2","text":"Giving context Explaning why Multiple examples, alternative approaches Making Connections No instruction or technical description","title":"What Matters?"},{"location":"About/format/#references","text":"Technical descriptions and how to operate it.","title":"References"},{"location":"About/format/#what-matters_3","text":"Structure Consistency Description Accuracy","title":"What Matters?"},{"location":"dev/Integration/guide/","text":"This guide is for helping developers integrating Ergo into exchanges, wallets, pools wallets etc. Introduction Some quick facts useful for an integration: like Bitcoin, a transaction in Ergo has multiple inputs and outputs. Unspent outputs are single-use entities. However, Ergo is built from scratch thus scripts and transaction format are different. like in Bitcoin, there are some standard scripts in Ergo associated with addresses, e.g. P2PK addresses. There's an article on address scheme available: https://ergoplatform.org/en/blog/2019_07_24_ergo_address/ Ergo has inbuilt wallet API which is enough for most use-cases. API has Swagger interface (on 127.0.0.1:9053 by default in the mainnet, 127.0.0.1:9052 in the testnet) with descriptions and examples for API methods. How to set up a node: https://ergoplatform.org/en/blog/2019_12_02_how_to_setup/, https://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node Please run the node with -Xmx3G flag, e.g. java -jar -Xmx3G ergo-4.0.4.jar --mainnet -c mainnet.conf Node Wallet Node wallet has UI available @ 127.0.0.1:9053/panel by default on the mainnet (127.0.0.1:9052/panel on the testnet). Main methods: /wallet/init and /wallet/restore to create a wallet (and a secret mnemonic) and restore wallet from mnemonic /wallet/unlock to unlock the wallet (it is unlocked after init but locked after restart) /wallet/lock to lock the wallet /wallet/payment/send to send a simple payment /wallet/status to get wallet status /wallet/deriveNextKey to derive a new key according to EIP-3 (BIP 44 implementation for Ergo) /wallet/balances to get wallet balance (for all the addresses) /wallet/transactions to get wallet transactions (for all the addresses) Doing an external wallet If you are going to do wallet logic externally, you can do it with a library and also the block explorer. Please note, you need to consider mempool transactions to avoid double-spending generation . Available libraries are: ergo-wallet made in Java (sources are in Ergo node repository ) sigma-rust in Rust with WASM bindings for JavaScript/TypeScript ergo-ts in TypeScript ergo-golang in Go (still raw) Offline Signing Transaction assembly and offline signing demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/c040f244865a451b94df01032c7a3456 Transaction assembly and signing in Rust https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/tx_builder.rs#L552-L592 https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/signing.rs#L133-L161 Transaction assembly and signing in JavaScript https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/bindings/ergo-lib-wasm/tests/test_transaction.js#L9-L69 Composing transaction outside the node To get unspent UTXOs for some address, please use transactions/boxes/byAddress/unspent Explorer API method: https://api.ergoplatform.com/transactions/boxes/byAddress/unspent/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M . You need to exclude UTXOs spent in the mempool! Use /transactions/unconfirmed/byAddress Explorer API method for that: https://api.ergoplatform.com/transactions/unconfirmed/byAddress/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M Broadcasting transaction To broadcast a transaction made outside the node, the easiest way is to serialize it into JSON, in Java it could be like: Json json = JsonCodecsWrapper.ergoLikeTransactionEncoder().apply(tx); System.out.println(json.toString()); and then send this json via POST request to the public explorer https://api.ergoplatform.com/api/v0/transactions/send , your private explorer or a node with open API (POST to http://{node_ip}:9053/transactions ) Address generation Secret seed and derived addresses generation demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/70dcfa841dfb504721f09c911b0fc53d Own Testnet and Explorer Infrastructure You can use ergo-bootstrap to install Explorer backend easily (and so not rely on public ones). To start your own testnet, use the following node: ergo { networkType = \"testnet\" node { mining = true offlineGeneration = true useExternalMiner = false } } scorex { network { bindAddress = \"0.0.0.0:9020\" nodeName = \"ergo-testnet-4.0.4\" knownPeers = [] } restApi { # Hex-encoded Blake2b256 hash of an API key. Should be 64-chars long Base16 string. # Below is hash corresponding to API_KEY = \"hello\" (with no quotes) apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } } and then the node will CPU-mine its own chain. Any suggestions for improvements are welcomed! Please send them to team@ergoplatform.org or #development channel in Discord https://discord.gg/kj7s7nb","title":"Integration"},{"location":"dev/Integration/guide/#introduction","text":"Some quick facts useful for an integration: like Bitcoin, a transaction in Ergo has multiple inputs and outputs. Unspent outputs are single-use entities. However, Ergo is built from scratch thus scripts and transaction format are different. like in Bitcoin, there are some standard scripts in Ergo associated with addresses, e.g. P2PK addresses. There's an article on address scheme available: https://ergoplatform.org/en/blog/2019_07_24_ergo_address/ Ergo has inbuilt wallet API which is enough for most use-cases. API has Swagger interface (on 127.0.0.1:9053 by default in the mainnet, 127.0.0.1:9052 in the testnet) with descriptions and examples for API methods. How to set up a node: https://ergoplatform.org/en/blog/2019_12_02_how_to_setup/, https://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node Please run the node with -Xmx3G flag, e.g. java -jar -Xmx3G ergo-4.0.4.jar --mainnet -c mainnet.conf","title":"Introduction"},{"location":"dev/Integration/guide/#node-wallet","text":"Node wallet has UI available @ 127.0.0.1:9053/panel by default on the mainnet (127.0.0.1:9052/panel on the testnet). Main methods: /wallet/init and /wallet/restore to create a wallet (and a secret mnemonic) and restore wallet from mnemonic /wallet/unlock to unlock the wallet (it is unlocked after init but locked after restart) /wallet/lock to lock the wallet /wallet/payment/send to send a simple payment /wallet/status to get wallet status /wallet/deriveNextKey to derive a new key according to EIP-3 (BIP 44 implementation for Ergo) /wallet/balances to get wallet balance (for all the addresses) /wallet/transactions to get wallet transactions (for all the addresses)","title":"Node Wallet"},{"location":"dev/Integration/guide/#doing-an-external-wallet","text":"If you are going to do wallet logic externally, you can do it with a library and also the block explorer. Please note, you need to consider mempool transactions to avoid double-spending generation . Available libraries are: ergo-wallet made in Java (sources are in Ergo node repository ) sigma-rust in Rust with WASM bindings for JavaScript/TypeScript ergo-ts in TypeScript ergo-golang in Go (still raw)","title":"Doing an external wallet"},{"location":"dev/Integration/guide/#offline-signing","text":"Transaction assembly and offline signing demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/c040f244865a451b94df01032c7a3456 Transaction assembly and signing in Rust https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/tx_builder.rs#L552-L592 https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/signing.rs#L133-L161 Transaction assembly and signing in JavaScript https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/bindings/ergo-lib-wasm/tests/test_transaction.js#L9-L69","title":"Offline Signing"},{"location":"dev/Integration/guide/#composing-transaction-outside-the-node","text":"To get unspent UTXOs for some address, please use transactions/boxes/byAddress/unspent Explorer API method: https://api.ergoplatform.com/transactions/boxes/byAddress/unspent/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M . You need to exclude UTXOs spent in the mempool! Use /transactions/unconfirmed/byAddress Explorer API method for that: https://api.ergoplatform.com/transactions/unconfirmed/byAddress/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M","title":"Composing transaction outside the node"},{"location":"dev/Integration/guide/#broadcasting-transaction","text":"To broadcast a transaction made outside the node, the easiest way is to serialize it into JSON, in Java it could be like: Json json = JsonCodecsWrapper.ergoLikeTransactionEncoder().apply(tx); System.out.println(json.toString()); and then send this json via POST request to the public explorer https://api.ergoplatform.com/api/v0/transactions/send , your private explorer or a node with open API (POST to http://{node_ip}:9053/transactions )","title":"Broadcasting transaction"},{"location":"dev/Integration/guide/#address-generation","text":"Secret seed and derived addresses generation demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/70dcfa841dfb504721f09c911b0fc53d","title":"Address generation"},{"location":"dev/Integration/guide/#own-testnet-and-explorer-infrastructure","text":"You can use ergo-bootstrap to install Explorer backend easily (and so not rely on public ones). To start your own testnet, use the following node: ergo { networkType = \"testnet\" node { mining = true offlineGeneration = true useExternalMiner = false } } scorex { network { bindAddress = \"0.0.0.0:9020\" nodeName = \"ergo-testnet-4.0.4\" knownPeers = [] } restApi { # Hex-encoded Blake2b256 hash of an API key. Should be 64-chars long Base16 string. # Below is hash corresponding to API_KEY = \"hello\" (with no quotes) apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } } and then the node will CPU-mine its own chain. Any suggestions for improvements are welcomed! Please send them to team@ergoplatform.org or #development channel in Discord https://discord.gg/kj7s7nb","title":"Own Testnet and Explorer Infrastructure"},{"location":"dev/Languages/csharp/","text":"C Tutorials How-to Guides Ergo with C# 101 Explanations References","title":"C#"},{"location":"dev/Languages/csharp/#c","text":"","title":"C"},{"location":"dev/Languages/csharp/#tutorials","text":"","title":"Tutorials"},{"location":"dev/Languages/csharp/#how-to-guides","text":"Ergo with C# 101","title":"How-to Guides"},{"location":"dev/Languages/csharp/#explanations","text":"","title":"Explanations"},{"location":"dev/Languages/csharp/#references","text":"","title":"References"},{"location":"dev/Languages/java/","text":"Tutorials See AppKit How-to Guides See AppKit Explanations See AppKit References","title":"Java"},{"location":"dev/Languages/java/#tutorials","text":"See AppKit","title":"Tutorials"},{"location":"dev/Languages/java/#how-to-guides","text":"See AppKit","title":"How-to Guides"},{"location":"dev/Languages/java/#explanations","text":"See AppKit","title":"Explanations"},{"location":"dev/Languages/java/#references","text":"","title":"References"},{"location":"dev/Languages/rust/","text":"Rust sigma-rust is an alternative and simple implementation of ErgoTree interpreter and transaction building tools. The goal for the Rust version is to be on par with Scala version feature-wise. Now Rust version is still significantly behind. Also the goal for the Rust version is to have bindings for web, iOS and Android. The Scala version will continue to be the primary choice for JVM ecosystem with Rust version covering the rest. Contributing A list of \" good first \" issues is available on GitHub - @greenhat on Discord is ready to assist anyone who is interested. The sigma-rust GitHub repo is here . There is an issues tab with labeled tasks anyone can pick up. If you are working on something, leave a comment so others know. - contributing References This document describes the high-level architecture of ErgoScript compiler and ErgoTree interpreter. Rust port of AVL tree from scrypto package. Ergo Utilities | simplify writing off-chain code in Rust.","title":"Rust"},{"location":"dev/Languages/rust/#rust","text":"sigma-rust is an alternative and simple implementation of ErgoTree interpreter and transaction building tools. The goal for the Rust version is to be on par with Scala version feature-wise. Now Rust version is still significantly behind. Also the goal for the Rust version is to have bindings for web, iOS and Android. The Scala version will continue to be the primary choice for JVM ecosystem with Rust version covering the rest.","title":"Rust"},{"location":"dev/Languages/rust/#contributing","text":"A list of \" good first \" issues is available on GitHub - @greenhat on Discord is ready to assist anyone who is interested. The sigma-rust GitHub repo is here . There is an issues tab with labeled tasks anyone can pick up. If you are working on something, leave a comment so others know. - contributing","title":"Contributing"},{"location":"dev/Languages/rust/#references","text":"This document describes the high-level architecture of ErgoScript compiler and ErgoTree interpreter. Rust port of AVL tree from scrypto package. Ergo Utilities | simplify writing off-chain code in Rust.","title":"References"},{"location":"dev/Languages/scala/","text":"Scala Ergo's primary language is Scala. Similarily, the scripting language used by ergo - ergoscript , is based on Scala. Learn Tutorials, How to Guides and Explanations found in the relevent sections - See ErgoScript - See AppKit References Sigmastate-Interpreter | The Sigmastate-Interpreter is a ErgoScript compiler and ErgoTree Interpreter implementation for Ergo blockchain's Sigma Language For development of Ergo applications using JVM languages a better alternative is to use Appkit . ScoreX , the open-source, modular blockchain & cryptocurrency framework. Scrypto | Scrypto is an open source cryptographic toolkit designed to make it easier and safer for developers to use cryptography in their applications based on Scorex This library is used internally in Ergo Node and ergo-wallet , the public interfaces are subject to change.","title":"Scala"},{"location":"dev/Languages/scala/#scala","text":"Ergo's primary language is Scala. Similarily, the scripting language used by ergo - ergoscript , is based on Scala.","title":"Scala"},{"location":"dev/Languages/scala/#learn","text":"Tutorials, How to Guides and Explanations found in the relevent sections - See ErgoScript - See AppKit","title":"Learn"},{"location":"dev/Languages/scala/#references","text":"Sigmastate-Interpreter | The Sigmastate-Interpreter is a ErgoScript compiler and ErgoTree Interpreter implementation for Ergo blockchain's Sigma Language For development of Ergo applications using JVM languages a better alternative is to use Appkit . ScoreX , the open-source, modular blockchain & cryptocurrency framework. Scrypto | Scrypto is an open source cryptographic toolkit designed to make it easier and safer for developers to use cryptography in their applications based on Scorex This library is used internally in Ergo Node and ergo-wallet , the public interfaces are subject to change.","title":"References"},{"location":"dev/ergo/a/","text":"","title":"A"},{"location":"dev/ergo/apps/","text":"Applications Check out sigmaverse.io - your portal to the Ergo Universe dApps ErgoDex The ErgoLabs repositorty contains all the related code for ErgoDex EIP-0014: Decentalized Exchange Contracts Single-Chain Swap Contracts (DEX basis) by Alex Chepurnoy ErgoMixer ErgoMixer is the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space. Technical Slides: ZeroJoin: Combining Zerocoin and Coinjoin Video tutorial ErgoProfitSharingDapp This service will provide a way for dapps to distribute gains among dapps' token holders. The first user of this service will be the ErgoMixer. Ergomixer's income (in ERG and other tokens) is currently received by its creator, aka 'anon2020s', since it has only one stakeholder at the moment. He has announced that he is willing to create and sell some tokens in the near future to obtain more stakeholders; let's call this token MIX. later, anyone having the MIX tokens can stake these tokens in the Profit Sharing contract and obtain the mixer's incomes proportional to their staked tokens. So, it is NOT a way to stake ERG at first. But, it CAN BE USED in the future in some creative services to provide ERG-staking. A solution for staking Ergo Profit Sharing dApp ErgoAuctions The Ergo Auction House lets you buy and sell collectible tokens, art and much more. Source code v2 contracts SigmaUSD sigmausd.io , The first UTxO-based stable coin - an instantiation of the AgeUSD protocol . Its economic model designed in partnership between IOHK, Ergo, and Emurgo maintains the conservative settings for collateral reserves and avoids the need for liquidations. Along with that, it supports a fully decentralised stablecoin emission setup. The UI for the front-end is available at anon-real/sigma-usd Ergo Summit 2021 - The IOHK Perspective - Designing the AgeUSD StableCoin Overview Video (with diagrams) Building Ergo: How the AgeUSD stablecoin works Dexy Dexy: USD Simplest Stablecoin Raffle Zero-Knowledge ErgoFund In development - Ergo Crowdfunding CLI | Command-line tool which enables participating and interacting with crowdfunding campaigns on Ergo - Scanner - ZK Treasury | a tool for joint spendings with on-chain privacy - Server - Client - 'A Collective Spending Appproach' LETS Oracles When external oracle data is posted on-chain, it needs to be encoded in a very precise way within a transaction. Furthermore, oracle pools have a bunch of different moving parts which require transactions to be issued to move between the different stages of the pool protocol. Oracle Core creates all of the complex transactions which posts the data on-chain & runs the oracle pool protocol on-chain (such as averaging datapoints). This comes bundled with Oracle Pool Bootstrap and a Connector Library . The ada-usd-oracle source can be seen here. Currently only the erg-usd-oracle is live as seen in the Oracle Pool List See this overview by Robert Kornacki. Resources eth/usd connector Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. Learn about data inputs and the truly novel innovations they bring to UTXO-based Blockchains Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. See also a forum topic with example v2 Oracle pool 2.0 contracts finalized (for initial draft). Tests for oracle pool 2.0 Articles Chainlink Oracles vs. Ergo Oracle Pools Oracle Pools - A New Oracle Model First steps towards interoperability with Cardano oracles Ergo Blockchain: Oracle Pool Governance Update The role of Ergo Oracles Resources ErgoFaucet.org Various utilities are listed on ergosites.github.io ergo.watch | Git ERGOHACK ERGOHACK I - ErgoRaffle - Ergo Index Fund - Smart Pools - Sigma Stamp - Ergo Charts - Simpler Joint Spending Tool ERGOHACK II - ErgoLend - Minotaur Wallet - Ergopad - Ergo Subpooling - HYPO10USE: QUIDGAMES - Ergo Audio Many more possible! Bonds based on Ergo (or the \u201cYield protocol\u201d) An ICO Example On Top Of Ergo A Local Exchange Trading System On Top Of Ergo A Trustless Local Exchange Trading System (E)mail Client for Limited or Blocked Internet LETS start the discussion ErgoFans | Decentralised content producer platform | Patreon/Onlyfans ErgoGigs | Decentralised gigs! (Fiverr) ErgoEarn | earn for learning (Coinbase Earn) ErgoStats | on-chain analysis (glassnode)","title":"Applications"},{"location":"dev/ergo/apps/#applications","text":"Check out sigmaverse.io - your portal to the Ergo Universe","title":"Applications"},{"location":"dev/ergo/apps/#dapps","text":"","title":"dApps"},{"location":"dev/ergo/apps/#ergodex","text":"The ErgoLabs repositorty contains all the related code for ErgoDex EIP-0014: Decentalized Exchange Contracts Single-Chain Swap Contracts (DEX basis) by Alex Chepurnoy","title":"ErgoDex"},{"location":"dev/ergo/apps/#ergomixer","text":"ErgoMixer is the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space. Technical Slides: ZeroJoin: Combining Zerocoin and Coinjoin Video tutorial","title":"ErgoMixer"},{"location":"dev/ergo/apps/#ergoprofitsharingdapp","text":"This service will provide a way for dapps to distribute gains among dapps' token holders. The first user of this service will be the ErgoMixer. Ergomixer's income (in ERG and other tokens) is currently received by its creator, aka 'anon2020s', since it has only one stakeholder at the moment. He has announced that he is willing to create and sell some tokens in the near future to obtain more stakeholders; let's call this token MIX. later, anyone having the MIX tokens can stake these tokens in the Profit Sharing contract and obtain the mixer's incomes proportional to their staked tokens. So, it is NOT a way to stake ERG at first. But, it CAN BE USED in the future in some creative services to provide ERG-staking. A solution for staking Ergo Profit Sharing dApp","title":"ErgoProfitSharingDapp"},{"location":"dev/ergo/apps/#ergoauctions","text":"The Ergo Auction House lets you buy and sell collectible tokens, art and much more. Source code v2 contracts","title":"ErgoAuctions"},{"location":"dev/ergo/apps/#sigmausd","text":"sigmausd.io , The first UTxO-based stable coin - an instantiation of the AgeUSD protocol . Its economic model designed in partnership between IOHK, Ergo, and Emurgo maintains the conservative settings for collateral reserves and avoids the need for liquidations. Along with that, it supports a fully decentralised stablecoin emission setup. The UI for the front-end is available at anon-real/sigma-usd Ergo Summit 2021 - The IOHK Perspective - Designing the AgeUSD StableCoin Overview Video (with diagrams) Building Ergo: How the AgeUSD stablecoin works Dexy Dexy: USD Simplest Stablecoin","title":"SigmaUSD"},{"location":"dev/ergo/apps/#raffle","text":"","title":"Raffle"},{"location":"dev/ergo/apps/#zero-knowledge","text":"","title":"Zero-Knowledge"},{"location":"dev/ergo/apps/#ergofund","text":"In development - Ergo Crowdfunding CLI | Command-line tool which enables participating and interacting with crowdfunding campaigns on Ergo - Scanner - ZK Treasury | a tool for joint spendings with on-chain privacy - Server - Client - 'A Collective Spending Appproach'","title":"ErgoFund"},{"location":"dev/ergo/apps/#lets","text":"","title":"LETS"},{"location":"dev/ergo/apps/#oracles","text":"When external oracle data is posted on-chain, it needs to be encoded in a very precise way within a transaction. Furthermore, oracle pools have a bunch of different moving parts which require transactions to be issued to move between the different stages of the pool protocol. Oracle Core creates all of the complex transactions which posts the data on-chain & runs the oracle pool protocol on-chain (such as averaging datapoints). This comes bundled with Oracle Pool Bootstrap and a Connector Library . The ada-usd-oracle source can be seen here. Currently only the erg-usd-oracle is live as seen in the Oracle Pool List See this overview by Robert Kornacki. Resources eth/usd connector Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. Learn about data inputs and the truly novel innovations they bring to UTXO-based Blockchains Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. See also a forum topic with example v2 Oracle pool 2.0 contracts finalized (for initial draft). Tests for oracle pool 2.0 Articles Chainlink Oracles vs. Ergo Oracle Pools Oracle Pools - A New Oracle Model First steps towards interoperability with Cardano oracles Ergo Blockchain: Oracle Pool Governance Update The role of Ergo Oracles","title":"Oracles"},{"location":"dev/ergo/apps/#resources","text":"ErgoFaucet.org Various utilities are listed on ergosites.github.io ergo.watch | Git","title":"Resources"},{"location":"dev/ergo/apps/#ergohack","text":"ERGOHACK I - ErgoRaffle - Ergo Index Fund - Smart Pools - Sigma Stamp - Ergo Charts - Simpler Joint Spending Tool ERGOHACK II - ErgoLend - Minotaur Wallet - Ergopad - Ergo Subpooling - HYPO10USE: QUIDGAMES - Ergo Audio","title":"ERGOHACK"},{"location":"dev/ergo/apps/#many-more-possible","text":"Bonds based on Ergo (or the \u201cYield protocol\u201d) An ICO Example On Top Of Ergo A Local Exchange Trading System On Top Of Ergo A Trustless Local Exchange Trading System (E)mail Client for Limited or Blocked Internet LETS start the discussion ErgoFans | Decentralised content producer platform | Patreon/Onlyfans ErgoGigs | Decentralised gigs! (Fiverr) ErgoEarn | earn for learning (Coinbase Earn) ErgoStats | on-chain analysis (glassnode)","title":"Many more possible!"},{"location":"dev/ergo/box/","text":"Box A UTXO is short for unspent transaction output. We can also consider spent transaction outputs (UTXOs that have been spent). In Ergo, a transaction output (whether spent or unspent) is called a box. A box at the minimum has 4 pieces of information. The value in NanoErgs (1 Erg = 1000000000 NanoErgs). The guard script (like scriptPubKey of Bitcoin). This is also called the \"smart contract\". Additional assets (tokens) stored in this box. Creation info of the box (txId, the identifier of the transaction that created the box along with an output index). It also contains a \"maxCreation\" height parameter defined by the box creator (this is not the creation height; its use is to easily create \"payment-channels\"). These are stored in the first 4 registers (numbered R0-R3) of the box. In addition, a box can have 6 optional registers (R4-R9) to store custom data for use in smart contracts. Registers must be densely packed, that is, we cannot sandwich empty registers between non-empty ones. The optional registers can contain data of any of the following types: Int, Long with the usual semantics of Scala. BigInt which is a 256 bit integer (i.e., all computation is done modulo 2^256). GroupElement, a point on the Secp256k1 curve represented in compressed format. Coll[Byte], which is a collection of bytes, semantically similar to Array[Byte] in Scala. Collection of the above, i.e., Coll[Int], Coll[GroupElement], Coll[Coll[Byte]], etc. A boxId is calculated based on the contents of all the registers. This boxId uniquely defines a box and can be considered equivalent to Bitcoin's (txId, vOut) pairs. Note that Ergo txId depends only on the message and not on signatures (similar to Bitcoin SegWit transactions). Hence, a txId is available even before signing. Similar to Bitcoin, Ergo supports chained transactions (i.e., spending of boxes with 0 confirmations). Anatomy of an Ergo transaction Articles UTXO Model Transaction Off-chain Logic and eUTXO An Ergo transaction consists of: One or more Input boxes (source of funds). These boxes must already exist and will be destroyed. The guard script in each of these boxes will be evaluated and must return true for the transaction to be considered valid, One or more Output boxes (destination of funds). These boxes will be created. Zero or more Data-Inputs boxes. These are additional boxes whose data can be referenced and used by smart contracts of the inputs. The guard script in these boxes will not be evaluated. Data-inputs are unique to Ergo and not yet present in other extended-UTXO systems. A data-input box can be shared by multiple transactions and only a single reference to the box will be stored in the block. A data-input box can also be spent in the same transaction as long as it existed before the transaction was applied. As an example, the box with id d2b9b6536287b242f436436ce5a1e4a117d7b4843a13ce3abe3168bff99924a1 was used as both an input and a data-input in this transaction. While the use of data-inputs may not be immediately apparent, they play a major role in making Ergo more friendly to DeFi applications where we want to refer to a box without needing (or having the ability) to spend it, such as in decentralized order-books (DEX). For instance, the above transaction used a \"timestamping service\" to timestamp a box that was provided as a data-input. A script in Ergo can refer to other boxes in the transaction. For instance, the code snippet INPUTS(0).value > 10000 && OUTPUTS(1).value > 20000 in any of the inputs boxes would enforce that the first input and the second output boxes must have value greater than 10000 and 20000 respectively. Addresses In today's article, we will have a closer look into the Ergo address formatting. In addition to that we are going to explain how they work specifically as well as what makes them preferable to other types of blockchain addresses. Let's start at the very beginning. The moment you install any cryptocurrency wallet you automatically create an address with it. Very loosely speaking you can compare a wallet to a traditional bank account and an address to the matching account number. It is precisely one of these alphanumeric addresses that's needed to either send money from person A to person B, receive money or withdraw your mining rewards . If you want to get started using the Ergo wallet and dive deeper into its functions go check out the following link . Now, what exactly are addresses? Addresses are short strings that correspond to certain scripts and are used to protect a box ( this post that core developer kushti published on our forum explains very well what a \"box\" is). Unlike a (hex-encoded) binary representation of a script, an Ergo address is using a Base58-encoding and therefore has some very useful characteristics to it which the binary representation do not offer: The integrity of an address can easily be checked via an integrated checksum (which is a \"small-sized datum derived from a block of digital data for the purpose of detecting errors that may have been introduced during its transmission or storage\", according to Wikipedia). A prefix of the address is showing you the network and address type. In particular, the network prefix prevents you from mistakenly sending mainnet tokens to the testnet address. The address is using an encoding (namely, Base58 as mentioned) which is avoiding similarly looking characters and is friendly to double-clicking and also line-breaking in emails. An address is encoding network type, address type, checksum, and enough information to correspond with particular scripts. Let's look at the prefix byte which contains information about the network and address types: Possible network types are: Mainnet - 0x00 Testnet - 0x10 Address types are (semantics described below): 0x01 - Pay-to-PublicKey(P2PK) address 0x02 - Pay-to-Script-Hash(P2SH) 0x03 - Pay-to-Script(P2S) For an address type, we form content bytes as follows: P2PK - serialized (compressed) public key P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes P2S - serialized script (this is where mining rewards go!) For example, sending 10 Ergs to a P2PK address usually means that a corresponding transaction will contain a box in which 10 Ergs are locked by a public key encoded in the P2PK address. Similarly, in case of a P2S address the box will be locked by a script encoded in the address. In the most complicated case of a P2SH script, the box will be protected by a special predefined script which is taking first 192 bits of Blake2b256 hash value for a script which should be shown by an input spending the box. Here is an example of how particular addresses are going to look on the testnet: 3 - P2PK ( 3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN ) ? - P2SH ( rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB ) ? - P2S ( Ms7smJwLGbUAjuWQ ) And here is how what they look like on the mainnet: 9 - P2PK ( 9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA ) ? - P2SH ( 8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg ) ? - P2S ( 4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ ) In short summary: Prefix byte = network type + address type (for example, P2S script on the testnet starts with 0x13 before Base58) checksum = leftmost_4_bytes (blake2b256 (prefix byte || content bytes)) address = prefix byte || content bytes || checksum","title":"Adresses"},{"location":"dev/ergo/box/#box","text":"A UTXO is short for unspent transaction output. We can also consider spent transaction outputs (UTXOs that have been spent). In Ergo, a transaction output (whether spent or unspent) is called a box. A box at the minimum has 4 pieces of information. The value in NanoErgs (1 Erg = 1000000000 NanoErgs). The guard script (like scriptPubKey of Bitcoin). This is also called the \"smart contract\". Additional assets (tokens) stored in this box. Creation info of the box (txId, the identifier of the transaction that created the box along with an output index). It also contains a \"maxCreation\" height parameter defined by the box creator (this is not the creation height; its use is to easily create \"payment-channels\"). These are stored in the first 4 registers (numbered R0-R3) of the box. In addition, a box can have 6 optional registers (R4-R9) to store custom data for use in smart contracts. Registers must be densely packed, that is, we cannot sandwich empty registers between non-empty ones. The optional registers can contain data of any of the following types: Int, Long with the usual semantics of Scala. BigInt which is a 256 bit integer (i.e., all computation is done modulo 2^256). GroupElement, a point on the Secp256k1 curve represented in compressed format. Coll[Byte], which is a collection of bytes, semantically similar to Array[Byte] in Scala. Collection of the above, i.e., Coll[Int], Coll[GroupElement], Coll[Coll[Byte]], etc. A boxId is calculated based on the contents of all the registers. This boxId uniquely defines a box and can be considered equivalent to Bitcoin's (txId, vOut) pairs. Note that Ergo txId depends only on the message and not on signatures (similar to Bitcoin SegWit transactions). Hence, a txId is available even before signing. Similar to Bitcoin, Ergo supports chained transactions (i.e., spending of boxes with 0 confirmations).","title":"Box"},{"location":"dev/ergo/box/#anatomy-of-an-ergo-transaction","text":"Articles UTXO Model Transaction Off-chain Logic and eUTXO An Ergo transaction consists of: One or more Input boxes (source of funds). These boxes must already exist and will be destroyed. The guard script in each of these boxes will be evaluated and must return true for the transaction to be considered valid, One or more Output boxes (destination of funds). These boxes will be created. Zero or more Data-Inputs boxes. These are additional boxes whose data can be referenced and used by smart contracts of the inputs. The guard script in these boxes will not be evaluated. Data-inputs are unique to Ergo and not yet present in other extended-UTXO systems. A data-input box can be shared by multiple transactions and only a single reference to the box will be stored in the block. A data-input box can also be spent in the same transaction as long as it existed before the transaction was applied. As an example, the box with id d2b9b6536287b242f436436ce5a1e4a117d7b4843a13ce3abe3168bff99924a1 was used as both an input and a data-input in this transaction. While the use of data-inputs may not be immediately apparent, they play a major role in making Ergo more friendly to DeFi applications where we want to refer to a box without needing (or having the ability) to spend it, such as in decentralized order-books (DEX). For instance, the above transaction used a \"timestamping service\" to timestamp a box that was provided as a data-input. A script in Ergo can refer to other boxes in the transaction. For instance, the code snippet INPUTS(0).value > 10000 && OUTPUTS(1).value > 20000 in any of the inputs boxes would enforce that the first input and the second output boxes must have value greater than 10000 and 20000 respectively.","title":"Anatomy of an Ergo transaction"},{"location":"dev/ergo/box/#addresses","text":"In today's article, we will have a closer look into the Ergo address formatting. In addition to that we are going to explain how they work specifically as well as what makes them preferable to other types of blockchain addresses. Let's start at the very beginning. The moment you install any cryptocurrency wallet you automatically create an address with it. Very loosely speaking you can compare a wallet to a traditional bank account and an address to the matching account number. It is precisely one of these alphanumeric addresses that's needed to either send money from person A to person B, receive money or withdraw your mining rewards . If you want to get started using the Ergo wallet and dive deeper into its functions go check out the following link . Now, what exactly are addresses? Addresses are short strings that correspond to certain scripts and are used to protect a box ( this post that core developer kushti published on our forum explains very well what a \"box\" is). Unlike a (hex-encoded) binary representation of a script, an Ergo address is using a Base58-encoding and therefore has some very useful characteristics to it which the binary representation do not offer: The integrity of an address can easily be checked via an integrated checksum (which is a \"small-sized datum derived from a block of digital data for the purpose of detecting errors that may have been introduced during its transmission or storage\", according to Wikipedia). A prefix of the address is showing you the network and address type. In particular, the network prefix prevents you from mistakenly sending mainnet tokens to the testnet address. The address is using an encoding (namely, Base58 as mentioned) which is avoiding similarly looking characters and is friendly to double-clicking and also line-breaking in emails. An address is encoding network type, address type, checksum, and enough information to correspond with particular scripts. Let's look at the prefix byte which contains information about the network and address types: Possible network types are: Mainnet - 0x00 Testnet - 0x10 Address types are (semantics described below): 0x01 - Pay-to-PublicKey(P2PK) address 0x02 - Pay-to-Script-Hash(P2SH) 0x03 - Pay-to-Script(P2S) For an address type, we form content bytes as follows: P2PK - serialized (compressed) public key P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes P2S - serialized script (this is where mining rewards go!) For example, sending 10 Ergs to a P2PK address usually means that a corresponding transaction will contain a box in which 10 Ergs are locked by a public key encoded in the P2PK address. Similarly, in case of a P2S address the box will be locked by a script encoded in the address. In the most complicated case of a P2SH script, the box will be protected by a special predefined script which is taking first 192 bits of Blake2b256 hash value for a script which should be shown by an input spending the box. Here is an example of how particular addresses are going to look on the testnet: 3 - P2PK ( 3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN ) ? - P2SH ( rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB ) ? - P2S ( Ms7smJwLGbUAjuWQ ) And here is how what they look like on the mainnet: 9 - P2PK ( 9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA ) ? - P2SH ( 8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg ) ? - P2S ( 4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ ) In short summary: Prefix byte = network type + address type (for example, P2S script on the testnet starts with 0x13 before Base58) checksum = leftmost_4_bytes (blake2b256 (prefix byte || content bytes)) address = prefix byte || content bytes || checksum","title":"Addresses"},{"location":"dev/ergo/multi/","text":"Multi-Stage Contracts So you\u2019ve heard about smart contracts, but what are multi-stage contracts? Multi-stage contracts refer to smart contracts that are operating on a stateful level. Because Ergo uses the UTXO model, it is possible to process parallelized actions on top of smart contracts. For a blockchain to contain smart contracts, it should have loops. These loops can later refer to themselves and check whether an operation is working or not. Bitcoin\u2019s UTXO design is very primitive, and it doesn\u2019t contain Turing-complete smart contracts. Ethereum has this capability, but it\u2019s a primitive version of a Turing-complete language. Ergo Blockchain provides a different approach to multi-stage contracts, empowered by the extended UTXO model. Permitting a lighter network and broader use cases. Multi-Stage Contracts","title":"Multi-Stage Contracts"},{"location":"dev/ergo/multi/#multi-stage-contracts","text":"So you\u2019ve heard about smart contracts, but what are multi-stage contracts? Multi-stage contracts refer to smart contracts that are operating on a stateful level. Because Ergo uses the UTXO model, it is possible to process parallelized actions on top of smart contracts. For a blockchain to contain smart contracts, it should have loops. These loops can later refer to themselves and check whether an operation is working or not. Bitcoin\u2019s UTXO design is very primitive, and it doesn\u2019t contain Turing-complete smart contracts. Ethereum has this capability, but it\u2019s a primitive version of a Turing-complete language. Ergo Blockchain provides a different approach to multi-stage contracts, empowered by the extended UTXO model. Permitting a lighter network and broader use cases. Multi-Stage Contracts","title":"Multi-Stage Contracts"},{"location":"dev/ergo/nipopow/","text":"","title":"NiPoPoWS"},{"location":"dev/ergo/protocol/","text":"The Ergo Protocol Ergo builds advanced cryptographic features and radically new DeFi functionality on the rock-solid foundations laid by a decade of blockchain theory and development. It complements tried and tested principles with the latest peer-reviewed academic research into cryptography, consensus models and digital currencies. Ergo is a unique Proof-of-Work (PoW) cryptocurrency and DeFi platform, building on the first principles of Bitcoin. With a research-driven but practical development model, Ergo has prioritized useful features without compromising on security. The platform's smart contracts are built on the extended UTXO (eUTXO) model with a unique data input concept, offering a radically different approach to provide robust, flexible cryptography and easy, safe scripting on privacy-centric Sigma Protocols (non-interactive zero-knowledge proofs). Storage rent (~.13 erg every 4 years) for long-term survivability, ultra-efficient light clients , and NiPoPoW technology. Ergo is a UTXO based blockchain with Proof-of-Work consensus. In this aspect it is similar to Bitcoin. Ergo uses standard Elliptic Curve Cryptography and the exact same curve as Bitcoin ( Secp256k1 ). Unlike Bitcoin and similar to Cardano, Ergo uses a so called \"extended-UTXO model\", which implies UTXOs with the ability to contain arbitrary data and sophisticated scripts. Due to this, Ergo supports advanced financial contracts similar to those in Ethereum's account-based model. Contractual Money The cryptographic part of Ergo script is based on Sigma Protocols and naturally supports threshold m-of-n signatures, ring signatures and more. Keeping all this in mind, we expect ErgoScript and Ergo\u2019s design to be uniquely useful as Contractual Money with countless possible applications. The overwhelming majority of successful public blockchain use\u2010cases are related to financial applications. Ergo extends Bitcoin\u2019s way of writing contracts by attaching a guard script (together with additional custom data) to every coin. For example, in addition to regular protection by some m\u2010of\u2010n signature, Ergo allows specifying the possible recipients of these coins, which may also be a contract with similar complex conditions. This \"chaining\" approach allows the implementation of secure and efficient contracts of arbitrary complexity. This, along with Ergo's focus on sustainability is what makes it uniquely useful as contractual money. The scripting language in itself is non-Turing complete but applications ran on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper All cryptocurrencies rely on contributions from the scientific research community. Ergo brings it in its core! The Manifesto Cryptocurrency should provide tools to enrich ordinary people. Their small businesses providing no much above making ends meet, not depersonalized big financial capital. This is what inspired me. This is my dream. See the Ergo Manifesto Ergo Proof-of-Work (PoW) Ergo uses Autolykos as the underlying PoW algorithm. Autolykos v2 (current version of PoW) is memory-hard ASIC-resistant PoW algorithm oriented towards GPUs. Storage Rent Another unique feature of Ergo is the concept of storage-rent, which is the ability of miners to take out a small amount of Ergs from boxes that have remained unspent for four or more years (the box is spent and a new box is created with the lower value). This allows Ergo to avoid long-term bloat of the UTXO set. Building Ergo: Storage rent ErgoScript Ergo provides advanced programming abilities for financial contracts using a high-level language called ErgoScript. As a simple example, the below script allows only Alice to spend a box before a certain height and only Bob to spend the box after that. if (HEIGHT < 100000) alicePubKey else bobPubKey","title":"The Ergo Protocol"},{"location":"dev/ergo/protocol/#the-ergo-protocol","text":"Ergo builds advanced cryptographic features and radically new DeFi functionality on the rock-solid foundations laid by a decade of blockchain theory and development. It complements tried and tested principles with the latest peer-reviewed academic research into cryptography, consensus models and digital currencies. Ergo is a unique Proof-of-Work (PoW) cryptocurrency and DeFi platform, building on the first principles of Bitcoin. With a research-driven but practical development model, Ergo has prioritized useful features without compromising on security. The platform's smart contracts are built on the extended UTXO (eUTXO) model with a unique data input concept, offering a radically different approach to provide robust, flexible cryptography and easy, safe scripting on privacy-centric Sigma Protocols (non-interactive zero-knowledge proofs). Storage rent (~.13 erg every 4 years) for long-term survivability, ultra-efficient light clients , and NiPoPoW technology. Ergo is a UTXO based blockchain with Proof-of-Work consensus. In this aspect it is similar to Bitcoin. Ergo uses standard Elliptic Curve Cryptography and the exact same curve as Bitcoin ( Secp256k1 ). Unlike Bitcoin and similar to Cardano, Ergo uses a so called \"extended-UTXO model\", which implies UTXOs with the ability to contain arbitrary data and sophisticated scripts. Due to this, Ergo supports advanced financial contracts similar to those in Ethereum's account-based model.","title":"The Ergo Protocol"},{"location":"dev/ergo/protocol/#contractual-money","text":"The cryptographic part of Ergo script is based on Sigma Protocols and naturally supports threshold m-of-n signatures, ring signatures and more. Keeping all this in mind, we expect ErgoScript and Ergo\u2019s design to be uniquely useful as Contractual Money with countless possible applications. The overwhelming majority of successful public blockchain use\u2010cases are related to financial applications. Ergo extends Bitcoin\u2019s way of writing contracts by attaching a guard script (together with additional custom data) to every coin. For example, in addition to regular protection by some m\u2010of\u2010n signature, Ergo allows specifying the possible recipients of these coins, which may also be a contract with similar complex conditions. This \"chaining\" approach allows the implementation of secure and efficient contracts of arbitrary complexity. This, along with Ergo's focus on sustainability is what makes it uniquely useful as contractual money. The scripting language in itself is non-Turing complete but applications ran on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper All cryptocurrencies rely on contributions from the scientific research community. Ergo brings it in its core!","title":"Contractual Money"},{"location":"dev/ergo/protocol/#the-manifesto","text":"Cryptocurrency should provide tools to enrich ordinary people. Their small businesses providing no much above making ends meet, not depersonalized big financial capital. This is what inspired me. This is my dream. See the Ergo Manifesto","title":"The Manifesto"},{"location":"dev/ergo/protocol/#ergo-proof-of-work-pow","text":"Ergo uses Autolykos as the underlying PoW algorithm. Autolykos v2 (current version of PoW) is memory-hard ASIC-resistant PoW algorithm oriented towards GPUs.","title":"Ergo Proof-of-Work (PoW)"},{"location":"dev/ergo/protocol/#storage-rent","text":"Another unique feature of Ergo is the concept of storage-rent, which is the ability of miners to take out a small amount of Ergs from boxes that have remained unspent for four or more years (the box is spent and a new box is created with the lower value). This allows Ergo to avoid long-term bloat of the UTXO set. Building Ergo: Storage rent","title":"Storage Rent"},{"location":"dev/ergo/protocol/#ergoscript","text":"Ergo provides advanced programming abilities for financial contracts using a high-level language called ErgoScript. As a simple example, the below script allows only Alice to spend a box before a certain height and only Bob to spend the box after that. if (HEIGHT < 100000) alicePubKey else bobPubKey","title":"ErgoScript"},{"location":"dev/ergo/sigma/","text":"Ergo aims to provide an efficient, secure, and easy way to implement financial contracts that will be useful and survivable in the long term. There is plenty of uniqueness in Ergo but the most significant is probably Sigma protocols. These allow a true P2P system with privacy in mind. No one else at the moment is able to build a trustless LETS system, multisig with no signers disclosure, trustless payment networks or has real ring signatures that preserve zero knowledge.","title":"Sigma Protocols"},{"location":"dev/node/node-config/","text":"Wallets Linux Mac Windows HOME environment variable is not often set in Windows. Please replace ${HOME} with ${HOMEPATH} or ${APPDATA} in your configuration file. You should also remember that environment variables names are case sensitive in Windows. Pi How to setup an Ergo node on a Raspberry Pi Node Config File !!!Note!!! This guide is outdated and should be actualized to current config format Actual for version 1.6.1 Below you can find a complete Ergo Node configuration file. This is the default configuration shipped with the application. It is possible to overwrite any parameters by providing an additional configuration file. You can pass an additional configuration file by providing the path to it as the first command line parameter when starting Ergo Node application. ergo { # Directory to keep data directory = ${user.dir}\"/ergo/data\" # Settings for node view holder regime. See papers.yellow.ModifiersProcessing.md node { # State type. Possible options are: # \"utxo\" - keep full utxo set, that allows to validate arbitrary block and generate ADProofs # \"digest\" - keep state root hash only and validate transactions via ADProofs stateType = \"utxo\" # Download block transactions and verify them (requires BlocksToKeep == 0 if disabled) verifyTransactions = true # Number of last blocks to keep with transactions and ADproofs, for all other blocks only header will be stored. # Keep all blocks from genesis if negative blocksToKeep = -1 # Download PoPoW proof on node bootstrap PoPoWBootstrap = false # Minimal suffix size for PoPoW proof (may be pre-defined constant or settings parameter) minimalSuffix = 10 # Is the node is doing mining mining = false # If true, a node generates blocks being offline. The only really useful case for it probably is to start a new # blockchain offlineGeneration = false # Delay for miner after succesful block creation miningDelay = 5s # Number of state snapshot diffs to keep. Defines maximum rollback depth keepVersions = 200 } testing { # Whether to turn on transaction generator transactionGeneration = false # Max number of transactions generated per a new block received maxTransactionsPerBlock = 100 } cache { # Number of recently used modifiers that will be kept in memory modifiersCacheSize = 1000 # Number of recently used indexes that will be kept in memory indexesCacheSize = 10000 } # Chain-specific settings. Change only if you are going to launch a new chain! chain { # Network address prefix, currently reserved values are 0x00 (money chain mainnet) and 0x20 (32 in decimal, # money chain testnet) addressPrefix = 16 # Monetary config for chain monetary { # number of blocks reward won't change (525600 (2 years) for mainnet, 10080 (14 days) for testnet) fixedRatePeriod = 10080 # number of coins issued every block during fixedRatePeriod (75 Ergo) fixedRate = 7500000000 # number of blocks between reward reduction (64800 (90 days) for mainnet, 2160 (3 days) for testnet) epochLength = 2160 # number of coins reward decrease every epochs (3 Ergo) oneEpochReduction = 300000000 # Base16 representation of state roothash after genesis afterGenesisStateDigestHex = \"a8f724cef6f8a247a63fba1b713def858d97258f7cd5d7ed71489a474790db5501\" } # Desired time interval between blocks blockInterval = 2m # length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block epochLength = 256 # Number of last epochs that will be used for difficulty recalculation useLastEpochs = 8 # Proof-of-Work algorithm and its parameters. Possible options are \"fake\" and \"equihash\". powScheme { powType = \"equihash\" n = 96 # used by Equihash k = 5 # used by Equihash } # Defines an id of the genesis block. Other genesis blocks will be considered invalid. # genesisId = \"ab19bb59871e86507defb9a7769841b1130aad4d8c1ea8b0e01e0dee9e97a27e\" } wallet { # Seed the wallet private keys are derived from seed = \"C3FAFMC27697FAF29E9887F977BB5994\" # How many Schorr secret keys (w for the g^w public key) to generate dlogSecretsNumber = 4 # Interval to re-scan uncertain boxes. When a block arrives, its transaction outputs are to be scanned, and if # certain bytes are found in the output script (e.g. public key bytes), the box is to be put to a queue of a boxes # which are potentially wallet's. But to be sure, script execution is needed, which could be costly to do in a bulk. # So we check from a queue only one box per \"scanningInterval\". scanningInterval = 1s } } scorex { network { bindAddress = \"0.0.0.0:9006\" maxInvObjects = 400 nodeName = \"ergo-testnet1\" knownPeers = [\"178.128.162.150:9006\", \"78.46.93.239:9006\", \"209.97.136.204:9006\", \"209.97.138.187:9006\", \"209.97.134.210:9006\", \"88.198.13.202:9006\"] syncInterval = 15s syncStatusRefresh = 30s syncIntervalStable = 20s syncTimeout = 5s syncStatusRefreshStable = 1m deliveryTimeout = 8s maxDeliveryChecks = 2 appVersion = 0.2.1 agentName = \"ergoref\" maxModifiersCacheSize = 512 maxPacketSize = 2048576 } restApi { bindAddress = \"0.0.0.0:9052\" } } Ergo configuration section Root configuration section ergo holds essential application parameters and other configuration subsections. There is also another one root section scorex that holds the parameters inherited from the Scorex project . Using parameter directory it is possible to set a path to the base application directory. It is also possible to use environment variables to override configuration parameters. For example, by default the base directory is being constructed relatively to the user's HOME environment variable. Please do not enclose references to environment variables into quotation marks, otherwise they will be handled as strings and won't be resolved. Network settings In scorex.network section P2P network related settings could be set. Using declaredAddress parameter you can set the external IP address and port number of the node. It's necessary to work behind NAT in most cloud hosting, where the machine does not interface directly with the external address. If you do not specify it, then your node connects to the P2P network, but it won't listen to incoming connections so other nodes will not be able to connect. Other nodes are connected to your node using these data. The format of this parameter is \"[ip-address]:[port]\". Using parameter bindAddress you can set the IP address of local network interface on which Ergo Node will accept incoming connections. By default, node binds to \"0.0.0.0\" that means that it will listen on all available network adapters. Note about Internet Address settings Internet Address settings have <ip-adderss>:<port> format. Note the <port> part at the very end of the address after the colon. For the bindAddress setting port part is used to set the network port number to which other Ergo nodes will connect. Please ensure that the port is reachable from outside, otherwise your node will have only outgoing connections to P2P network. If the given port is taken by other application, your node won't start. Parameter nodeName could be used to set the name of your node visible to other participants of the P2P network. The name transmitted during initial handshake. In the default configuration, this parameter is commented out, which leads to random name generation. The knownPeers parameter stores the list of bootstrap nodes to which your node will establish outgoing connections while initializing. Note about time settings All time span parameters are set in milliseconds. You can also use duration units to shorten their values. Supported units are: * s, second, seconds * m, minute, minutes * h, hour, hours * d, day, days For usage examples see the default configuration file above. Use maxConnections parameter to set the maximum number of simultaneous connections handled by the node. Parameter connectionTimeout could be used to change the network communication timeout. Using handshakeTimeout parameter it is possible to set time period to wait for reply during handshake. In case of no reply the peer will be blacklisted. Using parameters that starts with upnp you can configure the UPnP settings. Actually, those settings are useful only if you ran your Ergo node on the home network where the node could ask your router to establish a tunnel. By default, this functionality is disabled. Use upnpEnabled parameter to enable this functionality. Wallet settings In wallet section you can configure the wallet built in Ergo node. Use dlogSecretsNumber parameter to specify how many Schorr secret keys (w for the g^w public key) to generate. Use scanningInterval parameter to set an interval of re-scaning uncertain boxes. Using seed parameter you could recreate an existing walled on a new node. If you don't have any existing wallet comment out this parameter and start the node. During the first run, the application will create a new wallet with a random seed for you. In this case, the seed will be displayed in the application log. Attention! The wallet is a critical part of your node. You should better store wallet's file in a safe and protected location. Don't forget to backup your wallet's file. It's recommended to remove the seed from the configuration file immediately after the start of the node. If an attacker gains access to this seed string, he has access to all your funds on all your addresses! Blockchain settings At ergo.chain you can select or custom the blockchain parameters. Use blockInterval parameter to set desired time interval between blocks. Parameter epochLength used to set the length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block useLastEpochs parameter stores a number of last epochs that will be used for difficulty recalculation. You can change the PoW algo or related parameters using powScheme section. Node settings In section ergo.node it is possible to configure parameters of the node regime. Use enable parameter to enable or disable block generation on the node. By default, it's disabled. Node with disabled offlineGeneration parameter will start mining as soon as it connects to the first peer in the P2P network. Setting this parameter to true will enable off-line generation. Using miningDelay parameter you can tune your node's mining delay after finding a new block. REST API settings In section scorex.rest-api you can set the node's REST API parameters. Parameter bindAddress could be used to select network interface on which REST API will accept incoming connections. The :<port> part could be used to change the port number, which REST API will listen for connections. Attention! For the better security, do not change bindAddress from \"127.0.0.1\" if you do not know what you're doing! For the external access you should use Nginx's proxy_pass module or SSH port-forwarding instead. Use api-key-hash parameter to set the hash of your API key. The API key is used to protect calls of critical API methods. Remember, that in this parameter you should provide the hash of API key, but during REST calls you should provide API key itself. You can use blake2b to produce the hash of your API key. Attention! API key is transmitted in the HTTP header as unprotected plain text! An attacker could intercept it in network transit and use it to transfer your money to any address! So you have to protect the transmission using HTTPS or use SSH port forwarding. Parameter corsAllowedOrigin could be used to enable or disable CORS support in REST API. CORS allows to safely resolve queries to other domains outside the one running the node. It's necessary for Swagger and Lite client. You can read about it here .","title":"Mobile"},{"location":"dev/node/node-config/#wallets","text":"","title":"Wallets"},{"location":"dev/node/node-config/#linux","text":"","title":"Linux"},{"location":"dev/node/node-config/#mac","text":"","title":"Mac"},{"location":"dev/node/node-config/#windows","text":"HOME environment variable is not often set in Windows. Please replace ${HOME} with ${HOMEPATH} or ${APPDATA} in your configuration file. You should also remember that environment variables names are case sensitive in Windows.","title":"Windows"},{"location":"dev/node/node-config/#pi","text":"How to setup an Ergo node on a Raspberry Pi","title":"Pi"},{"location":"dev/node/node-config/#node-config-file","text":"!!!Note!!! This guide is outdated and should be actualized to current config format","title":"Node Config File"},{"location":"dev/node/node-config/#actual-for-version-161","text":"Below you can find a complete Ergo Node configuration file. This is the default configuration shipped with the application. It is possible to overwrite any parameters by providing an additional configuration file. You can pass an additional configuration file by providing the path to it as the first command line parameter when starting Ergo Node application. ergo { # Directory to keep data directory = ${user.dir}\"/ergo/data\" # Settings for node view holder regime. See papers.yellow.ModifiersProcessing.md node { # State type. Possible options are: # \"utxo\" - keep full utxo set, that allows to validate arbitrary block and generate ADProofs # \"digest\" - keep state root hash only and validate transactions via ADProofs stateType = \"utxo\" # Download block transactions and verify them (requires BlocksToKeep == 0 if disabled) verifyTransactions = true # Number of last blocks to keep with transactions and ADproofs, for all other blocks only header will be stored. # Keep all blocks from genesis if negative blocksToKeep = -1 # Download PoPoW proof on node bootstrap PoPoWBootstrap = false # Minimal suffix size for PoPoW proof (may be pre-defined constant or settings parameter) minimalSuffix = 10 # Is the node is doing mining mining = false # If true, a node generates blocks being offline. The only really useful case for it probably is to start a new # blockchain offlineGeneration = false # Delay for miner after succesful block creation miningDelay = 5s # Number of state snapshot diffs to keep. Defines maximum rollback depth keepVersions = 200 } testing { # Whether to turn on transaction generator transactionGeneration = false # Max number of transactions generated per a new block received maxTransactionsPerBlock = 100 } cache { # Number of recently used modifiers that will be kept in memory modifiersCacheSize = 1000 # Number of recently used indexes that will be kept in memory indexesCacheSize = 10000 } # Chain-specific settings. Change only if you are going to launch a new chain! chain { # Network address prefix, currently reserved values are 0x00 (money chain mainnet) and 0x20 (32 in decimal, # money chain testnet) addressPrefix = 16 # Monetary config for chain monetary { # number of blocks reward won't change (525600 (2 years) for mainnet, 10080 (14 days) for testnet) fixedRatePeriod = 10080 # number of coins issued every block during fixedRatePeriod (75 Ergo) fixedRate = 7500000000 # number of blocks between reward reduction (64800 (90 days) for mainnet, 2160 (3 days) for testnet) epochLength = 2160 # number of coins reward decrease every epochs (3 Ergo) oneEpochReduction = 300000000 # Base16 representation of state roothash after genesis afterGenesisStateDigestHex = \"a8f724cef6f8a247a63fba1b713def858d97258f7cd5d7ed71489a474790db5501\" } # Desired time interval between blocks blockInterval = 2m # length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block epochLength = 256 # Number of last epochs that will be used for difficulty recalculation useLastEpochs = 8 # Proof-of-Work algorithm and its parameters. Possible options are \"fake\" and \"equihash\". powScheme { powType = \"equihash\" n = 96 # used by Equihash k = 5 # used by Equihash } # Defines an id of the genesis block. Other genesis blocks will be considered invalid. # genesisId = \"ab19bb59871e86507defb9a7769841b1130aad4d8c1ea8b0e01e0dee9e97a27e\" } wallet { # Seed the wallet private keys are derived from seed = \"C3FAFMC27697FAF29E9887F977BB5994\" # How many Schorr secret keys (w for the g^w public key) to generate dlogSecretsNumber = 4 # Interval to re-scan uncertain boxes. When a block arrives, its transaction outputs are to be scanned, and if # certain bytes are found in the output script (e.g. public key bytes), the box is to be put to a queue of a boxes # which are potentially wallet's. But to be sure, script execution is needed, which could be costly to do in a bulk. # So we check from a queue only one box per \"scanningInterval\". scanningInterval = 1s } } scorex { network { bindAddress = \"0.0.0.0:9006\" maxInvObjects = 400 nodeName = \"ergo-testnet1\" knownPeers = [\"178.128.162.150:9006\", \"78.46.93.239:9006\", \"209.97.136.204:9006\", \"209.97.138.187:9006\", \"209.97.134.210:9006\", \"88.198.13.202:9006\"] syncInterval = 15s syncStatusRefresh = 30s syncIntervalStable = 20s syncTimeout = 5s syncStatusRefreshStable = 1m deliveryTimeout = 8s maxDeliveryChecks = 2 appVersion = 0.2.1 agentName = \"ergoref\" maxModifiersCacheSize = 512 maxPacketSize = 2048576 } restApi { bindAddress = \"0.0.0.0:9052\" } }","title":"Actual for version 1.6.1"},{"location":"dev/node/node-config/#ergo-configuration-section","text":"Root configuration section ergo holds essential application parameters and other configuration subsections. There is also another one root section scorex that holds the parameters inherited from the Scorex project . Using parameter directory it is possible to set a path to the base application directory. It is also possible to use environment variables to override configuration parameters. For example, by default the base directory is being constructed relatively to the user's HOME environment variable. Please do not enclose references to environment variables into quotation marks, otherwise they will be handled as strings and won't be resolved.","title":"Ergo configuration section"},{"location":"dev/node/node-config/#network-settings","text":"In scorex.network section P2P network related settings could be set. Using declaredAddress parameter you can set the external IP address and port number of the node. It's necessary to work behind NAT in most cloud hosting, where the machine does not interface directly with the external address. If you do not specify it, then your node connects to the P2P network, but it won't listen to incoming connections so other nodes will not be able to connect. Other nodes are connected to your node using these data. The format of this parameter is \"[ip-address]:[port]\". Using parameter bindAddress you can set the IP address of local network interface on which Ergo Node will accept incoming connections. By default, node binds to \"0.0.0.0\" that means that it will listen on all available network adapters. Note about Internet Address settings Internet Address settings have <ip-adderss>:<port> format. Note the <port> part at the very end of the address after the colon. For the bindAddress setting port part is used to set the network port number to which other Ergo nodes will connect. Please ensure that the port is reachable from outside, otherwise your node will have only outgoing connections to P2P network. If the given port is taken by other application, your node won't start. Parameter nodeName could be used to set the name of your node visible to other participants of the P2P network. The name transmitted during initial handshake. In the default configuration, this parameter is commented out, which leads to random name generation. The knownPeers parameter stores the list of bootstrap nodes to which your node will establish outgoing connections while initializing. Note about time settings All time span parameters are set in milliseconds. You can also use duration units to shorten their values. Supported units are: * s, second, seconds * m, minute, minutes * h, hour, hours * d, day, days For usage examples see the default configuration file above. Use maxConnections parameter to set the maximum number of simultaneous connections handled by the node. Parameter connectionTimeout could be used to change the network communication timeout. Using handshakeTimeout parameter it is possible to set time period to wait for reply during handshake. In case of no reply the peer will be blacklisted. Using parameters that starts with upnp you can configure the UPnP settings. Actually, those settings are useful only if you ran your Ergo node on the home network where the node could ask your router to establish a tunnel. By default, this functionality is disabled. Use upnpEnabled parameter to enable this functionality. Wallet settings In wallet section you can configure the wallet built in Ergo node. Use dlogSecretsNumber parameter to specify how many Schorr secret keys (w for the g^w public key) to generate. Use scanningInterval parameter to set an interval of re-scaning uncertain boxes. Using seed parameter you could recreate an existing walled on a new node. If you don't have any existing wallet comment out this parameter and start the node. During the first run, the application will create a new wallet with a random seed for you. In this case, the seed will be displayed in the application log. Attention! The wallet is a critical part of your node. You should better store wallet's file in a safe and protected location. Don't forget to backup your wallet's file. It's recommended to remove the seed from the configuration file immediately after the start of the node. If an attacker gains access to this seed string, he has access to all your funds on all your addresses! Blockchain settings At ergo.chain you can select or custom the blockchain parameters. Use blockInterval parameter to set desired time interval between blocks. Parameter epochLength used to set the length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block useLastEpochs parameter stores a number of last epochs that will be used for difficulty recalculation. You can change the PoW algo or related parameters using powScheme section. Node settings In section ergo.node it is possible to configure parameters of the node regime. Use enable parameter to enable or disable block generation on the node. By default, it's disabled. Node with disabled offlineGeneration parameter will start mining as soon as it connects to the first peer in the P2P network. Setting this parameter to true will enable off-line generation. Using miningDelay parameter you can tune your node's mining delay after finding a new block. REST API settings In section scorex.rest-api you can set the node's REST API parameters. Parameter bindAddress could be used to select network interface on which REST API will accept incoming connections. The :<port> part could be used to change the port number, which REST API will listen for connections. Attention! For the better security, do not change bindAddress from \"127.0.0.1\" if you do not know what you're doing! For the external access you should use Nginx's proxy_pass module or SSH port-forwarding instead. Use api-key-hash parameter to set the hash of your API key. The API key is used to protect calls of critical API methods. Remember, that in this parameter you should provide the hash of API key, but during REST calls you should provide API key itself. You can use blake2b to produce the hash of your API key. Attention! API key is transmitted in the HTTP header as unprotected plain text! An attacker could intercept it in network transit and use it to transfer your money to any address! So you have to protect the transmission using HTTPS or use SSH port forwarding. Parameter corsAllowedOrigin could be used to enable or disable CORS support in REST API. CORS allows to safely resolve queries to other domains outside the one running the node. It's necessary for Swagger and Lite client. You can read about it here .","title":"Network settings"},{"location":"dev/node/run/","text":"How to set up and configure a full Ergo node This tutorial explains how to install and run a full Ergo node. It does not cover mining. Windows users can also watch the video tutorial. Node security There are a few important aspects of node usage that your wallet and money's safety depends on: * An Ergo node requires storing security-critical parameters in the configuration file. You should never make this file public. * An Ergo node provides a REST API for interacting with the built-in wallet. Sensitive API methods require a security token, which should never be sent over untrusted channels. * Access to the Ergo REST API must be restricted to known hosts. In particular, the API must not be accessible from the Internet. Prerequisites To run an Ergo node you need a JDK/JRE version >= 9 installed on your system. We recommend either version 9 or 11. One way to do this is to install Oracle Java SE . Note that Oracle JDK/JRE <= 8 is no longer supported . The next step is to download the latest Ergo client release jar file and create a node configuration file. Note that instead of downloading the precompiled Ergo jar, you can clone the repository and compile the jar from the source using SBT by issuing the sbt assembly command. Create a dedicated folder (such as ~/ergo ) for running the node. Denote by ergo_folder the folder where the jar is kept. Running the node for the first time Create a configuration file ergo.conf with the following text in ergo_folder . ergo { node { mining = false } } Open a command prompt and cd to ergo_folder . Then issue the following command to run the node for the first time: java -jar ergo-<release>.jar --mainnet -c ergo.conf The node will start syncing immediately after this. Wait for a few minutes for the API to start and go to the next step. Note: You can use any name for the file instead of ergo.conf . All configuration parameters are to be passed through this file and you only need to rewrite parameters that you want to change from the default values. The above config file actually has the default values. Compute the hash of your secret First, select a secret to protect your API. Then go to http://127.0.0.1:9053/swagger#/utils/hashBlake2b and call the API to compute the hash of your secret. Refer to the image below. Copy the response containing the hash for use in the next step (see below image). In our example, the secret is hello whose hash corresponds to 324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf . IMPORTANT You must use a different and strong secret. Update config file with API key hash Edit the config file ergo.conf and paste the hash copied in the previous step. The file should look as follows: ergo { node { mining = false } } scorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string 'hello' # replace with your actual hash apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } } Initialize wallet Restart the node and go to http://127.0.0.1:9053/panel to access the panel. Then set the API key secret from the previous step. Note that you need to set the secret and not the hash from the config file. In our example, this is the string hello . Click on Initialize wallet . After the pop-up opens, there are two ways to proceed depending on your scenario. If this is the first time you are running the node then you need to initialize it with a new mnemonic sentence. If you had created a wallet earlier and would like to obtain the same address (possibly because there are funds stored in it), then you have to restore the wallet using the mnemonic sentence you had saved earlier. Follow one of the below steps depending on your situation. Initialize wallet from scratch In the pop-up that opens, you must enter a wallet password. The mnemonic password is optional. After you click send, the wallet will return a mnemonic sentence as shown below. You must copy this sentence and save it in a safe place. This sentence will be needed to restore the wallet on a different computer. Restore wallet from earlier Copy the mnemonic sentence from earlier paste it into the \"Mnemonic\" field in the Restore-wallet form. Enter a secure wallet password. Leave the Mnemonic password empty (it is only for advanced users). Refer to the figure below. After the wallet has been successfully restored from the mnemonic sentence, you will see a confirmation as shown in the figure below. Get wallet addresses This is a test to ensure you have set up the node properly. It will return the current addresses in the wallet. In the panel at http://127.0.0.1:9053/panel click on the Wallet tab on the left and then on Get all wallet addresses to view the addresses currently maintained by the wallet. It should return at least one address if the node is set correctly. Check if the node is synced While the node is syncing, the panel will show \"Active synchronization\" (see the image below). After the node is fully synced, the text will change to \"Node is synced\", as shown below. Check wallet balance Once the node is synced, use the wallet API in the panel to see your balance, as shown below. Sending funds If there is a non-zero balance, you can send Ergs to any other address using the panel as shown below: View the Swagger UI A Swagger UI is available at http://127.0.0.1:9053/swagger . You had already used it earlier to compute the hash of your secret. You can also use this UI to make API calls for advanced operations that are not (yet) available in the panel. Some examples of this are: Creating non-standard transactions with registers and context variables. Creating transactions that issue tokens. Creating transactions that use certain boxes as inputs. A future article will discuss each of these operations in detail. Note that most methods in the API are protected and you would need to use your secret (from earlier) to access these methods. The following images show the process of setting this secret in the Swagger UI. Navigate to the top of the page and click the \"Authorize\" button. Enter your secret in the form that pops-up as shown in the figure below. After the password is entered and you have clicked \"Authorize\", you will be shown the popup below: Now navigate to http://127.0.0.1:9053/swagger#/wallet/walletAddresses in the same tab where you entered the password and click on \"Try it out\". You should see the same list of addresses as you saw earlier from the panel.","title":"Run"},{"location":"dev/node/run/#how-to-set-up-and-configure-a-full-ergo-node","text":"This tutorial explains how to install and run a full Ergo node. It does not cover mining. Windows users can also watch the video tutorial.","title":"How to set up and configure a full Ergo node"},{"location":"dev/node/run/#node-security","text":"There are a few important aspects of node usage that your wallet and money's safety depends on: * An Ergo node requires storing security-critical parameters in the configuration file. You should never make this file public. * An Ergo node provides a REST API for interacting with the built-in wallet. Sensitive API methods require a security token, which should never be sent over untrusted channels. * Access to the Ergo REST API must be restricted to known hosts. In particular, the API must not be accessible from the Internet.","title":"Node security"},{"location":"dev/node/run/#prerequisites","text":"To run an Ergo node you need a JDK/JRE version >= 9 installed on your system. We recommend either version 9 or 11. One way to do this is to install Oracle Java SE . Note that Oracle JDK/JRE <= 8 is no longer supported . The next step is to download the latest Ergo client release jar file and create a node configuration file. Note that instead of downloading the precompiled Ergo jar, you can clone the repository and compile the jar from the source using SBT by issuing the sbt assembly command. Create a dedicated folder (such as ~/ergo ) for running the node. Denote by ergo_folder the folder where the jar is kept.","title":"Prerequisites"},{"location":"dev/node/run/#running-the-node-for-the-first-time","text":"Create a configuration file ergo.conf with the following text in ergo_folder . ergo { node { mining = false } } Open a command prompt and cd to ergo_folder . Then issue the following command to run the node for the first time: java -jar ergo-<release>.jar --mainnet -c ergo.conf The node will start syncing immediately after this. Wait for a few minutes for the API to start and go to the next step. Note: You can use any name for the file instead of ergo.conf . All configuration parameters are to be passed through this file and you only need to rewrite parameters that you want to change from the default values. The above config file actually has the default values.","title":"Running the node for the first time"},{"location":"dev/node/run/#compute-the-hash-of-your-secret","text":"First, select a secret to protect your API. Then go to http://127.0.0.1:9053/swagger#/utils/hashBlake2b and call the API to compute the hash of your secret. Refer to the image below. Copy the response containing the hash for use in the next step (see below image). In our example, the secret is hello whose hash corresponds to 324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf . IMPORTANT You must use a different and strong secret.","title":"Compute the hash of your secret"},{"location":"dev/node/run/#update-config-file-with-api-key-hash","text":"Edit the config file ergo.conf and paste the hash copied in the previous step. The file should look as follows: ergo { node { mining = false } } scorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string 'hello' # replace with your actual hash apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } }","title":"Update config file with API key hash"},{"location":"dev/node/run/#initialize-wallet","text":"Restart the node and go to http://127.0.0.1:9053/panel to access the panel. Then set the API key secret from the previous step. Note that you need to set the secret and not the hash from the config file. In our example, this is the string hello . Click on Initialize wallet . After the pop-up opens, there are two ways to proceed depending on your scenario. If this is the first time you are running the node then you need to initialize it with a new mnemonic sentence. If you had created a wallet earlier and would like to obtain the same address (possibly because there are funds stored in it), then you have to restore the wallet using the mnemonic sentence you had saved earlier. Follow one of the below steps depending on your situation.","title":"Initialize wallet"},{"location":"dev/node/run/#initialize-wallet-from-scratch","text":"In the pop-up that opens, you must enter a wallet password. The mnemonic password is optional. After you click send, the wallet will return a mnemonic sentence as shown below. You must copy this sentence and save it in a safe place. This sentence will be needed to restore the wallet on a different computer.","title":"Initialize wallet from scratch"},{"location":"dev/node/run/#restore-wallet-from-earlier","text":"Copy the mnemonic sentence from earlier paste it into the \"Mnemonic\" field in the Restore-wallet form. Enter a secure wallet password. Leave the Mnemonic password empty (it is only for advanced users). Refer to the figure below. After the wallet has been successfully restored from the mnemonic sentence, you will see a confirmation as shown in the figure below.","title":"Restore wallet from earlier"},{"location":"dev/node/run/#get-wallet-addresses","text":"This is a test to ensure you have set up the node properly. It will return the current addresses in the wallet. In the panel at http://127.0.0.1:9053/panel click on the Wallet tab on the left and then on Get all wallet addresses to view the addresses currently maintained by the wallet. It should return at least one address if the node is set correctly.","title":"Get wallet addresses"},{"location":"dev/node/run/#check-if-the-node-is-synced","text":"While the node is syncing, the panel will show \"Active synchronization\" (see the image below). After the node is fully synced, the text will change to \"Node is synced\", as shown below.","title":"Check if the node is synced"},{"location":"dev/node/run/#check-wallet-balance","text":"Once the node is synced, use the wallet API in the panel to see your balance, as shown below.","title":"Check wallet balance"},{"location":"dev/node/run/#sending-funds","text":"If there is a non-zero balance, you can send Ergs to any other address using the panel as shown below:","title":"Sending funds"},{"location":"dev/node/run/#view-the-swagger-ui","text":"A Swagger UI is available at http://127.0.0.1:9053/swagger . You had already used it earlier to compute the hash of your secret. You can also use this UI to make API calls for advanced operations that are not (yet) available in the panel. Some examples of this are: Creating non-standard transactions with registers and context variables. Creating transactions that issue tokens. Creating transactions that use certain boxes as inputs. A future article will discuss each of these operations in detail. Note that most methods in the API are protected and you would need to use your secret (from earlier) to access these methods. The following images show the process of setting this secret in the Swagger UI. Navigate to the top of the page and click the \"Authorize\" button. Enter your secret in the form that pops-up as shown in the figure below. After the password is entered and you have clicked \"Authorize\", you will be shown the popup below: Now navigate to http://127.0.0.1:9053/swagger#/wallet/walletAddresses in the same tab where you entered the password and click on \"Try it out\". You should see the same list of addresses as you saw earlier from the panel.","title":"View the Swagger UI"},{"location":"dev/p2p/p2p-handshake/","text":"Handshaking To establish a connection with another peer, handshake messages exchange is needed in the first place. This document describes handshaking procedure and messages format. Peer Feature Every peer can have one or more peer features. A peer feature describes some properties of a peer. Features are embedded into a handshake message and remain unchanged during the connection. Features are optional by default: a peer can add new ones, and if another peer is not recognizing it, the feature will be skipped. Feature format is arbitrary. Any number of features can be added to the handshake, only handshake message has size limit (8 KB). The only feature the reference client supported before 3.3.7 is \"mode feature\" (describing operating regime of the peer). Since 3.3.7, a new feature describing network magic and (pseudorandom) session id added Handshake Format Length Field Name Details 6-8 Time Reported handshake time (VLQ-encoded, 6 bytes now, 8 bytes max) 1 Agent name length Length of agent name string (unsigned byte) 0-255 Agent name Agent name (e.g. \"Cypra wallet\") in UTF-8 encoding, 255 bytes max 3 Network protocol version Protocol version (e.g. [0, 1, 1] 1 Peer name length Length of peer name string 0-255 Peer name Peer name (e.g. \"kushti's node\") in UTF-8 encoding, 255 bytes max 1 Public node flag Flag indicating whether the node has a public address (0 or 1) (1) Public address length Length of public address (*) Public address Public IP address bytes, IPv4 of IPv6, 4 or 6 bytes, see Note 2 (4) Public address port Public address port 1 Number of peer features How many features are encoded further (unsigned byte) * Features Serialized features, one after another (specified below) For client capabilities (Mode feature): | Length | Field Name | Details | | :------------ | :------------------------------------- | :----------- | |1 | Feature id | for mode feature = 16 | |1-2 | Feature body length | Length of feature description (VLQ-encoded, up to 2 bytes)| |1 | State type | State representation, 0 = utxo, 1 = digest | |1 | Whether the peer verifying transactions | 1 = transactions being verified, 0 = not verified | |1 | Whether the node bootstrapped via NiPoPoW | 1 if yes, 0 if no (then following field is missed) | |(4) | Nipopow suffix length | Suffix length for NiPoPoW bootstrapping | |1-4 | How many block kept | signed integer (ZigZag then VLQ encoded), if -1 then all the blocks are stored | For session peer feature introduced in 3.3.7: Length Field Name Details 1 Feature id for session feature = 3 1-2 Feature body length Length of feature description (VLQ-encoded, up to 2 bytes) 4 Network magic Network magic bytes, see notes 8 Session id 64 bits long random session id Notes: 1. For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). 2. For IPv4 or IP6 address bytes, \"The result is in network byte order: the highest order byte of the address is in \"getAddress()[0]\". Please check Inet4Address.getAddress() or Inet4Address.getAddress() in Java's JDK for details. 3. For reference client, session id is currently used only to avoid connections to self Handshake Procedure A peer is sending a handshake message, another replies. If there's no handshake got within \"handshakeTimeout\", then connection is dropped. Default value for handshakeTimeout = 30s","title":"P2P Handshaking"},{"location":"dev/p2p/p2p-handshake/#handshaking","text":"To establish a connection with another peer, handshake messages exchange is needed in the first place. This document describes handshaking procedure and messages format.","title":"Handshaking"},{"location":"dev/p2p/p2p-handshake/#peer-feature","text":"Every peer can have one or more peer features. A peer feature describes some properties of a peer. Features are embedded into a handshake message and remain unchanged during the connection. Features are optional by default: a peer can add new ones, and if another peer is not recognizing it, the feature will be skipped. Feature format is arbitrary. Any number of features can be added to the handshake, only handshake message has size limit (8 KB). The only feature the reference client supported before 3.3.7 is \"mode feature\" (describing operating regime of the peer). Since 3.3.7, a new feature describing network magic and (pseudorandom) session id added","title":"Peer Feature"},{"location":"dev/p2p/p2p-handshake/#handshake-format","text":"Length Field Name Details 6-8 Time Reported handshake time (VLQ-encoded, 6 bytes now, 8 bytes max) 1 Agent name length Length of agent name string (unsigned byte) 0-255 Agent name Agent name (e.g. \"Cypra wallet\") in UTF-8 encoding, 255 bytes max 3 Network protocol version Protocol version (e.g. [0, 1, 1] 1 Peer name length Length of peer name string 0-255 Peer name Peer name (e.g. \"kushti's node\") in UTF-8 encoding, 255 bytes max 1 Public node flag Flag indicating whether the node has a public address (0 or 1) (1) Public address length Length of public address (*) Public address Public IP address bytes, IPv4 of IPv6, 4 or 6 bytes, see Note 2 (4) Public address port Public address port 1 Number of peer features How many features are encoded further (unsigned byte) * Features Serialized features, one after another (specified below) For client capabilities (Mode feature): | Length | Field Name | Details | | :------------ | :------------------------------------- | :----------- | |1 | Feature id | for mode feature = 16 | |1-2 | Feature body length | Length of feature description (VLQ-encoded, up to 2 bytes)| |1 | State type | State representation, 0 = utxo, 1 = digest | |1 | Whether the peer verifying transactions | 1 = transactions being verified, 0 = not verified | |1 | Whether the node bootstrapped via NiPoPoW | 1 if yes, 0 if no (then following field is missed) | |(4) | Nipopow suffix length | Suffix length for NiPoPoW bootstrapping | |1-4 | How many block kept | signed integer (ZigZag then VLQ encoded), if -1 then all the blocks are stored | For session peer feature introduced in 3.3.7: Length Field Name Details 1 Feature id for session feature = 3 1-2 Feature body length Length of feature description (VLQ-encoded, up to 2 bytes) 4 Network magic Network magic bytes, see notes 8 Session id 64 bits long random session id Notes: 1. For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). 2. For IPv4 or IP6 address bytes, \"The result is in network byte order: the highest order byte of the address is in \"getAddress()[0]\". Please check Inet4Address.getAddress() or Inet4Address.getAddress() in Java's JDK for details. 3. For reference client, session id is currently used only to avoid connections to self","title":"Handshake Format"},{"location":"dev/p2p/p2p-handshake/#handshake-procedure","text":"A peer is sending a handshake message, another replies. If there's no handshake got within \"handshakeTimeout\", then connection is dropped. Default value for handshakeTimeout = 30s","title":"Handshake Procedure"},{"location":"dev/p2p/p2p-protocol/","text":"Handshake First of all, nodes are doing handshaking by sending each other handshake messages. Handshaking details are provided in dedicated P2P Handshaking doc Message format Every message in P2P protocol has the following format: Length Field Name Details 4 Magic bytes Network-specific magic bytes, see Note 1. 1 Message code One byte describing message type 4 Message body length Length of handshake body (specified below), as signed 32-bit integer 4 Handshake body checksum First four bytes of blake2b(message body) * Message body Message body (specified below) Notes: 1. For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). 2. No VLQ and ZigZag encoding is used for message length (for historical reasons), bytes are coming in big-endian order. [TODO: provide descriptions for possible values of message body] Syncing","title":"P2P Protocol"},{"location":"dev/p2p/p2p-protocol/#handshake","text":"First of all, nodes are doing handshaking by sending each other handshake messages. Handshaking details are provided in dedicated P2P Handshaking doc","title":"Handshake"},{"location":"dev/p2p/p2p-protocol/#message-format","text":"Every message in P2P protocol has the following format: Length Field Name Details 4 Magic bytes Network-specific magic bytes, see Note 1. 1 Message code One byte describing message type 4 Message body length Length of handshake body (specified below), as signed 32-bit integer 4 Handshake body checksum First four bytes of blake2b(message body) * Message body Message body (specified below) Notes: 1. For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). 2. No VLQ and ZigZag encoding is used for message length (for historical reasons), bytes are coming in big-endian order. [TODO: provide descriptions for possible values of message body]","title":"Message format"},{"location":"dev/p2p/p2p-protocol/#syncing","text":"","title":"Syncing"},{"location":"dev/stack/back-end/","text":"Back-end This page provides an overview of the tools used to interact with the Ergo blockchain. Developers can use these tools to read data from the blockchain, compute using that data and optionally create transactions to be broadcast. Each tool requires the developer to \"program\" in some language. Users of AppKit will usually write Scala code (although AppKit supports many other languages). HDF users will need to write Rust code. JDE users will have to write JSON. JDE Ergo JDE Tutorials How-to Guides Example: Minting Reserve Coins Writing JDE Scripts Using the web service Explanations References Sample Scripts Syntax Headless dApp Framework Ergo Headless dApp Framework . The premier Rust framework for developing Ergo Headless dApps. The Ergo HDF provides developers with the very first portable UTXO-based headless dApp development framework on any blockchain. Tutorials Math Bounty Headless dApp - Getting Started Writing Your First Action Math Bounty Headless dApp - Finishing The Headless dApp Math Bounty Headless dApp - Writing A CLI Frontend For Creating Bounties Explanations Understanding The Ergo Headless dApp Framework Appkit AppKit provides methods for the following Fetch data from Ergo Explorer API Interact with Ergo Node, both public and private methods Build transactions and sign them Helper methods to handle cryptographics like calculating PK addresses from secrets Appkit: A Library for Polyglot Development of Ergo Applications has an idiomatic Java API and is written in Java/Scala. It is a thin wrapper around core components provided by the ErgoScript interpreter and Ergo protocol implementations which are written in Scala. It is published on maven repository and cross compiled to both Java 7 and Java 8+ jars. Using Appkit Ergo applications can be written in one of the languages supported by GraalVM (i.e. Java, JavaScript, C/C++, Python, Ruby, R) and using this library applications can communicate with Ergo nodes via unified API and programming model provided by Appkit. In addition Appkit based Ergo applications can be compiled into native code using native-image ahead of time compiler and then executed without Java VM with very fast startup time and lower runtime memory overhead compared to a Java VM. This is attractive option for high-performance low-latency microservices. Tutorials Tutorial starting with Appkit on Gradle projects AppKit by Example (Video) Appkit Examples How-to Guides Ergo Android | Example Android application which demonstrates how Ergo Appkit can be used to develop Ergo applications running on Android. Explanations AppKit Introduction . References ErgoTool | A Command Line Interface for Ergo based on Appkit and GraalVM native-image. Read the introduction and overview .","title":"Backend"},{"location":"dev/stack/back-end/#back-end","text":"This page provides an overview of the tools used to interact with the Ergo blockchain. Developers can use these tools to read data from the blockchain, compute using that data and optionally create transactions to be broadcast. Each tool requires the developer to \"program\" in some language. Users of AppKit will usually write Scala code (although AppKit supports many other languages). HDF users will need to write Rust code. JDE users will have to write JSON.","title":"Back-end"},{"location":"dev/stack/back-end/#jde","text":"Ergo JDE","title":"JDE"},{"location":"dev/stack/back-end/#tutorials","text":"","title":"Tutorials"},{"location":"dev/stack/back-end/#how-to-guides","text":"Example: Minting Reserve Coins Writing JDE Scripts Using the web service","title":"How-to Guides"},{"location":"dev/stack/back-end/#explanations","text":"","title":"Explanations"},{"location":"dev/stack/back-end/#references","text":"Sample Scripts Syntax","title":"References"},{"location":"dev/stack/back-end/#headless-dapp-framework","text":"Ergo Headless dApp Framework . The premier Rust framework for developing Ergo Headless dApps. The Ergo HDF provides developers with the very first portable UTXO-based headless dApp development framework on any blockchain.","title":"Headless dApp Framework"},{"location":"dev/stack/back-end/#tutorials_1","text":"Math Bounty Headless dApp - Getting Started Writing Your First Action Math Bounty Headless dApp - Finishing The Headless dApp Math Bounty Headless dApp - Writing A CLI Frontend For Creating Bounties","title":"Tutorials"},{"location":"dev/stack/back-end/#explanations_1","text":"Understanding The Ergo Headless dApp Framework","title":"Explanations"},{"location":"dev/stack/back-end/#appkit","text":"AppKit provides methods for the following Fetch data from Ergo Explorer API Interact with Ergo Node, both public and private methods Build transactions and sign them Helper methods to handle cryptographics like calculating PK addresses from secrets Appkit: A Library for Polyglot Development of Ergo Applications has an idiomatic Java API and is written in Java/Scala. It is a thin wrapper around core components provided by the ErgoScript interpreter and Ergo protocol implementations which are written in Scala. It is published on maven repository and cross compiled to both Java 7 and Java 8+ jars. Using Appkit Ergo applications can be written in one of the languages supported by GraalVM (i.e. Java, JavaScript, C/C++, Python, Ruby, R) and using this library applications can communicate with Ergo nodes via unified API and programming model provided by Appkit. In addition Appkit based Ergo applications can be compiled into native code using native-image ahead of time compiler and then executed without Java VM with very fast startup time and lower runtime memory overhead compared to a Java VM. This is attractive option for high-performance low-latency microservices.","title":"Appkit"},{"location":"dev/stack/back-end/#tutorials_2","text":"Tutorial starting with Appkit on Gradle projects AppKit by Example (Video) Appkit Examples","title":"Tutorials"},{"location":"dev/stack/back-end/#how-to-guides_1","text":"Ergo Android | Example Android application which demonstrates how Ergo Appkit can be used to develop Ergo applications running on Android.","title":"How-to Guides"},{"location":"dev/stack/back-end/#explanations_2","text":"AppKit Introduction .","title":"Explanations"},{"location":"dev/stack/back-end/#references_1","text":"ErgoTool | A Command Line Interface for Ergo based on Appkit and GraalVM native-image. Read the introduction and overview .","title":"References"},{"location":"dev/stack/ergoscript/","text":"Proxy Contracts Decentralisation Transaction Chaining Address Learn Tutorials (Video) Learn ErgoScript By Example Via The Ergo Playground with Robert Kornacki Advanced ErgoScript Tutorial ErgoScript tutorial How-to Guides Explanations ErgoScript Design patterns SigmaState Protocols References A Quick Primer on ErgoScript ErgoScript Language Description","title":"ErgoScript"},{"location":"dev/stack/ergoscript/#proxy-contracts","text":"","title":"Proxy Contracts"},{"location":"dev/stack/ergoscript/#decentralisation","text":"","title":"Decentralisation"},{"location":"dev/stack/ergoscript/#transaction-chaining","text":"","title":"Transaction Chaining"},{"location":"dev/stack/ergoscript/#address","text":"","title":"Address"},{"location":"dev/stack/ergoscript/#learn","text":"","title":"Learn"},{"location":"dev/stack/ergoscript/#tutorials","text":"(Video) Learn ErgoScript By Example Via The Ergo Playground with Robert Kornacki Advanced ErgoScript Tutorial ErgoScript tutorial","title":"Tutorials"},{"location":"dev/stack/ergoscript/#how-to-guides","text":"","title":"How-to Guides"},{"location":"dev/stack/ergoscript/#explanations","text":"ErgoScript Design patterns SigmaState Protocols","title":"Explanations"},{"location":"dev/stack/ergoscript/#references","text":"A Quick Primer on ErgoScript ErgoScript Language Description","title":"References"},{"location":"dev/stack/front-end/","text":"Front-end Ergo JS Template The Ergo JS Template aims to serve as an entry point to Ergo dApp Development Bootstrapped with Create React App. It contains ergo-ts and ergo-lib libraries as dependencies and some examples to present how to use these libraries. Explanations The following examples can be seen on the Ergo JS Template repository Interacting with the explorer Encoding different data types Decoding fields (registers) of tokens References ergo-ts with support of tokens and complex transactions ergo-js with basic transaction operations Other Examples The Ergo Raffle documentation provides a detailed description of their implmenetion. hypo10use/quid-games (Angular)","title":"Frontend"},{"location":"dev/stack/front-end/#front-end","text":"","title":"Front-end"},{"location":"dev/stack/front-end/#ergo-js-template","text":"The Ergo JS Template aims to serve as an entry point to Ergo dApp Development Bootstrapped with Create React App. It contains ergo-ts and ergo-lib libraries as dependencies and some examples to present how to use these libraries.","title":"Ergo JS Template"},{"location":"dev/stack/front-end/#explanations","text":"The following examples can be seen on the Ergo JS Template repository Interacting with the explorer Encoding different data types Decoding fields (registers) of tokens","title":"Explanations"},{"location":"dev/stack/front-end/#references","text":"ergo-ts with support of tokens and complex transactions ergo-js with basic transaction operations","title":"References"},{"location":"dev/stack/front-end/#other-examples","text":"The Ergo Raffle documentation provides a detailed description of their implmenetion. hypo10use/quid-games (Angular)","title":"Other Examples"},{"location":"dev/start/api/","text":"An Ergo node provides a REST API accessible via HTTP. The full API specification (in OpenAPI format) is available here . Accessing the API Once the node is running, the API can be accessed at 127.0.0.1:9052 . You can also use Swagger to make API requests by going to 127.0.0.1:9052/swagger . To access protected API routes (such as for wallet), you must provide your secret phrase in the request headers [api_key, Content-Type] , or click the Authorize button in swagger and enter your secret phrase there. Setting an API key For accessing any protected methods you must configure apiKeyHash parameter in the node configuration file: scorex.restApi.apiKeyHash = \"replace_this_with_your_unique_api_key_hash\" The parameter is the hex-encoded Blake2b256 hash of your secret phrase that will be used to authenticate your API requests. You can use this Python script or any other script to securely generate the secret and the blake2b256 hash of it. The secret phrase acts as an API key and can be any string but please ensure that it remains secret and is not sent to any untrusted services. The following REST API endpoint also provides a (non-protected) method to compute the hash: /utils/hashBlake2b","title":"Api"},{"location":"dev/start/api/#accessing-the-api","text":"Once the node is running, the API can be accessed at 127.0.0.1:9052 . You can also use Swagger to make API requests by going to 127.0.0.1:9052/swagger . To access protected API routes (such as for wallet), you must provide your secret phrase in the request headers [api_key, Content-Type] , or click the Authorize button in swagger and enter your secret phrase there.","title":"Accessing the API"},{"location":"dev/start/api/#setting-an-api-key","text":"For accessing any protected methods you must configure apiKeyHash parameter in the node configuration file: scorex.restApi.apiKeyHash = \"replace_this_with_your_unique_api_key_hash\" The parameter is the hex-encoded Blake2b256 hash of your secret phrase that will be used to authenticate your API requests. You can use this Python script or any other script to securely generate the secret and the blake2b256 hash of it. The secret phrase acts as an API key and can be any string but please ensure that it remains secret and is not sent to any untrusted services. The following REST API endpoint also provides a (non-protected) method to compute the hash: /utils/hashBlake2b","title":"Setting an API key"},{"location":"dev/start/dApp-dev/","text":"","title":"dApp dev"},{"location":"dev/start/resources/","text":"Resources Explorer Explorer Mainnet explorer Testnet Testnet explorer Using Ergo-Testnet Testnet Faucet API API Docs Node API Explorer API Misc. Resources Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo. Basic Tutorials ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Resources"},{"location":"dev/start/resources/#resources","text":"","title":"Resources"},{"location":"dev/start/resources/#explorer","text":"Explorer Mainnet explorer","title":"Explorer"},{"location":"dev/start/resources/#testnet","text":"Testnet explorer Using Ergo-Testnet Testnet Faucet","title":"Testnet"},{"location":"dev/start/resources/#api","text":"API Docs Node API Explorer API","title":"API"},{"location":"dev/start/resources/#misc-resources","text":"Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo.","title":"Misc. Resources"},{"location":"dev/start/resources/#basic-tutorials","text":"ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Basic Tutorials"},{"location":"dev/start/start/","text":"Where to start? The dApp Development page provides a broad overview on creating your first decentralised app. See the Backend page for an overview of the tools available to interact with the blockchain. This is also broken down on a per-language basis. dApp Development For most developers, Appkit is the best entry point unless you're wanting to dive straight into ErgoScript smart-contract development. System Architecture Below is a example system architecture diagram highlighting the main components of a decentralised application (dApp) Front-end | The user-interface built in your framework of choice. For payments, we have the Yoroi dApp connector, proxy contracts, or Ergo-Pay. REST | A REST ful API to interact with the backend Backend | Perform the off-chain logic Database (Optional) Contract | Where the magic happens, the on-chain validation of the off-chain logic. Resources Explorer Explorer Mainnet explorer Testnet Testnet explorer Using Ergo-Testnet Testnet Faucet API API Docs Node API Explorer API Misc. Resources Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo. Basic Tutorials ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Where to start?"},{"location":"dev/start/start/#where-to-start","text":"The dApp Development page provides a broad overview on creating your first decentralised app. See the Backend page for an overview of the tools available to interact with the blockchain. This is also broken down on a per-language basis.","title":"Where to start?"},{"location":"dev/start/start/#dapp-development","text":"For most developers, Appkit is the best entry point unless you're wanting to dive straight into ErgoScript smart-contract development. System Architecture Below is a example system architecture diagram highlighting the main components of a decentralised application (dApp) Front-end | The user-interface built in your framework of choice. For payments, we have the Yoroi dApp connector, proxy contracts, or Ergo-Pay. REST | A REST ful API to interact with the backend Backend | Perform the off-chain logic Database (Optional) Contract | Where the magic happens, the on-chain validation of the off-chain logic.","title":"dApp Development"},{"location":"dev/start/start/#resources","text":"","title":"Resources"},{"location":"dev/start/start/#explorer","text":"Explorer Mainnet explorer","title":"Explorer"},{"location":"dev/start/start/#testnet","text":"Testnet explorer Using Ergo-Testnet Testnet Faucet","title":"Testnet"},{"location":"dev/start/start/#api","text":"API Docs Node API Explorer API","title":"API"},{"location":"dev/start/start/#misc-resources","text":"Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo.","title":"Misc. Resources"},{"location":"dev/start/start/#basic-tutorials","text":"ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Basic Tutorials"},{"location":"miners/mining/","text":"","title":"Mining"}]}