{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Ergo Platform Documentation! Ergo uses continous integration, meaning best practices dictate that the majority of the documentation should be kept on the assosciated repositories themselves. this site aims to serve as a directory that guides the user on their development journey. Documentation within the naviation tabs above is split into four distinct categories. Tutorials How-To Guides Explanations References Read more about the format used on this website. Other resources awesome-ergo ergonaut.space ergosites.github","title":"Welcome"},{"location":"#welcome-to-the-ergo-platform-documentation","text":"Ergo uses continous integration, meaning best practices dictate that the majority of the documentation should be kept on the assosciated repositories themselves. this site aims to serve as a directory that guides the user on their development journey. Documentation within the naviation tabs above is split into four distinct categories. Tutorials How-To Guides Explanations References Read more about the format used on this website.","title":"Welcome to the Ergo Platform Documentation!"},{"location":"#other-resources","text":"awesome-ergo ergonaut.space ergosites.github","title":"Other resources"},{"location":"About/events/","text":"ERGOHACK ERGOHACK I Hackerthon Jun 12th! ERGOHACK II ERGOHACK III ErgoSummit ErgoSummit I ErgoSummit Timestamps 00:00:00 - The Summit 00:01:00 - Ergo 101: The Basics 00:40:00 - Cardano & Ergo\u2019s UTXO Model 01:11:30 - DeFi Services: How Yoroi Wallet will be the gateway to Ergo dApps and what\u2019s to come 01:32:30 - Auction House 01:49:30 - Announcing The Release Of The AgeUSD Stablecoin Protocol 02:18:00 - An IOHK Perspective: Designing The AgeUSD Stablecoin Protocol - An Economic Analysis (with Special Guest IOHK\u2019s Bruno) 03:02:00 - AgeUSD Smart Contracts: A Technical Perspective 03:41:00 - Enter Into The Sigmaverse - Uncovering What Lays Within Ergo\u2019s dApp Ecosystem 03:47:30 - Ergo-Bootstrap - Streamlining Ergo dApp Infrastructure With One Simple Tool 03:59:30 - Headless dApps: A Novel Technical & Business Model for the dApp Industry 04:28:00 - Ergo - Cardano Collaboration 04:38:00 - Understanding dApp Developer Tooling: An Introduction To Kiosk [05:13:00] (https://www.youtube.com/watch?v=zG-rxMCDIa0&t=18780s) - The Upcoming Ergo Hardening Upgrade - How It Will Change The Ecosystem From Top To Bottom 05:26:30 - Oracle Pools Update - How Deviation Checking Consensus Improves Assurance 05:57:00 - Updatable dApps In The EUTXO Model 06:10:00 - Blockchain 2020: A DeFi Odyssey 06:51:00 - The Ergo Vision 07:03:00 - ZK Treasury 07:07:00 - Understanding dApp Developer Tooling: An Introduction To Json dApp Environment 07:45:30 - The Ergo Foundation\u2019s Grant-Based Approach To Developing The UTXO-Based dApp Ecosystem 08:05:30 - 2021 Ergo Roadmap reveal ErgoSummit II Q4 2021","title":"Events"},{"location":"About/events/#ergohack","text":"","title":"ERGOHACK"},{"location":"About/events/#ergohack-i","text":"Hackerthon Jun 12th!","title":"ERGOHACK I"},{"location":"About/events/#ergohack-ii","text":"","title":"ERGOHACK II"},{"location":"About/events/#ergohack-iii","text":"","title":"ERGOHACK III"},{"location":"About/events/#ergosummit","text":"","title":"ErgoSummit"},{"location":"About/events/#ergosummit-i","text":"","title":"ErgoSummit I"},{"location":"About/events/#ergosummit-timestamps","text":"00:00:00 - The Summit 00:01:00 - Ergo 101: The Basics 00:40:00 - Cardano & Ergo\u2019s UTXO Model 01:11:30 - DeFi Services: How Yoroi Wallet will be the gateway to Ergo dApps and what\u2019s to come 01:32:30 - Auction House 01:49:30 - Announcing The Release Of The AgeUSD Stablecoin Protocol 02:18:00 - An IOHK Perspective: Designing The AgeUSD Stablecoin Protocol - An Economic Analysis (with Special Guest IOHK\u2019s Bruno) 03:02:00 - AgeUSD Smart Contracts: A Technical Perspective 03:41:00 - Enter Into The Sigmaverse - Uncovering What Lays Within Ergo\u2019s dApp Ecosystem 03:47:30 - Ergo-Bootstrap - Streamlining Ergo dApp Infrastructure With One Simple Tool 03:59:30 - Headless dApps: A Novel Technical & Business Model for the dApp Industry 04:28:00 - Ergo - Cardano Collaboration 04:38:00 - Understanding dApp Developer Tooling: An Introduction To Kiosk [05:13:00] (https://www.youtube.com/watch?v=zG-rxMCDIa0&t=18780s) - The Upcoming Ergo Hardening Upgrade - How It Will Change The Ecosystem From Top To Bottom 05:26:30 - Oracle Pools Update - How Deviation Checking Consensus Improves Assurance 05:57:00 - Updatable dApps In The EUTXO Model 06:10:00 - Blockchain 2020: A DeFi Odyssey 06:51:00 - The Ergo Vision 07:03:00 - ZK Treasury 07:07:00 - Understanding dApp Developer Tooling: An Introduction To Json dApp Environment 07:45:30 - The Ergo Foundation\u2019s Grant-Based Approach To Developing The UTXO-Based dApp Ecosystem 08:05:30 - 2021 Ergo Roadmap reveal","title":"ErgoSummit Timestamps"},{"location":"About/events/#ergosummit-ii","text":"Q4 2021","title":"ErgoSummit II"},{"location":"About/faq/","text":"Basics What is the teams background? | Ergo is designed and implemented by a team of experienced developers and researchers, who hold publications and PhDs in cryptography, compiler theory, blockchain technology, and cryptographic e-cash. The team also has a solid background in core development with such cryptocurrencies and blockchain frameworks as Nxt, Scorex and Waves. Alexander 'kushti' Chepurnoy, was a co-founder of smartcontract.com (now Chainlink), a core developer at NXT (first PoS), and one of the first employees at IOHK, where he was a Research Fellow and Team Scorex Manager. The full team can be seen on Ergo's Hall of Fame . Why 'Ergo'? | \u201cErgo means \u201ctherefore\u201d in Latin, but \u201cwork\u201d in Greek. Initially, the name was chosen to point to the fact that the design of the cryptocurrency is ERGOnomical. What is the emission schedule? | Emission Schedule with a maximum supply of 97,739,925 Ergs, to be completed in 8 years after launch. When was Ergo launched? | July, 2019. The previous price spike was a different token (Ergo-First-Year-Token), if you view the chart by market-cap it is accurate. Where can I buy Erg? | KuCoin, CoinEx, TradeOgre, gate.io. Where can I store Erg? | Yoroi or the Android Wallet. Is there mobile support? | Android only currently, iOS in development Can we use a hardware wallet? | Ledger support underway. Workaround: You can move your Erg to waves.exchange and stake your erg through that. Can I stake ERG? | No, Ergo is a Proof of Work coin - you can however provide liquidity on either the CoinEx AMM pool (watch out for impermanent loss!), or SigmaUSD. However, dApp tokenisation is coming - A Solution for staking Ergo Foundation What is the Ergo Foundation? | The Ergo Foundation is a community-driven entity focused on: Promoting non-breaking development of Ergo Platform protocol; Promoting the widespread adoption and use of Ergo Platform and its native token (ERG); Developing the ecosystem around the Ergo Platform; Promoting the use of Ergo Platform and blockchain technology for social good; Supporting truly decentralized infrastructure, and; Supporting privacy as a basic human right. Deep Dives Ergo: Road to Top 10 ergonaut.space Infographics \u201cIt's one of the most revolutionary cryptocurrencies ever built. Got so many crazy ideas like sigma protocols and pruning the blockchain and roller chains. All this crazy stuff. Even has a proof of no premine. So really a technological marvel in many respects, and it reflects about 8 years of knowledge that Alex has amassed as both a researcher and a developer. Super concise code and it blows my mind that the market cap is where it's at. It should be a top 10 coin or top 15 coin\" \u2014 Charles Hoskinson Get some perspective Proof of Work Ergo was created for regular people, PoW allows for a fair start and true decentralistion. It's also widely studied, and has very high-security guarantees - which are essential for having useful contractual, programmable money that's ready today. Here's CH talking a bit about consensus Why Proof-of-Work? | It's tried and tested (the Lindy effect), and has some advantages over PoS. What about 51% attacks? | Not a significant problem, more pools are being added. Ergo's Efficiency and interplay with PoS - Discussion Can I mine ERG? | To mine, you will need a dedicated GPU (AMD/Intel), see this page on mining What will Erg bring to ADA? Features Storage Rent | After four years, miners can charge fees for unmoved erg. Stabilising miner income and preventing lost coins as we see in BTC. Sigma Protocols | Ergo\u2019s smart contracts and DeFi functionality are built on Sigma protocols \u2013 a powerful, flexible class of zero-knowledge proofs. Find out more about why they\u2019re so important, and how they put Ergo head and shoulders above the competition. eUTxO | Based on the UTXO model of Bitcoin, similar extended-UTXO model as Cardano, allowing interoperability. NiPoPoWs | Verify proof of work without downloading the headers. Enables light-clients during in places with poor internet - and light mining (not having to download the entire chain) dApps Ergo already has several functional decentralised applications | sigmaverse.io ErgoMixer | the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space . SigmaUSD | DAI-like Stablecoin - without liquidations. AuctionHouse | Working NFT marketplace. Oracle-Pools | More efficient and programmable than using multiple single oracle data points such as in Chainlink\u2019s oracle design. We build hierarchies of confidence using oracle pools and pools of oracle pools in Ergo. It\u2019s faster, cheaper, and more beneficial to the end-user. In-Development ErgoDex | Decentralised exchange that runs ontop ADA & ERG. ErgoFund | Crowdfunding on Ergo Use cases Ergo is one of the most sophisticated protocols in the space with stateless clients, NiPoPoWS for light clients, and easy miner-voting on parameter changes (e.g, block size) Ergo aims to provide an efficient, secure, and easy way to implement financial contracts that will be useful and survivable in the long term. There is plenty of uniqueness in Ergo but the most significant is probably Sigma protocols. These allow a true P2P system with privacy in mind. No one at the moment is able to build a trustless LETS system, multisig with no signers disclosure, trustless payment networks or has real ring signatures that preserve zero knowledge. Local Exchange Trading System - a local mutual credit association which members are allowed to create common credit money individually, with all the deals in the system written into a common ledger. To the best of our knowledge, this is the first implementation of such kind of community currency on top of a blockchain. LETS can be thought of as a mechanism to facilitate the velocity of trade, goods, and services out-with the existing monetary system, allowing us to create sustainable local economies. Smart contracts without gas fees. Ergo\u2019s native programming language \u2014 aka ErgoScript \u2014 enables the development of Turing complete contracts that completely bypass the need for any gas fee while providing other peripheral benefits such as estimation of script complexity before execution, a facet that helps in the active prevention of DoS attacks. Ergo.Meta - a unified set of design patterns for off-chain and sidechain solutions ErgoScript : a new advanced transactional language built from scratch by the team. Tutorials are available on the website /docs/AdvancedErgoScriptTutorial.pdf. It is a more advanced scripting language than Bitcoin while maintaining security and not introducing blockchain bloat problems. Scripting language in itself is non-Turing complete but applications ran on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper https://arxiv.org/pdf/1806.10116v1.pdf. Rigorous research and scientific approach : Ergo is based on original research, published at known peer-reviewed conferences. A list of scientific papers is available at here , but Ergo is not limited by research and it also implements other novel scientific ideas. Trustless Light Clients with Minimal Resource Requirements: Ergo block header supports NiPoPoWs that enable synchronizing network by downloading < 1Mb of data. This is further made possible by the fact Ergo state is authenticated as detailed in this paper from 2017 New Economic Model : Key feature of the new model is miners charge users a fee for any UTXO that remains unmoved for 4 years (\u201cstorage rent fee\u201d). This accomplishes stable mining revenue to secure the network, prevents \u201cstate bloat\u201d and enables a short release schedule \u2013 Ergo emission fully completes in just 8 years. Details in this paper Mined from Zero via PoW with no ICO or Pre-mine . It is about a hope to achieve a fair distribution of Ergs as possible to enhance decentralization. Decentralization First : Core commitment of Development team and community. Top item in \u201cErgo Vision\u201d section of white paper. Many of the above features\u2019 main purpose is to achieve this goal. Resiliency and Survivability : Decentralization First is to accomplish this goal. Ergo should be alive and operational for an indefinite amount of time and Contractual Money contracts on Ergo should be able to survive for at least the length of a person\u2019s lifetime despite a changing external environment. Privacy : Privacy is optional in Ergo, but it still beats a lot of privacy coins by default. You can actually put XMR on top, but Ergo itself can achieve privacy of early Monero if there are enough users of the mixers. Actually, it can be far better, as no inference scenarios are possible as described in this paper . Related: ErgoMixer Other : Ergo offers anyone the ability to issue their own tokens (non-native tokens) on the platform and leverage off its security and decentralization. Advanced on-chain governance is built with miners being able to vote on a number of parameters including simple items like block size \u2013 gradual changes only to ensure stability. Ergo follows a soft-forkability approach --- if an overwhelming majority of the network accepts a new feature, it is activated, however, old nodes which do not upgrade continue to operate normally and just skip over this feature validation. Thus disruptive hard forks should not be required in Ergo. Ergo mining will always be stable, unlike Bitcoin and other PoW currencies, in which mining may become unstable after the emission period. To achieve survivability, Ergo provides economic improvements in addition to the technical ones, most central of which is a storage fee component which plays an important role for Ergo\u2018s stability. Scalability The blocks in the Ergo Network are aimed to be produced at an interval of approx. 2 minutes. TPS itself doesn't matter much for Ergo in the long run since it has smart contracts in which you can chain hundreds of transactions within one. Ergo\u2019s solutions to transaction congestion are as follows: L0: A lot of efficiency improvements in the node have been completed starting from v4.0.8, 20-50x gains are still possible here. Quick bootstrapping using NiPoPoWs proofs and UTXO set snapshots are also planned L1: Ergo has an extension section in its code that allows the implementation of a wide variety of scaling solutions such as Sharding, Hydra, or BitcoinNG-style macroblocks. This even lets us do generic sidechains with velvet or soft forks. L2 (off-chain) - Ergo should be compatible with the Lightning Network, Rainbow Network, and many more. The implementation here will depend on the needs of the applications being built on Ergo. Ergo has stateless clients, NiPoPoWs - can put full nodes on Raspberry Pi's, make ultra-efficient SPV clients and other means to survive in the long-term even under the load. Storage rent helps to prevent spam & dust and stabilize mining income. Other benefits from having the storage rent fee include prevention of \"state bloat\", the building of an economy around the state (users must pay to keep unspent boxes in miners' memory for the long\u2010term) and a gradual return of any lost coins back into circulation. Partnerships / Business Development Yoroi dApp Connector | In Testing! Waves Partners with Ergo to foster Interoperability solutions | In Testing! Cryptocurrencycheckout: Supports both SigUSD and Ergo. Roadmap","title":"FAQ"},{"location":"About/faq/#basics","text":"What is the teams background? | Ergo is designed and implemented by a team of experienced developers and researchers, who hold publications and PhDs in cryptography, compiler theory, blockchain technology, and cryptographic e-cash. The team also has a solid background in core development with such cryptocurrencies and blockchain frameworks as Nxt, Scorex and Waves. Alexander 'kushti' Chepurnoy, was a co-founder of smartcontract.com (now Chainlink), a core developer at NXT (first PoS), and one of the first employees at IOHK, where he was a Research Fellow and Team Scorex Manager. The full team can be seen on Ergo's Hall of Fame . Why 'Ergo'? | \u201cErgo means \u201ctherefore\u201d in Latin, but \u201cwork\u201d in Greek. Initially, the name was chosen to point to the fact that the design of the cryptocurrency is ERGOnomical. What is the emission schedule? | Emission Schedule with a maximum supply of 97,739,925 Ergs, to be completed in 8 years after launch. When was Ergo launched? | July, 2019. The previous price spike was a different token (Ergo-First-Year-Token), if you view the chart by market-cap it is accurate. Where can I buy Erg? | KuCoin, CoinEx, TradeOgre, gate.io. Where can I store Erg? | Yoroi or the Android Wallet. Is there mobile support? | Android only currently, iOS in development Can we use a hardware wallet? | Ledger support underway. Workaround: You can move your Erg to waves.exchange and stake your erg through that. Can I stake ERG? | No, Ergo is a Proof of Work coin - you can however provide liquidity on either the CoinEx AMM pool (watch out for impermanent loss!), or SigmaUSD. However, dApp tokenisation is coming - A Solution for staking","title":"Basics"},{"location":"About/faq/#ergo-foundation","text":"What is the Ergo Foundation? | The Ergo Foundation is a community-driven entity focused on: Promoting non-breaking development of Ergo Platform protocol; Promoting the widespread adoption and use of Ergo Platform and its native token (ERG); Developing the ecosystem around the Ergo Platform; Promoting the use of Ergo Platform and blockchain technology for social good; Supporting truly decentralized infrastructure, and; Supporting privacy as a basic human right.","title":"Ergo Foundation"},{"location":"About/faq/#deep-dives","text":"Ergo: Road to Top 10 ergonaut.space Infographics \u201cIt's one of the most revolutionary cryptocurrencies ever built. Got so many crazy ideas like sigma protocols and pruning the blockchain and roller chains. All this crazy stuff. Even has a proof of no premine. So really a technological marvel in many respects, and it reflects about 8 years of knowledge that Alex has amassed as both a researcher and a developer. Super concise code and it blows my mind that the market cap is where it's at. It should be a top 10 coin or top 15 coin\" \u2014 Charles Hoskinson Get some perspective","title":"Deep Dives"},{"location":"About/faq/#proof-of-work","text":"Ergo was created for regular people, PoW allows for a fair start and true decentralistion. It's also widely studied, and has very high-security guarantees - which are essential for having useful contractual, programmable money that's ready today. Here's CH talking a bit about consensus Why Proof-of-Work? | It's tried and tested (the Lindy effect), and has some advantages over PoS. What about 51% attacks? | Not a significant problem, more pools are being added. Ergo's Efficiency and interplay with PoS - Discussion Can I mine ERG? | To mine, you will need a dedicated GPU (AMD/Intel), see this page on mining What will Erg bring to ADA?","title":"Proof of Work"},{"location":"About/faq/#features","text":"Storage Rent | After four years, miners can charge fees for unmoved erg. Stabilising miner income and preventing lost coins as we see in BTC. Sigma Protocols | Ergo\u2019s smart contracts and DeFi functionality are built on Sigma protocols \u2013 a powerful, flexible class of zero-knowledge proofs. Find out more about why they\u2019re so important, and how they put Ergo head and shoulders above the competition. eUTxO | Based on the UTXO model of Bitcoin, similar extended-UTXO model as Cardano, allowing interoperability. NiPoPoWs | Verify proof of work without downloading the headers. Enables light-clients during in places with poor internet - and light mining (not having to download the entire chain)","title":"Features"},{"location":"About/faq/#dapps","text":"Ergo already has several functional decentralised applications | sigmaverse.io ErgoMixer | the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space . SigmaUSD | DAI-like Stablecoin - without liquidations. AuctionHouse | Working NFT marketplace. Oracle-Pools | More efficient and programmable than using multiple single oracle data points such as in Chainlink\u2019s oracle design. We build hierarchies of confidence using oracle pools and pools of oracle pools in Ergo. It\u2019s faster, cheaper, and more beneficial to the end-user.","title":"dApps"},{"location":"About/faq/#in-development","text":"ErgoDex | Decentralised exchange that runs ontop ADA & ERG. ErgoFund | Crowdfunding on Ergo","title":"In-Development"},{"location":"About/faq/#use-cases","text":"Ergo is one of the most sophisticated protocols in the space with stateless clients, NiPoPoWS for light clients, and easy miner-voting on parameter changes (e.g, block size) Ergo aims to provide an efficient, secure, and easy way to implement financial contracts that will be useful and survivable in the long term. There is plenty of uniqueness in Ergo but the most significant is probably Sigma protocols. These allow a true P2P system with privacy in mind. No one at the moment is able to build a trustless LETS system, multisig with no signers disclosure, trustless payment networks or has real ring signatures that preserve zero knowledge. Local Exchange Trading System - a local mutual credit association which members are allowed to create common credit money individually, with all the deals in the system written into a common ledger. To the best of our knowledge, this is the first implementation of such kind of community currency on top of a blockchain. LETS can be thought of as a mechanism to facilitate the velocity of trade, goods, and services out-with the existing monetary system, allowing us to create sustainable local economies. Smart contracts without gas fees. Ergo\u2019s native programming language \u2014 aka ErgoScript \u2014 enables the development of Turing complete contracts that completely bypass the need for any gas fee while providing other peripheral benefits such as estimation of script complexity before execution, a facet that helps in the active prevention of DoS attacks. Ergo.Meta - a unified set of design patterns for off-chain and sidechain solutions ErgoScript : a new advanced transactional language built from scratch by the team. Tutorials are available on the website /docs/AdvancedErgoScriptTutorial.pdf. It is a more advanced scripting language than Bitcoin while maintaining security and not introducing blockchain bloat problems. Scripting language in itself is non-Turing complete but applications ran on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper https://arxiv.org/pdf/1806.10116v1.pdf. Rigorous research and scientific approach : Ergo is based on original research, published at known peer-reviewed conferences. A list of scientific papers is available at here , but Ergo is not limited by research and it also implements other novel scientific ideas. Trustless Light Clients with Minimal Resource Requirements: Ergo block header supports NiPoPoWs that enable synchronizing network by downloading < 1Mb of data. This is further made possible by the fact Ergo state is authenticated as detailed in this paper from 2017 New Economic Model : Key feature of the new model is miners charge users a fee for any UTXO that remains unmoved for 4 years (\u201cstorage rent fee\u201d). This accomplishes stable mining revenue to secure the network, prevents \u201cstate bloat\u201d and enables a short release schedule \u2013 Ergo emission fully completes in just 8 years. Details in this paper Mined from Zero via PoW with no ICO or Pre-mine . It is about a hope to achieve a fair distribution of Ergs as possible to enhance decentralization. Decentralization First : Core commitment of Development team and community. Top item in \u201cErgo Vision\u201d section of white paper. Many of the above features\u2019 main purpose is to achieve this goal. Resiliency and Survivability : Decentralization First is to accomplish this goal. Ergo should be alive and operational for an indefinite amount of time and Contractual Money contracts on Ergo should be able to survive for at least the length of a person\u2019s lifetime despite a changing external environment. Privacy : Privacy is optional in Ergo, but it still beats a lot of privacy coins by default. You can actually put XMR on top, but Ergo itself can achieve privacy of early Monero if there are enough users of the mixers. Actually, it can be far better, as no inference scenarios are possible as described in this paper . Related: ErgoMixer Other : Ergo offers anyone the ability to issue their own tokens (non-native tokens) on the platform and leverage off its security and decentralization. Advanced on-chain governance is built with miners being able to vote on a number of parameters including simple items like block size \u2013 gradual changes only to ensure stability. Ergo follows a soft-forkability approach --- if an overwhelming majority of the network accepts a new feature, it is activated, however, old nodes which do not upgrade continue to operate normally and just skip over this feature validation. Thus disruptive hard forks should not be required in Ergo. Ergo mining will always be stable, unlike Bitcoin and other PoW currencies, in which mining may become unstable after the emission period. To achieve survivability, Ergo provides economic improvements in addition to the technical ones, most central of which is a storage fee component which plays an important role for Ergo\u2018s stability.","title":"Use cases"},{"location":"About/faq/#scalability","text":"The blocks in the Ergo Network are aimed to be produced at an interval of approx. 2 minutes. TPS itself doesn't matter much for Ergo in the long run since it has smart contracts in which you can chain hundreds of transactions within one. Ergo\u2019s solutions to transaction congestion are as follows: L0: A lot of efficiency improvements in the node have been completed starting from v4.0.8, 20-50x gains are still possible here. Quick bootstrapping using NiPoPoWs proofs and UTXO set snapshots are also planned L1: Ergo has an extension section in its code that allows the implementation of a wide variety of scaling solutions such as Sharding, Hydra, or BitcoinNG-style macroblocks. This even lets us do generic sidechains with velvet or soft forks. L2 (off-chain) - Ergo should be compatible with the Lightning Network, Rainbow Network, and many more. The implementation here will depend on the needs of the applications being built on Ergo. Ergo has stateless clients, NiPoPoWs - can put full nodes on Raspberry Pi's, make ultra-efficient SPV clients and other means to survive in the long-term even under the load. Storage rent helps to prevent spam & dust and stabilize mining income. Other benefits from having the storage rent fee include prevention of \"state bloat\", the building of an economy around the state (users must pay to keep unspent boxes in miners' memory for the long\u2010term) and a gradual return of any lost coins back into circulation.","title":"Scalability"},{"location":"About/faq/#partnerships-business-development","text":"Yoroi dApp Connector | In Testing! Waves Partners with Ergo to foster Interoperability solutions | In Testing! Cryptocurrencycheckout: Supports both SigUSD and Ergo. Roadmap","title":"Partnerships / Business Development"},{"location":"About/format/","text":"Format Tutorials learning-oriented. Tutorial are lessons that take the reader by the hand through a series of steps to complete a project. Most important part of documentation, rarely done well. What matters? Learn by doing. Getting Started Inspiring Confidence Repeatability Immediate sense of achievement Concreteness, not abstraction Minimum necessary explanation No distractions How To Guides problem-oriented. Guides that take the user through a series of steps to achieve a common problem. What matters? A series of steps A focus on the goal Addressing a specific question A little flexibility Practical usability Good naming Explanations Understanding-orientated Explanations that clarify and illuminate a particular topic What Matters? Giving context Explaning why Multiple examples, alternative approaches Making Connections No instruction or technical description References Technical descriptions and how to operate it. What Matters? Structure Consistency Description Accuracy","title":"About ErgoDocs"},{"location":"About/format/#format","text":"","title":"Format"},{"location":"About/format/#tutorials","text":"learning-oriented. Tutorial are lessons that take the reader by the hand through a series of steps to complete a project. Most important part of documentation, rarely done well.","title":"Tutorials"},{"location":"About/format/#what-matters","text":"Learn by doing. Getting Started Inspiring Confidence Repeatability Immediate sense of achievement Concreteness, not abstraction Minimum necessary explanation No distractions","title":"What matters?"},{"location":"About/format/#how-to-guides","text":"problem-oriented. Guides that take the user through a series of steps to achieve a common problem.","title":"How To Guides"},{"location":"About/format/#what-matters_1","text":"A series of steps A focus on the goal Addressing a specific question A little flexibility Practical usability Good naming","title":"What matters?"},{"location":"About/format/#explanations","text":"Understanding-orientated Explanations that clarify and illuminate a particular topic","title":"Explanations"},{"location":"About/format/#what-matters_2","text":"Giving context Explaning why Multiple examples, alternative approaches Making Connections No instruction or technical description","title":"What Matters?"},{"location":"About/format/#references","text":"Technical descriptions and how to operate it.","title":"References"},{"location":"About/format/#what-matters_3","text":"Structure Consistency Description Accuracy","title":"What Matters?"},{"location":"dev/Integration/guide/","text":"This guide is for helping developers integrating Ergo into exchanges, wallets, pools wallets etc. Introduction Some quick facts useful for an integration: like Bitcoin, a transaction in Ergo has multiple inputs and outputs. Unspent outputs are single-use entities. However, Ergo is built from scratch thus scripts and transaction format are different. like in Bitcoin, there are some standard scripts in Ergo associated with addresses, e.g. P2PK addresses. There's an article on address scheme available: https://ergoplatform.org/en/blog/2019_07_24_ergo_address/ Ergo has inbuilt wallet API which is enough for most use-cases. API has Swagger interface (on 127.0.0.1:9053 by default in the mainnet, 127.0.0.1:9052 in the testnet) with descriptions and examples for API methods. How to set up a node: https://ergoplatform.org/en/blog/2019_12_02_how_to_setup/, https://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node Please run the node with -Xmx3G flag, e.g. java -jar -Xmx3G ergo-4.0.4.jar --mainnet -c mainnet.conf Node Wallet Node wallet has UI available @ 127.0.0.1:9053/panel by default on the mainnet (127.0.0.1:9052/panel on the testnet). Main methods: /wallet/init and /wallet/restore to create a wallet (and a secret mnemonic) and restore wallet from mnemonic /wallet/unlock to unlock the wallet (it is unlocked after init but locked after restart) /wallet/lock to lock the wallet /wallet/payment/send to send a simple payment /wallet/status to get wallet status /wallet/deriveNextKey to derive a new key according to EIP-3 (BIP 44 implementation for Ergo) /wallet/balances to get wallet balance (for all the addresses) /wallet/transactions to get wallet transactions (for all the addresses) Doing an external wallet If you are going to do wallet logic externally, you can do it with a library and also the block explorer. Please note, you need to consider mempool transactions to avoid double-spending generation . Available libraries are: ergo-wallet made in Java (sources are in Ergo node repository ) sigma-rust in Rust with WASM bindings for JavaScript/TypeScript ergo-ts in TypeScript ergo-golang in Go (still raw) Offline Signing Transaction assembly and offline signing demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/c040f244865a451b94df01032c7a3456 Transaction assembly and signing in Rust https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/tx_builder.rs#L552-L592 https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/signing.rs#L133-L161 Transaction assembly and signing in JavaScript https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/bindings/ergo-lib-wasm/tests/test_transaction.js#L9-L69 Composing transaction outside the node To get unspent UTXOs for some address, please use transactions/boxes/byAddress/unspent Explorer API method: https://api.ergoplatform.com/transactions/boxes/byAddress/unspent/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M . You need to exclude UTXOs spent in the mempool! Use /transactions/unconfirmed/byAddress Explorer API method for that: https://api.ergoplatform.com/transactions/unconfirmed/byAddress/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M Broadcasting transaction To broadcast a transaction made outside the node, the easiest way is to serialize it into JSON, in Java it could be like: Json json = JsonCodecsWrapper.ergoLikeTransactionEncoder().apply(tx); System.out.println(json.toString()); and then send this json via POST request to the public explorer https://api.ergoplatform.com/api/v0/transactions/send , your private explorer or a node with open API (POST to http://{node_ip}:9053/transactions ) Address generation Secret seed and derived addresses generation demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/70dcfa841dfb504721f09c911b0fc53d Own Testnet and Explorer Infrastructure You can use ergo-bootstrap to install Explorer backend easily (and so not rely on public ones). To start your own testnet, use the following node: ergo { networkType = \"testnet\" node { mining = true offlineGeneration = true useExternalMiner = false } } scorex { network { bindAddress = \"0.0.0.0:9020\" nodeName = \"ergo-testnet-4.0.4\" knownPeers = [] } restApi { # Hex-encoded Blake2b256 hash of an API key. Should be 64-chars long Base16 string. # Below is hash corresponding to API_KEY = \"hello\" (with no quotes) apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } } and then the node will CPU-mine its own chain. Any suggestions for improvements are welcomed! Please send them to team@ergoplatform.org or #development channel in Discord https://discord.gg/kj7s7nb","title":"Integration"},{"location":"dev/Integration/guide/#introduction","text":"Some quick facts useful for an integration: like Bitcoin, a transaction in Ergo has multiple inputs and outputs. Unspent outputs are single-use entities. However, Ergo is built from scratch thus scripts and transaction format are different. like in Bitcoin, there are some standard scripts in Ergo associated with addresses, e.g. P2PK addresses. There's an article on address scheme available: https://ergoplatform.org/en/blog/2019_07_24_ergo_address/ Ergo has inbuilt wallet API which is enough for most use-cases. API has Swagger interface (on 127.0.0.1:9053 by default in the mainnet, 127.0.0.1:9052 in the testnet) with descriptions and examples for API methods. How to set up a node: https://ergoplatform.org/en/blog/2019_12_02_how_to_setup/, https://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node Please run the node with -Xmx3G flag, e.g. java -jar -Xmx3G ergo-4.0.4.jar --mainnet -c mainnet.conf","title":"Introduction"},{"location":"dev/Integration/guide/#node-wallet","text":"Node wallet has UI available @ 127.0.0.1:9053/panel by default on the mainnet (127.0.0.1:9052/panel on the testnet). Main methods: /wallet/init and /wallet/restore to create a wallet (and a secret mnemonic) and restore wallet from mnemonic /wallet/unlock to unlock the wallet (it is unlocked after init but locked after restart) /wallet/lock to lock the wallet /wallet/payment/send to send a simple payment /wallet/status to get wallet status /wallet/deriveNextKey to derive a new key according to EIP-3 (BIP 44 implementation for Ergo) /wallet/balances to get wallet balance (for all the addresses) /wallet/transactions to get wallet transactions (for all the addresses)","title":"Node Wallet"},{"location":"dev/Integration/guide/#doing-an-external-wallet","text":"If you are going to do wallet logic externally, you can do it with a library and also the block explorer. Please note, you need to consider mempool transactions to avoid double-spending generation . Available libraries are: ergo-wallet made in Java (sources are in Ergo node repository ) sigma-rust in Rust with WASM bindings for JavaScript/TypeScript ergo-ts in TypeScript ergo-golang in Go (still raw)","title":"Doing an external wallet"},{"location":"dev/Integration/guide/#offline-signing","text":"Transaction assembly and offline signing demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/c040f244865a451b94df01032c7a3456 Transaction assembly and signing in Rust https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/tx_builder.rs#L552-L592 https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/signing.rs#L133-L161 Transaction assembly and signing in JavaScript https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/bindings/ergo-lib-wasm/tests/test_transaction.js#L9-L69","title":"Offline Signing"},{"location":"dev/Integration/guide/#composing-transaction-outside-the-node","text":"To get unspent UTXOs for some address, please use transactions/boxes/byAddress/unspent Explorer API method: https://api.ergoplatform.com/transactions/boxes/byAddress/unspent/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M . You need to exclude UTXOs spent in the mempool! Use /transactions/unconfirmed/byAddress Explorer API method for that: https://api.ergoplatform.com/transactions/unconfirmed/byAddress/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M","title":"Composing transaction outside the node"},{"location":"dev/Integration/guide/#broadcasting-transaction","text":"To broadcast a transaction made outside the node, the easiest way is to serialize it into JSON, in Java it could be like: Json json = JsonCodecsWrapper.ergoLikeTransactionEncoder().apply(tx); System.out.println(json.toString()); and then send this json via POST request to the public explorer https://api.ergoplatform.com/api/v0/transactions/send , your private explorer or a node with open API (POST to http://{node_ip}:9053/transactions )","title":"Broadcasting transaction"},{"location":"dev/Integration/guide/#address-generation","text":"Secret seed and derived addresses generation demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/70dcfa841dfb504721f09c911b0fc53d","title":"Address generation"},{"location":"dev/Integration/guide/#own-testnet-and-explorer-infrastructure","text":"You can use ergo-bootstrap to install Explorer backend easily (and so not rely on public ones). To start your own testnet, use the following node: ergo { networkType = \"testnet\" node { mining = true offlineGeneration = true useExternalMiner = false } } scorex { network { bindAddress = \"0.0.0.0:9020\" nodeName = \"ergo-testnet-4.0.4\" knownPeers = [] } restApi { # Hex-encoded Blake2b256 hash of an API key. Should be 64-chars long Base16 string. # Below is hash corresponding to API_KEY = \"hello\" (with no quotes) apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } } and then the node will CPU-mine its own chain. Any suggestions for improvements are welcomed! Please send them to team@ergoplatform.org or #development channel in Discord https://discord.gg/kj7s7nb","title":"Own Testnet and Explorer Infrastructure"},{"location":"dev/Languages/csharp/","text":"C Tutorials How-to Guides Ergo with C# 101 Explanations References","title":"C#"},{"location":"dev/Languages/csharp/#c","text":"","title":"C"},{"location":"dev/Languages/csharp/#tutorials","text":"","title":"Tutorials"},{"location":"dev/Languages/csharp/#how-to-guides","text":"Ergo with C# 101","title":"How-to Guides"},{"location":"dev/Languages/csharp/#explanations","text":"","title":"Explanations"},{"location":"dev/Languages/csharp/#references","text":"","title":"References"},{"location":"dev/Languages/java/","text":"Tutorials See AppKit","title":"Java"},{"location":"dev/Languages/java/#tutorials","text":"See AppKit","title":"Tutorials"},{"location":"dev/Languages/rust/","text":"Rust sigma-rust is an alternative and simple implementation of ErgoTree interpreter and transaction building tools. The goal for the Rust version is to be on par with Scala version feature-wise. Now Rust version is still significantly behind. Also the goal for the Rust version is to have bindings for web, iOS and Android. The Scala version will continue to be the primary choice for JVM ecosystem with Rust version covering the rest. Contributing A list of \" good first \" issues is available on GitHub - @greenhat on Discord is ready to assist anyone who is interested. The sigma-rust GitHub repo is here . There is an issues tab with labeled tasks anyone can pick up. If you are working on something, leave a comment so others know. - contributing References This document describes the high-level architecture of ErgoScript compiler and ErgoTree interpreter. Rust port of AVL tree from scrypto package. Ergo Utilities | simplify writing off-chain code in Rust.","title":"Rust"},{"location":"dev/Languages/rust/#rust","text":"sigma-rust is an alternative and simple implementation of ErgoTree interpreter and transaction building tools. The goal for the Rust version is to be on par with Scala version feature-wise. Now Rust version is still significantly behind. Also the goal for the Rust version is to have bindings for web, iOS and Android. The Scala version will continue to be the primary choice for JVM ecosystem with Rust version covering the rest.","title":"Rust"},{"location":"dev/Languages/rust/#contributing","text":"A list of \" good first \" issues is available on GitHub - @greenhat on Discord is ready to assist anyone who is interested. The sigma-rust GitHub repo is here . There is an issues tab with labeled tasks anyone can pick up. If you are working on something, leave a comment so others know. - contributing","title":"Contributing"},{"location":"dev/Languages/rust/#references","text":"This document describes the high-level architecture of ErgoScript compiler and ErgoTree interpreter. Rust port of AVL tree from scrypto package. Ergo Utilities | simplify writing off-chain code in Rust.","title":"References"},{"location":"dev/Languages/scala/","text":"Scala Ergo's primary language is Scala. Similarily, the scripting language used by ergo - ergoscript , is based on Scala. Learn Tutorials, How to Guides and Explanations found in the relevent sections - See ErgoScript - See AppKit References Sigmastate-Interpreter | The Sigmastate-Interpreter is a ErgoScript compiler and ErgoTree Interpreter implementation for Ergo blockchain's Sigma Language For development of Ergo applications using JVM languages a better alternative is to use Appkit . ScoreX , the open-source, modular blockchain & cryptocurrency framework. Scrypto | Scrypto is an open source cryptographic toolkit designed to make it easier and safer for developers to use cryptography in their applications based on Scorex This library is used internally in Ergo Node and ergo-wallet , the public interfaces are subject to change.","title":"Scala"},{"location":"dev/Languages/scala/#scala","text":"Ergo's primary language is Scala. Similarily, the scripting language used by ergo - ergoscript , is based on Scala.","title":"Scala"},{"location":"dev/Languages/scala/#learn","text":"Tutorials, How to Guides and Explanations found in the relevent sections - See ErgoScript - See AppKit","title":"Learn"},{"location":"dev/Languages/scala/#references","text":"Sigmastate-Interpreter | The Sigmastate-Interpreter is a ErgoScript compiler and ErgoTree Interpreter implementation for Ergo blockchain's Sigma Language For development of Ergo applications using JVM languages a better alternative is to use Appkit . ScoreX , the open-source, modular blockchain & cryptocurrency framework. Scrypto | Scrypto is an open source cryptographic toolkit designed to make it easier and safer for developers to use cryptography in their applications based on Scorex This library is used internally in Ergo Node and ergo-wallet , the public interfaces are subject to change.","title":"References"},{"location":"dev/data-model/BlockP2P/","text":"","title":"BlockP2P"},{"location":"dev/data-model/box/","text":"Box Ergo has Bitcoin-like UTXO transactional model: a transaction is spending one-time objects and creating new one-time objects. We call this object a box. A box is immutable object which could be only created or removed. A box is not simply a coin, rather, it is contains registers with data (and code). Even more, there's nothing in box but registers. There are four predefined registers, with monetary value, protecting script, and identifier of a transaction which created the box and output index in the transaction (and also creation height). Because data of transaction which created the box is included into it, the box has unique contents and thus unique id. A box is first-class citizen in the Ergo protocol. Active boxes set is authenticated via a hash-based data structure, which allows to build lightweight full-nodes (as described in https://eprint.iacr.org/2016/994 ). A box may have up to six additional registers with typed data. A script may access its registers (as well as registers of input and output boxes of the spending transaction). Example of a box (proof-of-no-premine from Ergo genesis state, which contains last block ids from Bitcoin and Ethereum at the moment of launch, and also latest news headlines): { \"boxId\": \"b8ce8cfe331e5eadfb0783bdc375c94413433f65e1e45857d71550d42e4d83bd\", \"value\": 1000000000, \"ergoTree\": \"10010100d17300\", \"assets\": [], \"creationHeight\": 0, \"additionalRegisters\": { \"R5\": \"0e42307864303761393732393334363864393133326335613261646162326535326132333030396536373938363038653437623064323632336337653365393233343633\", \"R6\": \"0e464272657869743a20626f746820546f727920736964657320706c617920646f776e207269736b206f66206e6f2d6465616c20616674657220627573696e65737320616c61726d\", \"R8\": \"0e45d094d0b8d0b2d0b8d0b4d0b5d0bdd0b4d18b20d0a7d0a2d09fd09720d0b2d18bd180d0b0d181d182d183d18220d0bdd0b02033332520d0bdd0b020d0b0d0bad186d0b8d18e\", \"R7\": \"0e54e8bfb0e8af84efbc9ae5b9b3e8a1a1e38081e68c81e7bbade38081e58c85e5aeb9e28094e28094e696b0e697b6e4bba3e5ba94e5afb9e585a8e79083e58c96e68c91e68898e79a84e4b8ade59bbde4b98be98193\", \"R4\": \"0e4030303030303030303030303030303030303031346332653265376533336435316165376536366636636362363934326333343337313237623336633333373437\" } } A box, at the minimum, has four pieces of information. The value in NanoErgs ( 1 Erg = 1000000000 NanoErgs ). The guard script (like scriptPubKey of Bitcoin). This is also called the \"smart contract.\" Additional assets (tokens) are stored in this box. Creation info of the box ( txId , the identifier of the transaction that created the box along with an output index). It also contains a maxCreation height parameter defined by the box creator (this is not the creation height; its use is to create \"payment channels easily\"). R0 = monetary value R1 = protecting script R2 = tokens <\u2014 this was missed R3 = identifier of a transaction which created the box and output index in the transaction (and also creation height). These are stored in the first four registers (numbered R0-R3) of the box. In addition, a box can have six optional registers (R4-R9) to store custom data for use in smart contracts. Registers must be densely packed; that is, we cannot sandwich empty registers between non-empty ones. The optional registers can contain data of any of the following types: Int , Long with the usual semantics of Scala. BigInt , which is a 256-bit integer (i.e., all computation is done modulo 2^256). GroupElement , a point on the Secp256k1 curve represented in compressed format. Coll[Byte] , a collection of bytes, semantically similar to Array[Byte] in Scala. Collection of the above, i.e., Coll[Int] , Coll[GroupElement] , Coll[Coll[Byte]] , etc. A boxId is calculated based on the contents of all the registers. This boxId uniquely defines a box and can be considered equivalent to Bitcoin's (txId, vOut) pairs. Note that Ergo txId depends only on the message and not on signatures (similar to Bitcoin SegWit transactions). Hence, a txId is available even before signing. Similar to Bitcoin, Ergo supports chained transactions (i.e., spending of boxes with 0 confirmations). Anatomy of an Ergo transaction Articles UTXO Model Transaction Off-chain Logic and eUTXO An Ergo transaction consists of: One or more Input boxes (source of funds). These boxes must already exist and will be destroyed. The guard script in each of these boxes will be evaluated and must return true for the transaction to be considered valid, One or more Output boxes (destination of funds). These boxes will be created. Zero or more Data-Inputs boxes. These are additional boxes whose data can be referenced and used by smart contracts of the inputs. The guard script in these boxes will not be evaluated. Data inputs are unique to Ergo and not yet present in other extended-UTXO systems. Multiple transactions can share a data-input box, and it will store only a single reference to the box in the block. We can also spend a data-input box in the same transaction as long as it existed before the transaction was applied. As an example, the box with id d2b9b6536287b242f436436ce5a1e4a117d7b4843a13ce3abe3168bff99924a1 was used as both an input and a data-input in this transaction. While the use of data-inputs may not be immediately apparent, they play a major role in making Ergo more friendly to DeFi applications where we want to refer to a box without needing (or having the ability) to spend it such as in decentralized order-books (DEX). For instance, the above transaction used a \"timestamping service\" to timestamp a box provided as data input. A script in Ergo can refer to other boxes in the transaction. For instance, the code snippet INPUTS(0).value > 10000 && OUTPUTS(1).value > 20000 in any of the inputs boxes would enforce that the first input and the second output boxes must have a value greater than 10000 and 20000 , respectively.","title":"Box"},{"location":"dev/data-model/box/#box","text":"Ergo has Bitcoin-like UTXO transactional model: a transaction is spending one-time objects and creating new one-time objects. We call this object a box. A box is immutable object which could be only created or removed. A box is not simply a coin, rather, it is contains registers with data (and code). Even more, there's nothing in box but registers. There are four predefined registers, with monetary value, protecting script, and identifier of a transaction which created the box and output index in the transaction (and also creation height). Because data of transaction which created the box is included into it, the box has unique contents and thus unique id. A box is first-class citizen in the Ergo protocol. Active boxes set is authenticated via a hash-based data structure, which allows to build lightweight full-nodes (as described in https://eprint.iacr.org/2016/994 ). A box may have up to six additional registers with typed data. A script may access its registers (as well as registers of input and output boxes of the spending transaction). Example of a box (proof-of-no-premine from Ergo genesis state, which contains last block ids from Bitcoin and Ethereum at the moment of launch, and also latest news headlines): { \"boxId\": \"b8ce8cfe331e5eadfb0783bdc375c94413433f65e1e45857d71550d42e4d83bd\", \"value\": 1000000000, \"ergoTree\": \"10010100d17300\", \"assets\": [], \"creationHeight\": 0, \"additionalRegisters\": { \"R5\": \"0e42307864303761393732393334363864393133326335613261646162326535326132333030396536373938363038653437623064323632336337653365393233343633\", \"R6\": \"0e464272657869743a20626f746820546f727920736964657320706c617920646f776e207269736b206f66206e6f2d6465616c20616674657220627573696e65737320616c61726d\", \"R8\": \"0e45d094d0b8d0b2d0b8d0b4d0b5d0bdd0b4d18b20d0a7d0a2d09fd09720d0b2d18bd180d0b0d181d182d183d18220d0bdd0b02033332520d0bdd0b020d0b0d0bad186d0b8d18e\", \"R7\": \"0e54e8bfb0e8af84efbc9ae5b9b3e8a1a1e38081e68c81e7bbade38081e58c85e5aeb9e28094e28094e696b0e697b6e4bba3e5ba94e5afb9e585a8e79083e58c96e68c91e68898e79a84e4b8ade59bbde4b98be98193\", \"R4\": \"0e4030303030303030303030303030303030303031346332653265376533336435316165376536366636636362363934326333343337313237623336633333373437\" } } A box, at the minimum, has four pieces of information. The value in NanoErgs ( 1 Erg = 1000000000 NanoErgs ). The guard script (like scriptPubKey of Bitcoin). This is also called the \"smart contract.\" Additional assets (tokens) are stored in this box. Creation info of the box ( txId , the identifier of the transaction that created the box along with an output index). It also contains a maxCreation height parameter defined by the box creator (this is not the creation height; its use is to create \"payment channels easily\"). R0 = monetary value R1 = protecting script R2 = tokens <\u2014 this was missed R3 = identifier of a transaction which created the box and output index in the transaction (and also creation height). These are stored in the first four registers (numbered R0-R3) of the box. In addition, a box can have six optional registers (R4-R9) to store custom data for use in smart contracts. Registers must be densely packed; that is, we cannot sandwich empty registers between non-empty ones. The optional registers can contain data of any of the following types: Int , Long with the usual semantics of Scala. BigInt , which is a 256-bit integer (i.e., all computation is done modulo 2^256). GroupElement , a point on the Secp256k1 curve represented in compressed format. Coll[Byte] , a collection of bytes, semantically similar to Array[Byte] in Scala. Collection of the above, i.e., Coll[Int] , Coll[GroupElement] , Coll[Coll[Byte]] , etc. A boxId is calculated based on the contents of all the registers. This boxId uniquely defines a box and can be considered equivalent to Bitcoin's (txId, vOut) pairs. Note that Ergo txId depends only on the message and not on signatures (similar to Bitcoin SegWit transactions). Hence, a txId is available even before signing. Similar to Bitcoin, Ergo supports chained transactions (i.e., spending of boxes with 0 confirmations).","title":"Box"},{"location":"dev/data-model/box/#anatomy-of-an-ergo-transaction","text":"Articles UTXO Model Transaction Off-chain Logic and eUTXO","title":"Anatomy of an Ergo transaction"},{"location":"dev/data-model/box/#an-ergo-transaction-consists-of","text":"One or more Input boxes (source of funds). These boxes must already exist and will be destroyed. The guard script in each of these boxes will be evaluated and must return true for the transaction to be considered valid, One or more Output boxes (destination of funds). These boxes will be created. Zero or more Data-Inputs boxes. These are additional boxes whose data can be referenced and used by smart contracts of the inputs. The guard script in these boxes will not be evaluated. Data inputs are unique to Ergo and not yet present in other extended-UTXO systems. Multiple transactions can share a data-input box, and it will store only a single reference to the box in the block. We can also spend a data-input box in the same transaction as long as it existed before the transaction was applied. As an example, the box with id d2b9b6536287b242f436436ce5a1e4a117d7b4843a13ce3abe3168bff99924a1 was used as both an input and a data-input in this transaction. While the use of data-inputs may not be immediately apparent, they play a major role in making Ergo more friendly to DeFi applications where we want to refer to a box without needing (or having the ability) to spend it such as in decentralized order-books (DEX). For instance, the above transaction used a \"timestamping service\" to timestamp a box provided as data input. A script in Ergo can refer to other boxes in the transaction. For instance, the code snippet INPUTS(0).value > 10000 && OUTPUTS(1).value > 20000 in any of the inputs boxes would enforce that the first input and the second output boxes must have a value greater than 10000 and 20000 , respectively.","title":"An Ergo transaction consists of:"},{"location":"dev/data-model/p2p-handshake/","text":"Handshaking To establish a connection with another peer, handshake messages exchange is needed in the first place. This document describes handshaking procedure and messages format. Peer Feature Every peer can have one or more peer features. A peer feature describes some properties of a peer. Features are embedded into a handshake message and remain unchanged during the connection. Features are optional by default: a peer can add new ones, and if another peer is not recognizing it, the feature will be skipped. Feature format is arbitrary. Any number of features can be added to the handshake, only handshake message has size limit (8 KB). The only feature the reference client supported before 3.3.7 is \"mode feature\" (describing operating regime of the peer). Since 3.3.7, a new feature describing network magic and (pseudorandom) session id added Handshake Format Length Field Name Details 6-8 Time Reported handshake time (VLQ-encoded, 6 bytes now, 8 bytes max) 1 Agent name length Length of agent name string (unsigned byte) 0-255 Agent name Agent name (e.g. \"Cypra wallet\") in UTF-8 encoding, 255 bytes max 3 Network protocol version Protocol version (e.g. [0, 1, 1] 1 Peer name length Length of peer name string 0-255 Peer name Peer name (e.g. \"kushti's node\") in UTF-8 encoding, 255 bytes max 1 Public node flag Flag indicating whether the node has a public address (0 or 1) (1) Public address length Length of public address (*) Public address Public IP address bytes, IPv4 of IPv6, 4 or 6 bytes, see Note 2 (4) Public address port Public address port 1 Number of peer features How many features are encoded further (unsigned byte) * Features Serialized features, one after another (specified below) For client capabilities (Mode feature): Length Field Name Details 1 Feature id for mode feature = 16 1-2 Feature body length Length of feature description (VLQ-encoded, up to 2 bytes) 1 State type State representation, 0 = utxo, 1 = digest 1 Whether the peer verifying transactions 1 = transactions being verified, 0 = not verified 1 Whether the node bootstrapped via NiPoPoW 1 if yes, 0 if no (then following field is missed) (4) Nipopow suffix length Suffix length for NiPoPoW bootstrapping 1-4 How many block kept signed integer (ZigZag then VLQ encoded), if -1 then all the blocks are stored For session peer feature introduced in 3.3.7: Length Field Name Details 1 Feature id for session feature = 3 1-2 Feature body length Length of feature description (VLQ-encoded, up to 2 bytes) 4 Network magic Network magic bytes, see notes 8 Session id 64 bits long random session id Notes: For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). For IPv4 or IP6 address bytes, \"The result is in network byte order: the highest order byte of the address is in getAddress()[0] . Please check Inet4Address.getAddress() or Inet4Address.getAddress() in Java's JDK for details. For reference client, session id is currently used only to avoid connections to self Handshake Procedure A peer is sending a handshake message, another replies. If there's no handshake got within handshakeTimeout , then connection is dropped. Default value for handshakeTimeout = 30s","title":"Modifiers Exchange"},{"location":"dev/data-model/p2p-handshake/#handshaking","text":"To establish a connection with another peer, handshake messages exchange is needed in the first place. This document describes handshaking procedure and messages format.","title":"Handshaking"},{"location":"dev/data-model/p2p-handshake/#peer-feature","text":"Every peer can have one or more peer features. A peer feature describes some properties of a peer. Features are embedded into a handshake message and remain unchanged during the connection. Features are optional by default: a peer can add new ones, and if another peer is not recognizing it, the feature will be skipped. Feature format is arbitrary. Any number of features can be added to the handshake, only handshake message has size limit (8 KB). The only feature the reference client supported before 3.3.7 is \"mode feature\" (describing operating regime of the peer). Since 3.3.7, a new feature describing network magic and (pseudorandom) session id added","title":"Peer Feature"},{"location":"dev/data-model/p2p-handshake/#handshake-format","text":"Length Field Name Details 6-8 Time Reported handshake time (VLQ-encoded, 6 bytes now, 8 bytes max) 1 Agent name length Length of agent name string (unsigned byte) 0-255 Agent name Agent name (e.g. \"Cypra wallet\") in UTF-8 encoding, 255 bytes max 3 Network protocol version Protocol version (e.g. [0, 1, 1] 1 Peer name length Length of peer name string 0-255 Peer name Peer name (e.g. \"kushti's node\") in UTF-8 encoding, 255 bytes max 1 Public node flag Flag indicating whether the node has a public address (0 or 1) (1) Public address length Length of public address (*) Public address Public IP address bytes, IPv4 of IPv6, 4 or 6 bytes, see Note 2 (4) Public address port Public address port 1 Number of peer features How many features are encoded further (unsigned byte) * Features Serialized features, one after another (specified below) For client capabilities (Mode feature): Length Field Name Details 1 Feature id for mode feature = 16 1-2 Feature body length Length of feature description (VLQ-encoded, up to 2 bytes) 1 State type State representation, 0 = utxo, 1 = digest 1 Whether the peer verifying transactions 1 = transactions being verified, 0 = not verified 1 Whether the node bootstrapped via NiPoPoW 1 if yes, 0 if no (then following field is missed) (4) Nipopow suffix length Suffix length for NiPoPoW bootstrapping 1-4 How many block kept signed integer (ZigZag then VLQ encoded), if -1 then all the blocks are stored For session peer feature introduced in 3.3.7: Length Field Name Details 1 Feature id for session feature = 3 1-2 Feature body length Length of feature description (VLQ-encoded, up to 2 bytes) 4 Network magic Network magic bytes, see notes 8 Session id 64 bits long random session id Notes: For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). For IPv4 or IP6 address bytes, \"The result is in network byte order: the highest order byte of the address is in getAddress()[0] . Please check Inet4Address.getAddress() or Inet4Address.getAddress() in Java's JDK for details. For reference client, session id is currently used only to avoid connections to self","title":"Handshake Format"},{"location":"dev/data-model/p2p-handshake/#handshake-procedure","text":"A peer is sending a handshake message, another replies. If there's no handshake got within handshakeTimeout , then connection is dropped. Default value for handshakeTimeout = 30s","title":"Handshake Procedure"},{"location":"dev/data-model/p2p-protocol/","text":"Handshake First of all, nodes are doing handshaking by sending each other handshake messages. Handshaking details are provided in dedicated P2P Handshaking doc Message format Every message in P2P protocol has the following format: Length Field Name Details 4 Magic bytes Network-specific magic bytes, see Note 1. 1 Message code One byte describing message type 4 Message body length Length of handshake body (specified below), as signed 32-bit integer 4 Handshake body checksum First four bytes of blake2b(message body) * Message body Message body (specified below) Notes: For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). No VLQ and ZigZag encoding is used for message length (for historical reasons), bytes are coming in big-endian order.","title":"Protocol Overview"},{"location":"dev/data-model/p2p-protocol/#handshake","text":"First of all, nodes are doing handshaking by sending each other handshake messages. Handshaking details are provided in dedicated P2P Handshaking doc","title":"Handshake"},{"location":"dev/data-model/p2p-protocol/#message-format","text":"Every message in P2P protocol has the following format: Length Field Name Details 4 Magic bytes Network-specific magic bytes, see Note 1. 1 Message code One byte describing message type 4 Message body length Length of handshake body (specified below), as signed 32-bit integer 4 Handshake body checksum First four bytes of blake2b(message body) * Message body Message body (specified below) Notes: For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). No VLQ and ZigZag encoding is used for message length (for historical reasons), bytes are coming in big-endian order.","title":"Message format"},{"location":"dev/data-model/transactions/","text":"","title":"Transactions"},{"location":"dev/ergo/a/","text":"diff readjustment leads to timewarp attacks etc. Ergo is already using epoch length of ~1.5 days (with normal block rate), not Bitcoin's 2 weeks. However, more epochs considered, but retargeting function is non-linear also, so may adjust sooner than linear function in certain popular scenarios. coin hopping was one of the motivations there Our algo will adjust slowly yes, but it is also preventing from adversarial hopping.","title":"A"},{"location":"dev/ergo/eutxo/","text":"UTXO has many advantages over the account-based model used by Ethereum. It provides superior: Privacy, as UTXOs are one-time objects making it possible to formalise privacy leaks. Scalability, as parallel transaction processing is more straightforward in UTXO. UTXOs are also more friendly to known stateless client solutions. Interoperability, as off-chain and sidechain protocols. One-time objects are more straightforward to work with from an off-chain point of view. Transaction Cost Predictability, where the only on-chain action is validating the smart contracts. As a result, the transaction cost is significantly lower, and most importantly, the transaction cost is predictable, eliminating the need for \u2018gas.\u2019 ErgoScript is built considering Bitcoin\u2019s security and privacy and the purpose of making all kinds of complex financial contracts accessible to everyone. However, Bitcoin\u2019s design doesn\u2019t allow loops, and building complex smart contracts on top of it aren\u2019t possible. ErgoScript allows for self-replication; therefore, it can be used to create Turing-Complete processes in a blockchain. Another approach to creating smart contracts in the blockchain is the Account-Based model, like on Ethereum. Ethereum\u2019s design facilitates smart contract opeld coins, so the unspent transaction output (UTXO) show us which private key holds which coiration by processing smart contracts as accounts. In Bitcoin, there aren\u2019t accounts that hons. Coins are in a set of addresses represented with a single UTXO. It\u2019s also easier to include privacy schemes in this model than the Account-Based model. Therefore, Ergo developed Bitcoin\u2019s UTXO model to the extended UTXO model by introducing a readable UTXO design. This enables smart contracts to use UTXOs as data inputs without changing them. Therefore nodes are checking transactions rather than balances. In comparison, in Ethereum\u2019s Account model, nodes check all accounts to validate the system. Side by side, the UTXO model is more scalable, but it\u2019s also more complicated to build User Interface tools. The account model provides easier access to developers, but codes are heavier on the blockchain, leading to network congestion. Furthermore, UTXO allows for parallel computation, and it\u2019s easier to compute atomic swaps in a non-custodial manner. https://ergoplatform.org/en/blog/2021-10-04-off-chain-logic-and-eutxo/ https://ergoplatform.org/en/blog/2021-09-26-the-utxo-alliance/ Ergo takes the most secure and well-established features of Bitcoin and implements advanced new cryptographic features on its rock-solid foundations. This series explores our choices in creating Ergo, with the first article unpacking the advantages of the UTXO model. When you\u2019re dealing with financial value, you cannot afford to take chances. Every architecture decision in a cryptocurrency platform has implications. While there are different ways to solve the same problem, some solutions are better tested and more reliable. Like Bitcoin, Ergo uses the \u2018UTXO\u2019 (unspent transaction outputs) model rather than the Account model used by platforms like Ethereum. There are several reasons why we have made this choice, but first, it\u2019s worth explaining a little about how the UTXO or \u2018Box\u2019 model works. Most people think that the balance of an account is a simple number that is updated when you send or receive funds. This is the obvious way to approach the problem; it is effectively how money works in the real world. Your bank account has a balance that is increased or decreased when different transfers are made in and out. This is how the \u2018Account\u2019 model operates: your balance on the blockchain is altered by transactions to and from the account. How much dough? The UTXO model, pioneered by Bitcoin, is quite different. You can think of this a bit like a person holding a series of lumps of bread dough. Their balance is the sum of these lumps or UTXOs. Lumps can be divided or combined before they are sent to a new address, but you always know where they came from. For example: Alice has 100g of bread dough (100 ERG). She breaks off a lump of 75g and gives it to Bob, keeping 25g of \u2018change\u2019 for herself. Charlie has 250g of dough. He breaks off 150g and gives it to Bob, keeping 100g of change for himself. Bob breaks 20g of dough off the 150g lump he received from Charlie and combines the resulting 130g with the 75g he received from Alice. He gives the total of 205g to Dave, keeping the 20g change for himself. Dave now has 205g of bread dough, which used to belong to Charlie. Before Charlie owned it, 75g used to belong to Alice, while 130g belonged to Bob. In the UTXO model, \u2018lumps\u2019 of coins can be combined and divided, but they aren\u2019t mixed together unlike bread dough. You can follow the history of funds right back to the coinbase transaction in which those coins were first mined. That\u2019s very different to the Account model, where the balance of each account is simply changed. (You can, of course, check the blockchain to make sure the Account says what it should, but that\u2019s not intrinsically necessary like it is with the UTXO approach.) Why UTXO? The UXTO model has several implications. For a start, each object is immutable \u2013 lumps of coins cannot be \u2018edited\u2019 like an Account balance is edited when a transaction is made. The balance is calculated from the transaction history, right back to when those coins first came into existence. That makes security much simpler because either a UTXO exists in the form you are expecting, or it does not exist at all. With the account model, you need to carefully check that the account you\u2019re dealing with is in the state it should be (and developers typically don\u2019t do that correctly). This also makes UTXOs more friendly for off-chain protocols, like sidechains and the Lightning Network. Accounts make it easier to store the \u2018state\u2019, but easy doesn\u2019t always mean better. With Ergo\u2019s extended UTXO model, state transitions are more explicit and cleaner \u2013 there are no unwanted surprises. It might be a bit more burdensome to deal with, but it\u2019s a lot better and more straightforward in terms of security.","title":"Eutxo"},{"location":"dev/ergo/eutxo/#how-much-dough","text":"The UTXO model, pioneered by Bitcoin, is quite different. You can think of this a bit like a person holding a series of lumps of bread dough. Their balance is the sum of these lumps or UTXOs. Lumps can be divided or combined before they are sent to a new address, but you always know where they came from. For example: Alice has 100g of bread dough (100 ERG). She breaks off a lump of 75g and gives it to Bob, keeping 25g of \u2018change\u2019 for herself. Charlie has 250g of dough. He breaks off 150g and gives it to Bob, keeping 100g of change for himself. Bob breaks 20g of dough off the 150g lump he received from Charlie and combines the resulting 130g with the 75g he received from Alice. He gives the total of 205g to Dave, keeping the 20g change for himself. Dave now has 205g of bread dough, which used to belong to Charlie. Before Charlie owned it, 75g used to belong to Alice, while 130g belonged to Bob. In the UTXO model, \u2018lumps\u2019 of coins can be combined and divided, but they aren\u2019t mixed together unlike bread dough. You can follow the history of funds right back to the coinbase transaction in which those coins were first mined. That\u2019s very different to the Account model, where the balance of each account is simply changed. (You can, of course, check the blockchain to make sure the Account says what it should, but that\u2019s not intrinsically necessary like it is with the UTXO approach.)","title":"How much dough?"},{"location":"dev/ergo/eutxo/#why-utxo","text":"The UXTO model has several implications. For a start, each object is immutable \u2013 lumps of coins cannot be \u2018edited\u2019 like an Account balance is edited when a transaction is made. The balance is calculated from the transaction history, right back to when those coins first came into existence. That makes security much simpler because either a UTXO exists in the form you are expecting, or it does not exist at all. With the account model, you need to carefully check that the account you\u2019re dealing with is in the state it should be (and developers typically don\u2019t do that correctly). This also makes UTXOs more friendly for off-chain protocols, like sidechains and the Lightning Network. Accounts make it easier to store the \u2018state\u2019, but easy doesn\u2019t always mean better. With Ergo\u2019s extended UTXO model, state transitions are more explicit and cleaner \u2013 there are no unwanted surprises. It might be a bit more burdensome to deal with, but it\u2019s a lot better and more straightforward in terms of security.","title":"Why UTXO?"},{"location":"dev/ergo/protocol/","text":"The Ergo Protocol Ergo is a Resilient Platform for Contractual Money . Designed with the main focus to provide an efficient, secure, and easy way to implement financial contracts. Ergo builds advanced cryptographic features and radically new DeFi functionality on the rock-solid foundations laid by a decade of blockchain theory and development. It complements tried and tested principles with the latest peer-reviewed academic research into cryptography, consensus models, and digital currencies. With a research-driven but practical development model, Ergo has prioritized useful features without compromising on security. Extended support of light nodes makes Ergo friendly for end-users, allowing them to run contracts on common devices such as mobile phones without centralized intermediaries. To be useful in the long-term, we use widely-researched solutions with high-security guarantees while also preventing performance degradation over time with a new economic model. All cryptocurrencies rely on contributions from the scientific research community. Ergo brings it in its core! The Manifesto Cryptocurrency should provide tools to enrich ordinary people. The small businesses that are getting not much above making ends meet, not depersonalized big financial capital. This is what inspired me. This is my dream. Proof-of-Work Ergo uses Autolykos as the underlying PoW algorithm. Autolykos v2 (the current version of PoW) is a memory-hard ASIC-resistant PoW algorithm oriented towards GPUs. eUTXO The platform's smart contracts are built on the extended UTXO (eUTXO) model with a unique data input concept, offering a radically different approach to provide robust, flexible cryptography and easy, safe scripting on privacy-centric Sigma Protocols (non-interactive zero-knowledge proofs). Ergo is a UTXO based blockchain with Proof-of-Work consensus. In this aspect, it is similar to Bitcoin. Ergo uses standard Elliptic Curve Cryptography with the same curve as Bitcoin ( Secp256k1 ). Unlike Bitcoin and similar to Cardano, Ergo uses a so-called \"extended-UTXO model,\" which implies UTXOs with the ability to contain arbitrary data and sophisticated scripts. Due to this, Ergo supports advanced financial contracts similar to those in Ethereum's account-based model. ErgoScript Ergo provides advanced programming abilities for financial contracts using a high-level language called ErgoScript. The scripting language in itself is non-Turing complete, but applications run on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper . Ergo provides superior support for real-world financial agreements. It does this through: Support for multi-stage contracts A simple high-level language, ErgoScript, enabling clear descriptions of contractual logic Support for formal verification of contracts for improved security guarantees (Ergo Platform deployed its first formally verified p2p crowdfunding contract just three months after the network launched) Easy Oracle creation Native support for complex signature schemes In short, creating financial contracts on the blockchain isn\u2019t just about the functionality you provide. It\u2019s about making that functionality safe and accessible, as well as powerful. Ergo achieves this and more. Sigma Protocols The cryptographic part of ErgoScript is based on Sigma Protocols and naturally supports threshold m-of-n signatures, ring signatures, and more. Keeping all this in mind, we expect ErgoScript and Ergo's design to be uniquely useful as Contractual Money with countless possible applications. NIPoPoWs Non-Interactive Proofs of Proof of Work ( NIPoPoWs ) are essential for two reasons: Light Clients and Side Chains. These two components are essential for clients and nodes to facilitate easier onboarding to the blockchain. A decentralized network is inherently inefficient because of the randomness mechanism in a synchronous network; that is to say, every time a transaction (TX) occurs on the network, a couple of random nodes must process the TX to prove and secure its reliability. When put into perspective, that is an enormous task on a global scale. There can be billions of transactions, and it is plausible that many of those are from contributors operating with low bandwidth. Storage Rent Another unique feature of Ergo is the concept of storage-rent, which is the ability of miners to take out a small amount of Ergs from boxes that have remained unspent for four or more years (the box is spent, and a new box is created with the lower value). This allows Ergo to avoid long-term bloat of the UTXO set. Scaling Roadmap A Scalability Plan for Ergo Network congestion on Jul, 10th, 2021 Long-Term Vision Long-term vision for Ergo ~ 26 Sept, 2021","title":"The Ergo Protocol"},{"location":"dev/ergo/protocol/#the-ergo-protocol","text":"Ergo is a Resilient Platform for Contractual Money . Designed with the main focus to provide an efficient, secure, and easy way to implement financial contracts. Ergo builds advanced cryptographic features and radically new DeFi functionality on the rock-solid foundations laid by a decade of blockchain theory and development. It complements tried and tested principles with the latest peer-reviewed academic research into cryptography, consensus models, and digital currencies. With a research-driven but practical development model, Ergo has prioritized useful features without compromising on security. Extended support of light nodes makes Ergo friendly for end-users, allowing them to run contracts on common devices such as mobile phones without centralized intermediaries. To be useful in the long-term, we use widely-researched solutions with high-security guarantees while also preventing performance degradation over time with a new economic model. All cryptocurrencies rely on contributions from the scientific research community. Ergo brings it in its core!","title":"The Ergo Protocol"},{"location":"dev/ergo/protocol/#the-manifesto","text":"Cryptocurrency should provide tools to enrich ordinary people. The small businesses that are getting not much above making ends meet, not depersonalized big financial capital. This is what inspired me. This is my dream.","title":"The Manifesto"},{"location":"dev/ergo/protocol/#proof-of-work","text":"Ergo uses Autolykos as the underlying PoW algorithm. Autolykos v2 (the current version of PoW) is a memory-hard ASIC-resistant PoW algorithm oriented towards GPUs.","title":"Proof-of-Work"},{"location":"dev/ergo/protocol/#eutxo","text":"The platform's smart contracts are built on the extended UTXO (eUTXO) model with a unique data input concept, offering a radically different approach to provide robust, flexible cryptography and easy, safe scripting on privacy-centric Sigma Protocols (non-interactive zero-knowledge proofs). Ergo is a UTXO based blockchain with Proof-of-Work consensus. In this aspect, it is similar to Bitcoin. Ergo uses standard Elliptic Curve Cryptography with the same curve as Bitcoin ( Secp256k1 ). Unlike Bitcoin and similar to Cardano, Ergo uses a so-called \"extended-UTXO model,\" which implies UTXOs with the ability to contain arbitrary data and sophisticated scripts. Due to this, Ergo supports advanced financial contracts similar to those in Ethereum's account-based model.","title":"eUTXO"},{"location":"dev/ergo/protocol/#ergoscript","text":"Ergo provides advanced programming abilities for financial contracts using a high-level language called ErgoScript. The scripting language in itself is non-Turing complete, but applications run on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper . Ergo provides superior support for real-world financial agreements. It does this through: Support for multi-stage contracts A simple high-level language, ErgoScript, enabling clear descriptions of contractual logic Support for formal verification of contracts for improved security guarantees (Ergo Platform deployed its first formally verified p2p crowdfunding contract just three months after the network launched) Easy Oracle creation Native support for complex signature schemes In short, creating financial contracts on the blockchain isn\u2019t just about the functionality you provide. It\u2019s about making that functionality safe and accessible, as well as powerful. Ergo achieves this and more.","title":"ErgoScript"},{"location":"dev/ergo/protocol/#sigma-protocols","text":"The cryptographic part of ErgoScript is based on Sigma Protocols and naturally supports threshold m-of-n signatures, ring signatures, and more. Keeping all this in mind, we expect ErgoScript and Ergo's design to be uniquely useful as Contractual Money with countless possible applications.","title":"Sigma Protocols"},{"location":"dev/ergo/protocol/#nipopows","text":"Non-Interactive Proofs of Proof of Work ( NIPoPoWs ) are essential for two reasons: Light Clients and Side Chains. These two components are essential for clients and nodes to facilitate easier onboarding to the blockchain. A decentralized network is inherently inefficient because of the randomness mechanism in a synchronous network; that is to say, every time a transaction (TX) occurs on the network, a couple of random nodes must process the TX to prove and secure its reliability. When put into perspective, that is an enormous task on a global scale. There can be billions of transactions, and it is plausible that many of those are from contributors operating with low bandwidth.","title":"NIPoPoWs"},{"location":"dev/ergo/protocol/#storage-rent","text":"Another unique feature of Ergo is the concept of storage-rent, which is the ability of miners to take out a small amount of Ergs from boxes that have remained unspent for four or more years (the box is spent, and a new box is created with the lower value). This allows Ergo to avoid long-term bloat of the UTXO set.","title":"Storage Rent"},{"location":"dev/ergo/protocol/#scaling","text":"Roadmap A Scalability Plan for Ergo Network congestion on Jul, 10th, 2021","title":"Scaling"},{"location":"dev/ergo/protocol/#long-term-vision","text":"Long-term vision for Ergo ~ 26 Sept, 2021","title":"Long-Term Vision"},{"location":"dev/protocol/address/","text":"Addresses In today's article, we will have a closer look into the Ergo address formatting. In addition to that, we will explain how they work specifically and what makes them preferable to other types of blockchain addresses. Let's start at the very beginning. The moment you install any cryptocurrency wallet, you automatically create an address with it. Very loosely speaking, you can compare a wallet to a traditional bank account and an address to the matching account number. It is precisely one of these alphanumeric addresses needed to either send money from person A to person B, receive money, or withdraw your mining rewards . If you want to start using the Ergo wallet and dive deeper into its functions, check out the the following link . Now, what exactly are addresses? Addresses are short strings that correspond to specific scripts and are used to protect a box ( this post that core developer kushti published on our forum explains very well what a \"box\" is). Unlike a (hex-encoded) binary representation of a script, an Ergo address use a Base58-encoding and therefore have some advantageous characteristics to it which the binary representation does not offer: We can quickly check the integrity of an address via an integrated checksum (which is a \"small-sized datum derived from a block of digital data to detect errors that may have been introduced during its transmission or storage\" according to Wikipedia). A prefix of the address shows you the network and address type. In particular, the network prefix prevents you from mistakenly sending mainnet tokens to the testnet address. The address uses an encoding (namely, Base58 as mentioned) that avoids similarly-looking characters and is friendly to double-clicking and line-breaking in emails. An address encodes network type, address type, checksum, and enough information to correspond with particular scripts. Let's look at the prefix byte, which contains information about the network and address types: Possible Types Possible network types are: Mainnet - 0x00 Testnet - 0x10 Address types are (semantics described below): 0x01 - Pay-to-PublicKey(P2PK) address 0x02 - Pay-to-Script-Hash(P2SH) 0x03 - Pay-to-Script(P2S) For an address type, we form content bytes as follows: P2PK - serialized (compressed) public key P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes P2S - serialized script (this is where mining rewards go!) For example, sending 10 Ergs to a P2PK address usually means that a corresponding transaction will contain a box in which 10 Ergs are locked by a public key encoded in the P2PK address. Similarly, in the case of a P2S address, the box will be locked by a script encoded in the address. In the most complicated case of a P2SH script, the box will be protected by a special predefined script that takes the first 192 bits of Blake2b256 hash value for a script shown by an input spending the box. Here is an example of how particular addresses are going to look on the testnet: 3 - P2PK ( 3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN ) ? - P2SH ( rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB ) ? - P2S ( Ms7smJwLGbUAjuWQ ) And here is how what they look like on the mainnet: 9 - P2PK ( 9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA ) ? - P2SH ( 8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg ) ? - P2S ( 4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ ) Summary Prefix byte = network type + address type (for example, P2S script on the testnet starts with 0x13 before Base58) checksum = leftmost_4_bytes (blake2b256 (prefix byte || content bytes)) address = prefix byte || content bytes || checksum","title":"Addresses"},{"location":"dev/protocol/address/#addresses","text":"In today's article, we will have a closer look into the Ergo address formatting. In addition to that, we will explain how they work specifically and what makes them preferable to other types of blockchain addresses. Let's start at the very beginning. The moment you install any cryptocurrency wallet, you automatically create an address with it. Very loosely speaking, you can compare a wallet to a traditional bank account and an address to the matching account number. It is precisely one of these alphanumeric addresses needed to either send money from person A to person B, receive money, or withdraw your mining rewards . If you want to start using the Ergo wallet and dive deeper into its functions, check out the the following link .","title":"Addresses"},{"location":"dev/protocol/address/#now-what-exactly-are-addresses","text":"Addresses are short strings that correspond to specific scripts and are used to protect a box ( this post that core developer kushti published on our forum explains very well what a \"box\" is). Unlike a (hex-encoded) binary representation of a script, an Ergo address use a Base58-encoding and therefore have some advantageous characteristics to it which the binary representation does not offer: We can quickly check the integrity of an address via an integrated checksum (which is a \"small-sized datum derived from a block of digital data to detect errors that may have been introduced during its transmission or storage\" according to Wikipedia). A prefix of the address shows you the network and address type. In particular, the network prefix prevents you from mistakenly sending mainnet tokens to the testnet address. The address uses an encoding (namely, Base58 as mentioned) that avoids similarly-looking characters and is friendly to double-clicking and line-breaking in emails. An address encodes network type, address type, checksum, and enough information to correspond with particular scripts. Let's look at the prefix byte, which contains information about the network and address types:","title":"Now, what exactly are addresses?"},{"location":"dev/protocol/address/#possible-types","text":"Possible network types are: Mainnet - 0x00 Testnet - 0x10 Address types are (semantics described below): 0x01 - Pay-to-PublicKey(P2PK) address 0x02 - Pay-to-Script-Hash(P2SH) 0x03 - Pay-to-Script(P2S) For an address type, we form content bytes as follows: P2PK - serialized (compressed) public key P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes P2S - serialized script (this is where mining rewards go!) For example, sending 10 Ergs to a P2PK address usually means that a corresponding transaction will contain a box in which 10 Ergs are locked by a public key encoded in the P2PK address. Similarly, in the case of a P2S address, the box will be locked by a script encoded in the address. In the most complicated case of a P2SH script, the box will be protected by a special predefined script that takes the first 192 bits of Blake2b256 hash value for a script shown by an input spending the box. Here is an example of how particular addresses are going to look on the testnet: 3 - P2PK ( 3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN ) ? - P2SH ( rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB ) ? - P2S ( Ms7smJwLGbUAjuWQ ) And here is how what they look like on the mainnet: 9 - P2PK ( 9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA ) ? - P2SH ( 8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg ) ? - P2S ( 4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ )","title":"Possible Types"},{"location":"dev/protocol/address/#summary","text":"Prefix byte = network type + address type (for example, P2S script on the testnet starts with 0x13 before Base58) checksum = leftmost_4_bytes (blake2b256 (prefix byte || content bytes)) address = prefix byte || content bytes || checksum","title":"Summary"},{"location":"dev/protocol/atomic/","text":"Because a blockchain is a siloed, self-contained system by design, it interacts with other blockchain protocols. Atomic Swaps enable the cross-chain exchange of digital assets, avoiding the need for centralised exchanges. Blockchains are excellent at decentralised value transfer within their domains. That is, you can send BTC to any Bitcoin address securely and efficiently, and you can send LTC to any Litecoin address securely and efficiently too. But because blockchains are based on consensus between miners, they are not designed to interface with other blockchains. Trading assets on different blockchains has, therefore, traditionally involved third parties like exchanges and OTC desks \u2013 with all the risks and inefficiencies they bring. Cross-chain swaps Atomic swaps solve this problem by enabling cryptocurrencies to be traded across blockchains. This allows the trustless exchange of assets quickly and efficiently. Here\u2019s how they work in theory: Alice and Bob agree to exchange some cryptocurrency. Alice will send Bob 1 BTC, and Bob will send Alice 50,000 ERG. Neither party trusts the other, so neither wants to send their crypto first. Alice generates a secret \u2013 a long random number \u2013 and hashes it. She then creates a transaction on the Bitcoin blockchain with a script attached, locking 1 BTC and specifying a condition: when the secret (pre-image) to the hash she has created is revealed, the BTC will be sent to Bob\u2019s address. The hash can safely be included in the transaction script because the pre-image cannot be calculated. When the pre-image is revealed, 50,000 locked ERG will be sent from Bob\u2019s address to Alice\u2019s address.* Bob then similarly creates a transaction on the Ergo blockchain, including a script with the same hash Alice has used. Because Bob doesn\u2019t have the pre-image, he can\u2019t execute Alice\u2019s transaction before he has created his own. Once Alice sees that Bob has created his transaction on the Ergo blockchain, she can publish the secret and execute his transaction. Because the pre-image is now public, Bob can also execute the script that will send him his BTC. Neither party can delete their transactions and scripts once they have been posted to the blockchain. They may include a condition that the transaction will expire within a certain time to avoid their coins being locked indefinitely if Alice does not reveal the secret. Ergo\u2019s atomic swaps They are called \u2018atomic\u2019 swaps because the orders are either executed in their entirety or not \u2013 a kind of fill-or-kill order. But while that\u2019s useful up to a point, it doesn\u2019t allow for active trading, like you would be able to do on an exchange. Ergo\u2019s implementation of atomic swaps develops the concept further. It\u2019s relatively easy to swap coins or custom tokens trustlessly across any Bitcoin-like blockchains. But beyond that, Ergo allows partial swaps. Like on a regular exchange, We can partially fill orders if that\u2019s what the trader wants. This means it\u2019s possible to build a fully-fledged decentralised exchange (DEX) that enables cross-chain trading: a trustless version of existing crypto exchanges. There\u2019s no need for any gateways, token wrapping or other potential bottlenecks or points of failure. You can learn more about Ergo\u2019s implementation of atomic swaps and intra-chain and cross-chain token swaps in the ErgoScript white paper .","title":"Atomic Swaps"},{"location":"dev/protocol/atomic/#cross-chain-swaps","text":"Atomic swaps solve this problem by enabling cryptocurrencies to be traded across blockchains. This allows the trustless exchange of assets quickly and efficiently. Here\u2019s how they work in theory: Alice and Bob agree to exchange some cryptocurrency. Alice will send Bob 1 BTC, and Bob will send Alice 50,000 ERG. Neither party trusts the other, so neither wants to send their crypto first. Alice generates a secret \u2013 a long random number \u2013 and hashes it. She then creates a transaction on the Bitcoin blockchain with a script attached, locking 1 BTC and specifying a condition: when the secret (pre-image) to the hash she has created is revealed, the BTC will be sent to Bob\u2019s address. The hash can safely be included in the transaction script because the pre-image cannot be calculated. When the pre-image is revealed, 50,000 locked ERG will be sent from Bob\u2019s address to Alice\u2019s address.* Bob then similarly creates a transaction on the Ergo blockchain, including a script with the same hash Alice has used. Because Bob doesn\u2019t have the pre-image, he can\u2019t execute Alice\u2019s transaction before he has created his own. Once Alice sees that Bob has created his transaction on the Ergo blockchain, she can publish the secret and execute his transaction. Because the pre-image is now public, Bob can also execute the script that will send him his BTC. Neither party can delete their transactions and scripts once they have been posted to the blockchain. They may include a condition that the transaction will expire within a certain time to avoid their coins being locked indefinitely if Alice does not reveal the secret. Ergo\u2019s atomic swaps They are called \u2018atomic\u2019 swaps because the orders are either executed in their entirety or not \u2013 a kind of fill-or-kill order. But while that\u2019s useful up to a point, it doesn\u2019t allow for active trading, like you would be able to do on an exchange. Ergo\u2019s implementation of atomic swaps develops the concept further. It\u2019s relatively easy to swap coins or custom tokens trustlessly across any Bitcoin-like blockchains. But beyond that, Ergo allows partial swaps. Like on a regular exchange, We can partially fill orders if that\u2019s what the trader wants. This means it\u2019s possible to build a fully-fledged decentralised exchange (DEX) that enables cross-chain trading: a trustless version of existing crypto exchanges. There\u2019s no need for any gateways, token wrapping or other potential bottlenecks or points of failure. You can learn more about Ergo\u2019s implementation of atomic swaps and intra-chain and cross-chain token swaps in the ErgoScript white paper .","title":"Cross-chain swaps"},{"location":"dev/protocol/audit/","text":"We want to announce that Ergo has successfully passed a security audit of certain (most critical) parts of the code. This time the audit was done by Jean-Philipee Aumasson (aka veorq, aumasson.jp/ ). The detailed report is below. Nothing critical is found. Comments on issues found: On wallet password, we'll provide a recommendation in subsequent versions of the protocol client. Not sure hard enforcement on passwords will take place, but we'll do more consultations on this. Changing \"n\" and \"k\" parameters makes sense only when launching a new network. Changing these parameters in the mining node will make blocks produced invalid for other nodes. Changing these parameters in the protocol client means going on another fork (blocks coming from the honest protocol participants will be rejected). So no need for extra checks may be, as people launching new networks will set \"n\" and \"k\" properly. Currently, the Ergo node (as well as other blockchain protocol clients and wallets we're aware of and the cryptographic libraries we're using) does not protect from side-channel attacks running locally (e.g. timing attacks or memory inspection by malware or viruses). So please protect the machines you're running wallets on! Ergo security assessment by Jean-Philippe Aumasson on 07/Dec/19 Summary Ergo solicited us to perform a security assessment of several components of their Ergo Platform: Sigma protocol proofs creation and verification Wallet's secure storage of secrets Proof-of-Work validation \u200bThis brief report summarises our assessment and describes our findings and mitigation recommendations. Sigma protocol proofs \u200bThe Ergo protocol relies on ErgoScript, a scripting language supporting sigma-statements, which can be proven and verified through non-interactive proofs of knowledge. These proofs are statements described as a tree of AND, OR, and threshold conditions, whose leaves are proofs of knowledge of a discrete logarithm problem. The proof of the sigma-statement is then made non-interactive thanks to the Fiat-Shamir transform. This logic is specified in the ErgoScript paper , and the specific proving and verification routines described in Appendix A. \u200bImplementation challenges are then to: Define encoding of the proofs that are safe and efficient, and implement serialisation and deserialisation that always successfully processes valid input and gracefully fails to process invalid input. Implement the proving and verification functionalities correctly, in compliance with the specification, and most importantly, no invalid statement can successfully pass verification. We reviewed these two aspects, based on the code in the repository sigmastate-interpreter , and the ErgoScript paper , carefully comparing the intended behaviour (in Appendix A) with the actual behaviour as implemented. \u200bWe notably reviewed code from the SigSerializer , Interpreter , and ProverInterpreter traits and objects. \u200bWe mainly sought bugs from the following classes: \u200bUnsafe processing of malformed input Unsafe processing of unusually long or short input Behavior when large tree depth or recursion level Unsafe use Scala types and structures Inappropriate variable types Integer overflows Race conditions Logic bugs \u200bDespite the extensive review, we did not identify any security issue. The protocol's logic and internals are relatively complex, and we believe the highest risk is in parsing and verifying proofs. To exploit such issues, however, an attacker would have to create a semantically correct script that somehow benefits them yet that passes verification when it does not ought to. Regarding software security, Scala eliminates certain classes of bugs, but Scala code may still suffer from bugs due to Scala's specific behaviour or to unhandled errors. Wallet Ergo's wallet functionality enables its users to store a secret on disk and recover it, initialising the wallet with a new seed when it's first used. \u200bThis logic is mainly defined in ErgoWalletActor , and a key component regarding secrets' storage is JsonSecretStorage . \u200bThe first time a wallet is created, the InitWallet command does the following: Generate settings.walletSettings.seedStrengthBits random bits, as initial entropy. By default , 160 bits are generated. Generate a BIP39 from the random bits generated, which can be seen as encoding the entropy bits. The standard BIP39 logic is used with an optional password. Derive a seed from the mnemonic using BIP39's PBKDF2-based derivation logic. Encrypt this seed to disk with AES-GCM, using a random nonce, and a key derives from the password using PBKDF2-HMAC-SHA256 with 128000 iterations, using a random salt. To unlock a wallet already created, a user provides the password and the wallet attempts to decrypt the stored data. \u200bA similar process as initialisation is performed to restore an existing account from a BIP39 passphrase, except that the wallet will derive the seed from the mnemonic instead of picking a random mnemonic. \u200bThe two risks we identified here are: The absence of checks on the password's length: since the password is sufficient to access the seed given the wallet's on-disk stored secret, the password should, in theory, have at least as much entropy as the mnemonic, and in practice, should be practically hard to crack. We thus recommend enforcing a minimal password length, for example of 16 characters. Copies of secret values (password, seed, and derive private keys) are likely to remain in memory after wallet software execution, an intrinsic limitation of garbage-collected languages such as Scala. Another process or user sharing the same memory address space could potentially recover the secrets, and they could also appear in crash dumps. To the best of our knowledge, there is no effective mitigation in pure Scala. \u200b PoW validation \u200bAfter previously reviewing the security of the Autolykos PoW, we performed another round of review focusing on its latest verification logic, and notably, the changes in the commit eb0f85a . \u200bThe main relevant file is AutolykosPowScheme ,and other important operations are for example implemented in HeadersProcessor and ModifierValidator . \u200bWe checked that the implemented verification logic is consistent with that specified in the Autolykos specifications and that it is appropriately integrated into the block header validation logic. \u200bWe believe the following points should be addressed: Stricter validation of k and n : although the class enforces k<=32 (number of elements in the solution) and n<31 (log2 of the total number of elements), weak could still be created from the authorised parameters. The validate() function may therefore have additional validation that n and k are equal to the intended values. Assert that k and n are positive values, since currently negative ones (as Int's) would pass the assert` statements.","title":"Audit"},{"location":"dev/protocol/audit/#summary","text":"Ergo solicited us to perform a security assessment of several components of their Ergo Platform: Sigma protocol proofs creation and verification Wallet's secure storage of secrets Proof-of-Work validation \u200bThis brief report summarises our assessment and describes our findings and mitigation recommendations.","title":"Summary"},{"location":"dev/protocol/audit/#sigma-protocol-proofs","text":"\u200bThe Ergo protocol relies on ErgoScript, a scripting language supporting sigma-statements, which can be proven and verified through non-interactive proofs of knowledge. These proofs are statements described as a tree of AND, OR, and threshold conditions, whose leaves are proofs of knowledge of a discrete logarithm problem. The proof of the sigma-statement is then made non-interactive thanks to the Fiat-Shamir transform. This logic is specified in the ErgoScript paper , and the specific proving and verification routines described in Appendix A. \u200bImplementation challenges are then to: Define encoding of the proofs that are safe and efficient, and implement serialisation and deserialisation that always successfully processes valid input and gracefully fails to process invalid input. Implement the proving and verification functionalities correctly, in compliance with the specification, and most importantly, no invalid statement can successfully pass verification. We reviewed these two aspects, based on the code in the repository sigmastate-interpreter , and the ErgoScript paper , carefully comparing the intended behaviour (in Appendix A) with the actual behaviour as implemented. \u200bWe notably reviewed code from the SigSerializer , Interpreter , and ProverInterpreter traits and objects. \u200bWe mainly sought bugs from the following classes: \u200bUnsafe processing of malformed input Unsafe processing of unusually long or short input Behavior when large tree depth or recursion level Unsafe use Scala types and structures Inappropriate variable types Integer overflows Race conditions Logic bugs \u200bDespite the extensive review, we did not identify any security issue. The protocol's logic and internals are relatively complex, and we believe the highest risk is in parsing and verifying proofs. To exploit such issues, however, an attacker would have to create a semantically correct script that somehow benefits them yet that passes verification when it does not ought to. Regarding software security, Scala eliminates certain classes of bugs, but Scala code may still suffer from bugs due to Scala's specific behaviour or to unhandled errors.","title":"Sigma protocol proofs"},{"location":"dev/protocol/audit/#wallet","text":"Ergo's wallet functionality enables its users to store a secret on disk and recover it, initialising the wallet with a new seed when it's first used. \u200bThis logic is mainly defined in ErgoWalletActor , and a key component regarding secrets' storage is JsonSecretStorage . \u200bThe first time a wallet is created, the InitWallet command does the following: Generate settings.walletSettings.seedStrengthBits random bits, as initial entropy. By default , 160 bits are generated. Generate a BIP39 from the random bits generated, which can be seen as encoding the entropy bits. The standard BIP39 logic is used with an optional password. Derive a seed from the mnemonic using BIP39's PBKDF2-based derivation logic. Encrypt this seed to disk with AES-GCM, using a random nonce, and a key derives from the password using PBKDF2-HMAC-SHA256 with 128000 iterations, using a random salt. To unlock a wallet already created, a user provides the password and the wallet attempts to decrypt the stored data. \u200bA similar process as initialisation is performed to restore an existing account from a BIP39 passphrase, except that the wallet will derive the seed from the mnemonic instead of picking a random mnemonic. \u200bThe two risks we identified here are: The absence of checks on the password's length: since the password is sufficient to access the seed given the wallet's on-disk stored secret, the password should, in theory, have at least as much entropy as the mnemonic, and in practice, should be practically hard to crack. We thus recommend enforcing a minimal password length, for example of 16 characters. Copies of secret values (password, seed, and derive private keys) are likely to remain in memory after wallet software execution, an intrinsic limitation of garbage-collected languages such as Scala. Another process or user sharing the same memory address space could potentially recover the secrets, and they could also appear in crash dumps. To the best of our knowledge, there is no effective mitigation in pure Scala. \u200b","title":"Wallet"},{"location":"dev/protocol/audit/#pow-validation","text":"\u200bAfter previously reviewing the security of the Autolykos PoW, we performed another round of review focusing on its latest verification logic, and notably, the changes in the commit eb0f85a . \u200bThe main relevant file is AutolykosPowScheme ,and other important operations are for example implemented in HeadersProcessor and ModifierValidator . \u200bWe checked that the implemented verification logic is consistent with that specified in the Autolykos specifications and that it is appropriately integrated into the block header validation logic. \u200bWe believe the following points should be addressed: Stricter validation of k and n : although the class enforces k<=32 (number of elements in the solution) and n<31 (log2 of the total number of elements), weak could still be created from the authorised parameters. The validate() function may therefore have additional validation that n and k are equal to the intended values. Assert that k and n are positive values, since currently negative ones (as Int's) would pass the assert` statements.","title":"PoW validation"},{"location":"dev/protocol/autolykos/","text":"Participate in community discussions around soft-fork! Ergo Emission: details, retargeting via a soft-fork Autolykos Security of Proof-of-Work blockchains relies on multiple miners trying to produce new blocks by participating in a PoW puzzle lottery , and the network is secure if the majority of them are honest. However, the reality becomes much more complicated than the original one-CPU-one-vote idea from the Bitcoin whitepaper. non-outsourceability The first threat to Decentralisation came from mining pools \u2013 miners tend to unite in mining pools. Regardless of the PoW algorithm, the number of pools controlling more than 50% of computational power is usually relatively small: 4 pools in Bitcoin, 2 in Ethereum, 3 in ZCash, etc. This problem led to the notion of non-outsourceable puzzles. These are the puzzles constructed in such a way that if a mining pool outsources the puzzle to a miner, the miner can recover the pool's private key and steal the reward with a non-negligible probability. However, the existing solutions either have too large a solution size (kilobyte is already on the edge of acceptability for distributed ledgers) or very specific and can not be modified or extended in any way without breaking non-outsource-ability. The second threat to cryptocurrencies Decentralisation is that ASIC-equipped miners can find PoW solutions orders of magnitude faster and more efficiently than miners equipped with the commodity hardware, to reduce the disparity between the ASICs and regular hardware memory-bound computations were proposed. The most interesting practical examples are two asymmetric memory-hard PoW schemes that require significantly less memory to verify a solution than to find it. Although ASICs already exist for both of them, they remain the only asymmetric memory-hard PoW algorithms in use. Overview of Ergo PoW called Autolykos (2019) Autolykos: The Ergo Platform PoW Puzzle Autolykos v1 originally had non-outsourcability built-in. However, it became apparent that it's impossible to prevent pools with smart contracts, so they turned it off so that not only larger players could take advantage of the loophole. Ergo is now focusing on memory hardness in an attempt to keep mining as fair as possible, which should help prevent ASICs mining at least. There are also some improvements for pooling, e.g. Stratum 2 protocol. \"Bypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts\" https://ia.cr/2020/044 was presented by Alex Chepurnoy at the WTSC workshop associated with Financial Cryptography and Data Security 2020 in Malaysia. It's also discussed here on 'Unblocked with Robert Kornacki' (14:45) v.2 Autolykos version two follows Autolykos v.1, but with certain modifications made: non-outsourceable puzzles were switched off. It turns out (based on more than one year of non-outsourceable PoW experience) that non-outsourceable PoW is not attractive to small miners. Now, the algorithm is trying to bind an efficient solving procedure with a single table of ~2 GB (initially), which is significantly reducing memory optimizations possibilities table size (memory requirements of a solving algorithm) grows with time The table depends solely on the block height, so there is no penalization for recalculating block candidates for the same height Basic Ideas: Like Autlykos-1, based on the k-sum problem, so a miner needs to find k (k=32) out of N (2^n = 2^26) elements, and the hash of their sum must be less than the target value (inverse of the difficulty) k indexes are pseudorandom values derived from block candidate and nonce N elements are derived from block height and constants, unlike Autolykos v.1, so miners can recalculate block candidates quickly now (so only indexes are depending on them) Indexes calculation also involving the same table (which elements are last 31 bytes of H(i | | h | | M ) , where i is in [0, N), h is block height, M is padding to slow down hash calculation (8kb of constant data). So algorithm tries to make mining efficient for ones that store the table, which is 2^26 * 31 = 2,080,374,784 bytes initially (about 2GB). Thus Autolykos is now is friendly to all the GPUs. Also, table size (N value) is growing with time as follows. Until block 614,400 , N = 2^{26} = 67,108,864 elements (31 bytes each) . From this block, and until block 4,198,400 , every 51,200 blocks N is increased by 5 percent. Since block 4,198,400 , value of N is fixed and equals to 2,143,944,600 . Test vectors for N values are provided in the paper. Ergo PoW Bypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts 51% Attack Mining pools offer a buffer against such network attacks as the hash rate is distributed across thousands of individual miners. Ergo's memory-hardened aspect also makes this vector of attack more expensive as there is no ASIC support to rent. With the collective rentable rigs at the moment, this isn't a viable path to a 51% attack. In theory, someone could build a massive GPU farm to try to launch such an attack. If a bad actor can rent a warehouse of ASIC and mine on a small chain with 51% attacks are a viable option... if there is an offramp. This attack is usually performed for-profit and results in massive dumping on an exchange as it is occurring. Meaning the attacker will dump tokens on an exchange than \"double-spend\" them back into their wallet. The current exchange situation doesn't provide the liquidity for a viable offramp. The rentable ASIC support isn't an option. So is it possible, in theory, yes, practical or likely? I don't think so at all. Ethereum classic is perhaps a bad example, as it shares the same mining algorithm as Eth. One could buy more than 100% current hash rate of eth classic on NiceHash. It's not the same case for Ergo. Ergo also believes in the 'Good Miner' principle; in the case of Bitcoin - it was a good thing 51% existed. Difficulty Ergo uses the linear least square method over 8 epoch's (each epoch is 1024 blocks x 2 minutes). Autolykos will adjust slowly yes, but it is also helping to prevent from adversarial hopping. Can it be quicker? Having a quicker difficulty readjustment can lead to Timewarp attacks (amongst others). Ergo is already using epoch length of ~1.5 days (with normal block rate), not Bitcoin's 2 weeks. However, more epochs considered, but retargeting function is non-linear also, so may adjust sooner than linear function in certain popular scenarios. Decentralisation While most active conversations today in the space are about wider adoption of the blockchain technology (which often means selling out to Wall St.) and competition with systems like Visa and Mastercard (which often means giving up with Decentralisation or introducing unclear security assumptions in the name of efficiency), there is the obvious need to revisit the roots of the cryptocurrency movement, which are mostly about Decentralisation. Many questions to be answered clear here. Is it okay when 90% of mining power in Bitcoin can gather in one room ? - Is it okay when 2 or 3 mining pools control the majority of hashing power, so can censorship? - Is it okay when almost all the new nodes avoid processing a blockchain from its genesis block? - Is it okay when Proof-of-Work coin developers are doing a hard-fork changing the consensus algorithm to make it GPU-friendly again? - Can we summarize all the issues with Decentralisation? - Can we cover most of the issues with technical means? Decentralisation is about many issues lying in many fields, of technical, social, and hybrid kinds. Researchers and developers are trying to find technical solutions, preferably elegant and efficient. However, for many issues such solutions are not known; thus, social solutions are also needed. Decentralisation of Mining The two biggest concerns about decentralising mining are specialized hardware (such as ASICs) and centralized pools. With ASICs, a big player capable of investing enough money into R&D can get an unfair advantage from privately owned efficient hardware. In principle, for any computational activity, it is always possible to develop specialized hardware performing better than commodity computing units, such and CPUs and GPUs. However, for different computational tasks, R&D efforts and the possible outcome could vary a lot. The reasoning behind a search for a perfect (or close enough to perfect) could be quite complex (see, e.g. 30 pages long Equihash paper ). For most Proof-of-Work cryptocurrencies (including Bitcoin, Ethereum, ZCash), 2 to 4 centralized mining pools control most mining power. This could mean easy censorship or frontrunning on applications (for example, reordering exchange orders), as in centralized pools, only the pool decides block candidate for the whole pool to work on. As a possible outcome, non-outsourceable mining schemes can prevent centralized pools formation. Only Ergo Platform is known for deploying a practical non-outsourceable Proof-of-Work scheme (based on a supposedly memory-harder problem from the Equihash paper ) called Autolykos . As an example where social Decentralisation issues meet the Decentralisation of mining, sometimes developers of Proof-of-Work is introducing hard-forks to make a Proof-of-Work algorithm GPU-friendly again once ASICs are going to dominate in the mining market for the coin; however, it is always not quite clear why legit activity is banned and why developers (along with some users) can do hard-fork for this particular reason. Decentralisation of Verification Decentralisation of verification is about the possibility to check the validity of blockchain history. Such check provides confidence that nothing bad (i.e. not conforming to a protocol) was injected into the blockchain and thus gave a user a right to reject malicious chain even if it has absorbed more work than alternatives. There were many talks about such the right in the Bitcoin community when it was partly hot about User-Activated Soft Fork (UASF) idea, and a recent article \"Who secures Bitcoin?\" is summarizing this way of thinking well. If verification can be done in reasonable time only by an entity able to spend millions on renting a data centre, a network is not decentralized. Ideally, it should be possible to check the integrity of the whole blockchain on commodity hardware, like a decent laptop. However, new blockchains also tend to absorb more and more features, and they are not coming for free. Then the huge topic in the research community is about how to make it possible to check the integrity of the whole blockchain with pruned blocks or system state (or both) under plausible assumptions. Possible solutions here are about bootstrapping state snapshot and blockchain suffix on top of it (popular in Ethereum protocol clients, and formalized in an academic paper even ), stateless clients ( partially stateless , as implemented in Ergo Platform or fully stateless which do exist only in research papers currently).","title":"Autolykos"},{"location":"dev/protocol/autolykos/#autolykos","text":"Security of Proof-of-Work blockchains relies on multiple miners trying to produce new blocks by participating in a PoW puzzle lottery , and the network is secure if the majority of them are honest. However, the reality becomes much more complicated than the original one-CPU-one-vote idea from the Bitcoin whitepaper.","title":"Autolykos"},{"location":"dev/protocol/autolykos/#non-outsourceability","text":"The first threat to Decentralisation came from mining pools \u2013 miners tend to unite in mining pools. Regardless of the PoW algorithm, the number of pools controlling more than 50% of computational power is usually relatively small: 4 pools in Bitcoin, 2 in Ethereum, 3 in ZCash, etc. This problem led to the notion of non-outsourceable puzzles. These are the puzzles constructed in such a way that if a mining pool outsources the puzzle to a miner, the miner can recover the pool's private key and steal the reward with a non-negligible probability. However, the existing solutions either have too large a solution size (kilobyte is already on the edge of acceptability for distributed ledgers) or very specific and can not be modified or extended in any way without breaking non-outsource-ability. The second threat to cryptocurrencies Decentralisation is that ASIC-equipped miners can find PoW solutions orders of magnitude faster and more efficiently than miners equipped with the commodity hardware, to reduce the disparity between the ASICs and regular hardware memory-bound computations were proposed. The most interesting practical examples are two asymmetric memory-hard PoW schemes that require significantly less memory to verify a solution than to find it. Although ASICs already exist for both of them, they remain the only asymmetric memory-hard PoW algorithms in use. Overview of Ergo PoW called Autolykos (2019) Autolykos: The Ergo Platform PoW Puzzle Autolykos v1 originally had non-outsourcability built-in. However, it became apparent that it's impossible to prevent pools with smart contracts, so they turned it off so that not only larger players could take advantage of the loophole. Ergo is now focusing on memory hardness in an attempt to keep mining as fair as possible, which should help prevent ASICs mining at least. There are also some improvements for pooling, e.g. Stratum 2 protocol. \"Bypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts\" https://ia.cr/2020/044 was presented by Alex Chepurnoy at the WTSC workshop associated with Financial Cryptography and Data Security 2020 in Malaysia. It's also discussed here on 'Unblocked with Robert Kornacki' (14:45)","title":"non-outsourceability"},{"location":"dev/protocol/autolykos/#v2","text":"Autolykos version two follows Autolykos v.1, but with certain modifications made: non-outsourceable puzzles were switched off. It turns out (based on more than one year of non-outsourceable PoW experience) that non-outsourceable PoW is not attractive to small miners. Now, the algorithm is trying to bind an efficient solving procedure with a single table of ~2 GB (initially), which is significantly reducing memory optimizations possibilities table size (memory requirements of a solving algorithm) grows with time The table depends solely on the block height, so there is no penalization for recalculating block candidates for the same height Basic Ideas: Like Autlykos-1, based on the k-sum problem, so a miner needs to find k (k=32) out of N (2^n = 2^26) elements, and the hash of their sum must be less than the target value (inverse of the difficulty) k indexes are pseudorandom values derived from block candidate and nonce N elements are derived from block height and constants, unlike Autolykos v.1, so miners can recalculate block candidates quickly now (so only indexes are depending on them) Indexes calculation also involving the same table (which elements are last 31 bytes of H(i | | h | | M ) , where i is in [0, N), h is block height, M is padding to slow down hash calculation (8kb of constant data). So algorithm tries to make mining efficient for ones that store the table, which is 2^26 * 31 = 2,080,374,784 bytes initially (about 2GB). Thus Autolykos is now is friendly to all the GPUs. Also, table size (N value) is growing with time as follows. Until block 614,400 , N = 2^{26} = 67,108,864 elements (31 bytes each) . From this block, and until block 4,198,400 , every 51,200 blocks N is increased by 5 percent. Since block 4,198,400 , value of N is fixed and equals to 2,143,944,600 . Test vectors for N values are provided in the paper. Ergo PoW Bypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts","title":"v.2"},{"location":"dev/protocol/autolykos/#51-attack","text":"Mining pools offer a buffer against such network attacks as the hash rate is distributed across thousands of individual miners. Ergo's memory-hardened aspect also makes this vector of attack more expensive as there is no ASIC support to rent. With the collective rentable rigs at the moment, this isn't a viable path to a 51% attack. In theory, someone could build a massive GPU farm to try to launch such an attack. If a bad actor can rent a warehouse of ASIC and mine on a small chain with 51% attacks are a viable option... if there is an offramp. This attack is usually performed for-profit and results in massive dumping on an exchange as it is occurring. Meaning the attacker will dump tokens on an exchange than \"double-spend\" them back into their wallet. The current exchange situation doesn't provide the liquidity for a viable offramp. The rentable ASIC support isn't an option. So is it possible, in theory, yes, practical or likely? I don't think so at all. Ethereum classic is perhaps a bad example, as it shares the same mining algorithm as Eth. One could buy more than 100% current hash rate of eth classic on NiceHash. It's not the same case for Ergo. Ergo also believes in the 'Good Miner' principle; in the case of Bitcoin - it was a good thing 51% existed.","title":"51% Attack"},{"location":"dev/protocol/autolykos/#difficulty","text":"Ergo uses the linear least square method over 8 epoch's (each epoch is 1024 blocks x 2 minutes). Autolykos will adjust slowly yes, but it is also helping to prevent from adversarial hopping. Can it be quicker? Having a quicker difficulty readjustment can lead to Timewarp attacks (amongst others). Ergo is already using epoch length of ~1.5 days (with normal block rate), not Bitcoin's 2 weeks. However, more epochs considered, but retargeting function is non-linear also, so may adjust sooner than linear function in certain popular scenarios.","title":"Difficulty"},{"location":"dev/protocol/autolykos/#decentralisation","text":"While most active conversations today in the space are about wider adoption of the blockchain technology (which often means selling out to Wall St.) and competition with systems like Visa and Mastercard (which often means giving up with Decentralisation or introducing unclear security assumptions in the name of efficiency), there is the obvious need to revisit the roots of the cryptocurrency movement, which are mostly about Decentralisation. Many questions to be answered clear here. Is it okay when 90% of mining power in Bitcoin can gather in one room ? - Is it okay when 2 or 3 mining pools control the majority of hashing power, so can censorship? - Is it okay when almost all the new nodes avoid processing a blockchain from its genesis block? - Is it okay when Proof-of-Work coin developers are doing a hard-fork changing the consensus algorithm to make it GPU-friendly again? - Can we summarize all the issues with Decentralisation? - Can we cover most of the issues with technical means? Decentralisation is about many issues lying in many fields, of technical, social, and hybrid kinds. Researchers and developers are trying to find technical solutions, preferably elegant and efficient. However, for many issues such solutions are not known; thus, social solutions are also needed.","title":"Decentralisation"},{"location":"dev/protocol/autolykos/#decentralisation-of-mining","text":"The two biggest concerns about decentralising mining are specialized hardware (such as ASICs) and centralized pools. With ASICs, a big player capable of investing enough money into R&D can get an unfair advantage from privately owned efficient hardware. In principle, for any computational activity, it is always possible to develop specialized hardware performing better than commodity computing units, such and CPUs and GPUs. However, for different computational tasks, R&D efforts and the possible outcome could vary a lot. The reasoning behind a search for a perfect (or close enough to perfect) could be quite complex (see, e.g. 30 pages long Equihash paper ). For most Proof-of-Work cryptocurrencies (including Bitcoin, Ethereum, ZCash), 2 to 4 centralized mining pools control most mining power. This could mean easy censorship or frontrunning on applications (for example, reordering exchange orders), as in centralized pools, only the pool decides block candidate for the whole pool to work on. As a possible outcome, non-outsourceable mining schemes can prevent centralized pools formation. Only Ergo Platform is known for deploying a practical non-outsourceable Proof-of-Work scheme (based on a supposedly memory-harder problem from the Equihash paper ) called Autolykos . As an example where social Decentralisation issues meet the Decentralisation of mining, sometimes developers of Proof-of-Work is introducing hard-forks to make a Proof-of-Work algorithm GPU-friendly again once ASICs are going to dominate in the mining market for the coin; however, it is always not quite clear why legit activity is banned and why developers (along with some users) can do hard-fork for this particular reason.","title":"Decentralisation of Mining"},{"location":"dev/protocol/autolykos/#decentralisation-of-verification","text":"Decentralisation of verification is about the possibility to check the validity of blockchain history. Such check provides confidence that nothing bad (i.e. not conforming to a protocol) was injected into the blockchain and thus gave a user a right to reject malicious chain even if it has absorbed more work than alternatives. There were many talks about such the right in the Bitcoin community when it was partly hot about User-Activated Soft Fork (UASF) idea, and a recent article \"Who secures Bitcoin?\" is summarizing this way of thinking well. If verification can be done in reasonable time only by an entity able to spend millions on renting a data centre, a network is not decentralized. Ideally, it should be possible to check the integrity of the whole blockchain on commodity hardware, like a decent laptop. However, new blockchains also tend to absorb more and more features, and they are not coming for free. Then the huge topic in the research community is about how to make it possible to check the integrity of the whole blockchain with pruned blocks or system state (or both) under plausible assumptions. Possible solutions here are about bootstrapping state snapshot and blockchain suffix on top of it (popular in Ethereum protocol clients, and formalized in an academic paper even ), stateless clients ( partially stateless , as implemented in Ergo Platform or fully stateless which do exist only in research papers currently).","title":"Decentralisation of Verification"},{"location":"dev/protocol/nipopow/","text":"NiPoPoWs Ergo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. You can explore this technology in full on nipopows.com . Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) are short stand-alone strings that a computer program can inspect to verify that an event happened on a proof-of-work-based blockchain without connecting to the blockchain network and without downloading all block headers. For example, these proofs can illustrate that a cryptocurrency payment was made. Blocks In Ergo, just like Bitcoin, Ethereum, and other blockchains, blocks are broken into sections. In Bitcoin, there's simply a block header and the transactions themselves. But in Ergo, we have some extra sections that enable new functionality: Header Transactions Extensions Proofs of UTXO transformation The 'extension' section contains certain mandatory fields (including links for NiPoPoW, once per 1,024 block epoch) and parameters for miner voting, such as current block size. It can also contain arbitrary fields. What this means in practice is that different types of nodes and clients can download only those sections of the blocks they need \u2013 reducing the demands for storage, bandwidth, and CPU cycles. Light Full Nodes While miners need to download everything, lite full nodes only need the transactions and proofs. This means they have a cryptographic guarantee of transactions without holding the complete UTXO set itself. Lite full nodes check the proofs generated by full nodes (including miners) who hold the whole blockchain, guaranteeing ledger validity. In Ethereum, these nodes are called Stateless Clients. For Ergo, it means you can run a full node and maintain the network with a device as simple as a Raspberry Pi with 512 MB RAM. This provides the ideal balance between ensuring the network's security and placing an unnecessary burden on users who wish to do so \u2013 improving decentralisation and democratising participation in the Ergo network and community. You might want to run a full node. If you're a miner, this will require that you download the entire blockchain because you'll need the whole UTXO (unspent outputs) set to mine new blocks. But you can still run a full node without that UTXO set \u2013 vastly reducing the specification and expense of the hardware needed. Light Clients Light Clients are essential when considering the hurdles cryptocurrency faces with mass adoption. Most crypto users do not have the necessary tools to run a full node. Running a full node means having a strong processor with high electricity wattage and more than a hundred gigabytes of memory to store the entire blockchain. Light clients are useful because they enable verification with a limited supply of data providers (nodes) and significantly reduce the amount of data storage and bandwidth needed for everyday users. The use of light clients with the implementation of NIPoPoWs makes it possible to interact with the blockchain through block headers by using only a couple of kilobytes. Verifying whether a transaction happened on the blockchain becomes simplified. NIPoPoWs can help people interact with the blockchain by using more efficient and convenient mobile wallets. NIPoPoWs allow very efficient mobile wallets to be created. SPV wallets are already very lightweight compared to full nodes because they only require the download of block headers, not the whole blockchain. NIPoPoW wallets need to download only a small sample of block headers, around 250, when SPV clients need to download half a million block headers. The sample needed changes but doesn't grow much in size as the blockchain grows larger over the years, even after decades of data has been accumulated. This enables Ergo to build a mobile SPV client that requires around just 100KB of block headers to be downloaded. SPV Security There's often tension in the crypto world between security and convenience. That trade-off is unacceptable if we want these technologies to be widely used. Here's how Ergo addresses one common and critical issue.* We all know that the most secure way to use Bitcoin, or any crypto, is to download a copy of the blockchain and run a full node yourself. That way, every time you or anyone else makes a transaction, your client checks the blockchain to ensure it's valid. You don't have to trust anyone else. A full Bitcoin node checks all the blocks in the blockchain (using headers) and makes sure there are no fraudulent transactions. It's a very secure way of using crypto \u2013 but there's a problem. It requires significant bandwidth, storage, and processing power. That kind of commodity hardware is expensive, and using a full node to validate and make transactions is in any case unsuitable for mobile devices. This is particularly true for Bitcoin, where the blockchain is over 270 GB and counting . Simplified Payment Verification (SPV) is designed to address this problem, as described in the Bitcoin white paper : It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it and blocks added after it further confirms the network has accepted it. Satoshi notes that this is not a perfect solution and is vulnerable to an attacker overpowering the network and fooling SPV users. Moreover, while SPV mode is intended for resource-limited devices, even this 'lite' approach is not always feasible. Ethereum's headers alone total around 5 GB to download. Thus Ethereum mobile clients do not validate chain validity and so blindly have to trust third parties. There are proposals to reduce the requirements for SPV mode by checking just a few random headers instead of all of them. But it's hard to do that securely. Efficient SPV Several years have been spent researching and developing secure protocols that allow for efficient SPV clients. The two best-known and most reliable protocols are NiPoPoWs and FlyClient. Ergo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. You can explore this technology in full on this dedicated website: https://nipopows.com : Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) are short stand-alone strings that a computer program can inspect to verify that an event happened on a proof-of-work-based blockchain without connecting to the blockchain network and without downloading all block headers. For example, these proofs can illustrate that a cryptocurrency payment was made. NIPoPoWs allow very efficient mobile wallets to be created. SPV wallets are already very lightweight compared to full nodes because they only require the download of block headers, not the whole blockchain. NIPoPoW wallets need to download only a tiny sample of block headers, around 250 when SPV clients need to download half a million block headers. The sample needed changes but doesn't grow much in size as the blockchain grows more extensive over the years, even after accumulated decades of data. This enables us to build a mobile SPV client that requires around just 100KB of block headers to be downloaded. A super-efficient Ergo wallet with SPV security is in development, so stay tuned for more updates! Log-Space Mining Dionysis Zindros explains the technical landscape of Non-Interactive Proofs of Proof-of-Work. Dionysis takes a diligent approach for the Ergo Cast with a detailed rundown of what Non-Interactive Proofs of Proof-of-Work truly are. Furthermore, Dionysis evaluates the operation, implementation, and impact that his primitive delivers upon. Furthermore, we unveil a brand-new piece of research that -as of yet- has never been shared publicly: log-space mining. NiPoPoWs & Log-Space Mining \u2013 Ergo Cast Episode #5 This section is based on a recently published article by IOHK. For an additional resource, please see the following video. Whether it is Ergo, Bitcoin, or another PoW consensus model, miners must constantly maintain the blockchain. In addition to using computational resources, miners also use storage resources that maintain all blockchain data from the genesis block. A new miner's problem: Is downloading all the data from the genesis block strictly necessary? Why is it not possible to download only the most relevant blocks to maintain the network? The block headers of the blockchain should be enough to access the necessary data. NIPoPoWs (Non-Interactive Proofs of Proof of Work) can be integrated to form interlinked block header sets that will reduce historical data storage. When needing to access key blocks in the blockchain, miners should be able to efficiently do this from the headers of the old blocks. That is because each new block must indicate all of the current networks. As new blocks are created, a set of new block headers can be enough to check for the current UTXO set. Since the new blocks contain the data of old stringed block header sets, it enables light mining by eliminating the need to download all the blockchain data. What are we trying to optimize by stringing old PoW history and compiling it into a snapshot? If we say C=old blocks and K=new blocks, then included blocks in the snapshot can be growing when K=new blocks are constant, and C=old blocks are linear. But it can also be shrinking depending on the smart contract applications. The problem of maintaining heavy loads of data by the miners can be solved by bootstrapping through NIPoPoWs. NIPoPoW Implementation Instead of accessing all of the blocks, superblocks (or light-clients) are enough to verify all of the blocks. This is accomplished by maintaining the historical data of the blockchain through smart contracts. The introduction of these superblock clients on NIPoPoWs can be done via 'velvet' or soft forks, and after that \"light\" miners can bootstrap through \"online\" mining. NIPoPoWs enable smart contracts to maintain historical data so that new \"light\" miners can work in a so-called \"online\" fashion. This is the main idea of Logarithmic Space Mining, where instead of saving all the blockchain data locally on nodes, the unnecessary part of it can be compiled into the blockchain itself. New miners do not need to carry the historical data, and as they continue to mine, new \"light\" miners will help other \"light\" miners bootstrap. There will be no need to carry old historical data, and old miners can abandon historical data for lighter mining. This is how the whole miner population can abandon old blocks and make the system much more efficient. Sidechains Another implementation is cross-chain communication with Proof of Stake networks. PoS networks such as Cardano can interact with Ergo through NIPoPoW integration. Such verification schemes can erase the need for centralized DAO structures and create new non-interactive cross-chain operations. To put it simply, NiPoPoWs act as sidechains. Two or more separate chains can integrate through NiPoPoWs without the need for change in other chains. Such integration would erase the need for, for example, \"Wrapped Tokens,\" tokens that rely on DAO governance. NIPoPoW is a robust tool in creating blockchain networks and provides easier access to clients. They're also helpful in enhancing scalability by creating Layer 2 organizations. Side chains , on the other hand, are a completely different component of blockchain. They are beneficial for various elements such as private chains, scalability improvement, and cross-chain interoperability. Kushti mentioned that he will release a sidechain \"cookbook,\" entitled Ergo-Meta, in the following months. One application of NIPoPoWs that we have described in a previous article deals with logarithmic space mining . Logarithmic space mining allows for \"light miners.\" Similar to light clients, light miners can bootstrap with block headers without downloading the whole blockchain. It is also possible to store just a few necessary blocks to verify the whole blockchain in a blockchain. This essentially eradicates the need for miners to store all of the blockchains. Integrating logarithmic space mining in Ergo is possible via velvet (soft) forks, therefore preventing the need for painful hard forks. Another application of NIPoPoWs was proposed in the first ErgoHack by a team called SmartPools. SmartPools' proposal aims to increase the Nakamoto Coefficient , a metric for calculating the decentralization of the given network. In our case, the proposal aims to increase the decentralization of the Ergo Platform by bootstrapping mining entities with collateralized smart contracts. The purpose here is to provide returns for non-miner investors and prevent big GPU farms from taking control of the system. The most well-known example of NIPoPoWs is the implementation of the second layer blockchain. Second layers are helpful in interacting with different blockchains by increasing scalability and creating private sidechains for enterprise-grade applications. Second layers create blockchains on top of the primary blockchain for different use cases. Because transactions can happen on these second layers without constant synchronous updates, the network load can be lowered substantially by keeping everything on the main chain all the time. The Ergo blockchain has supported NIPoPoWs since its genesis, yet their use cases are still in their infancy. We continue to develop this field of research with our partners at IOHK and EMURGO , and we expect their application to increase with continued contributions from the community developers.","title":"NIPoPoWS"},{"location":"dev/protocol/nipopow/#nipopows","text":"Ergo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. You can explore this technology in full on nipopows.com . Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) are short stand-alone strings that a computer program can inspect to verify that an event happened on a proof-of-work-based blockchain without connecting to the blockchain network and without downloading all block headers. For example, these proofs can illustrate that a cryptocurrency payment was made.","title":"NiPoPoWs"},{"location":"dev/protocol/nipopow/#blocks","text":"In Ergo, just like Bitcoin, Ethereum, and other blockchains, blocks are broken into sections. In Bitcoin, there's simply a block header and the transactions themselves. But in Ergo, we have some extra sections that enable new functionality: Header Transactions Extensions Proofs of UTXO transformation The 'extension' section contains certain mandatory fields (including links for NiPoPoW, once per 1,024 block epoch) and parameters for miner voting, such as current block size. It can also contain arbitrary fields. What this means in practice is that different types of nodes and clients can download only those sections of the blocks they need \u2013 reducing the demands for storage, bandwidth, and CPU cycles.","title":"Blocks"},{"location":"dev/protocol/nipopow/#light-full-nodes","text":"While miners need to download everything, lite full nodes only need the transactions and proofs. This means they have a cryptographic guarantee of transactions without holding the complete UTXO set itself. Lite full nodes check the proofs generated by full nodes (including miners) who hold the whole blockchain, guaranteeing ledger validity. In Ethereum, these nodes are called Stateless Clients. For Ergo, it means you can run a full node and maintain the network with a device as simple as a Raspberry Pi with 512 MB RAM. This provides the ideal balance between ensuring the network's security and placing an unnecessary burden on users who wish to do so \u2013 improving decentralisation and democratising participation in the Ergo network and community. You might want to run a full node. If you're a miner, this will require that you download the entire blockchain because you'll need the whole UTXO (unspent outputs) set to mine new blocks. But you can still run a full node without that UTXO set \u2013 vastly reducing the specification and expense of the hardware needed.","title":"Light Full Nodes"},{"location":"dev/protocol/nipopow/#light-clients","text":"Light Clients are essential when considering the hurdles cryptocurrency faces with mass adoption. Most crypto users do not have the necessary tools to run a full node. Running a full node means having a strong processor with high electricity wattage and more than a hundred gigabytes of memory to store the entire blockchain. Light clients are useful because they enable verification with a limited supply of data providers (nodes) and significantly reduce the amount of data storage and bandwidth needed for everyday users. The use of light clients with the implementation of NIPoPoWs makes it possible to interact with the blockchain through block headers by using only a couple of kilobytes. Verifying whether a transaction happened on the blockchain becomes simplified. NIPoPoWs can help people interact with the blockchain by using more efficient and convenient mobile wallets. NIPoPoWs allow very efficient mobile wallets to be created. SPV wallets are already very lightweight compared to full nodes because they only require the download of block headers, not the whole blockchain. NIPoPoW wallets need to download only a small sample of block headers, around 250, when SPV clients need to download half a million block headers. The sample needed changes but doesn't grow much in size as the blockchain grows larger over the years, even after decades of data has been accumulated. This enables Ergo to build a mobile SPV client that requires around just 100KB of block headers to be downloaded.","title":"Light Clients"},{"location":"dev/protocol/nipopow/#spv-security","text":"There's often tension in the crypto world between security and convenience. That trade-off is unacceptable if we want these technologies to be widely used. Here's how Ergo addresses one common and critical issue.* We all know that the most secure way to use Bitcoin, or any crypto, is to download a copy of the blockchain and run a full node yourself. That way, every time you or anyone else makes a transaction, your client checks the blockchain to ensure it's valid. You don't have to trust anyone else. A full Bitcoin node checks all the blocks in the blockchain (using headers) and makes sure there are no fraudulent transactions. It's a very secure way of using crypto \u2013 but there's a problem. It requires significant bandwidth, storage, and processing power. That kind of commodity hardware is expensive, and using a full node to validate and make transactions is in any case unsuitable for mobile devices. This is particularly true for Bitcoin, where the blockchain is over 270 GB and counting . Simplified Payment Verification (SPV) is designed to address this problem, as described in the Bitcoin white paper : It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it and blocks added after it further confirms the network has accepted it. Satoshi notes that this is not a perfect solution and is vulnerable to an attacker overpowering the network and fooling SPV users. Moreover, while SPV mode is intended for resource-limited devices, even this 'lite' approach is not always feasible. Ethereum's headers alone total around 5 GB to download. Thus Ethereum mobile clients do not validate chain validity and so blindly have to trust third parties. There are proposals to reduce the requirements for SPV mode by checking just a few random headers instead of all of them. But it's hard to do that securely.","title":"SPV Security"},{"location":"dev/protocol/nipopow/#efficient-spv","text":"Several years have been spent researching and developing secure protocols that allow for efficient SPV clients. The two best-known and most reliable protocols are NiPoPoWs and FlyClient. Ergo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. You can explore this technology in full on this dedicated website: https://nipopows.com : Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) are short stand-alone strings that a computer program can inspect to verify that an event happened on a proof-of-work-based blockchain without connecting to the blockchain network and without downloading all block headers. For example, these proofs can illustrate that a cryptocurrency payment was made. NIPoPoWs allow very efficient mobile wallets to be created. SPV wallets are already very lightweight compared to full nodes because they only require the download of block headers, not the whole blockchain. NIPoPoW wallets need to download only a tiny sample of block headers, around 250 when SPV clients need to download half a million block headers. The sample needed changes but doesn't grow much in size as the blockchain grows more extensive over the years, even after accumulated decades of data. This enables us to build a mobile SPV client that requires around just 100KB of block headers to be downloaded. A super-efficient Ergo wallet with SPV security is in development, so stay tuned for more updates!","title":"Efficient SPV"},{"location":"dev/protocol/nipopow/#log-space-mining","text":"Dionysis Zindros explains the technical landscape of Non-Interactive Proofs of Proof-of-Work. Dionysis takes a diligent approach for the Ergo Cast with a detailed rundown of what Non-Interactive Proofs of Proof-of-Work truly are. Furthermore, Dionysis evaluates the operation, implementation, and impact that his primitive delivers upon. Furthermore, we unveil a brand-new piece of research that -as of yet- has never been shared publicly: log-space mining. NiPoPoWs & Log-Space Mining \u2013 Ergo Cast Episode #5 This section is based on a recently published article by IOHK. For an additional resource, please see the following video. Whether it is Ergo, Bitcoin, or another PoW consensus model, miners must constantly maintain the blockchain. In addition to using computational resources, miners also use storage resources that maintain all blockchain data from the genesis block. A new miner's problem: Is downloading all the data from the genesis block strictly necessary? Why is it not possible to download only the most relevant blocks to maintain the network? The block headers of the blockchain should be enough to access the necessary data. NIPoPoWs (Non-Interactive Proofs of Proof of Work) can be integrated to form interlinked block header sets that will reduce historical data storage. When needing to access key blocks in the blockchain, miners should be able to efficiently do this from the headers of the old blocks. That is because each new block must indicate all of the current networks. As new blocks are created, a set of new block headers can be enough to check for the current UTXO set. Since the new blocks contain the data of old stringed block header sets, it enables light mining by eliminating the need to download all the blockchain data. What are we trying to optimize by stringing old PoW history and compiling it into a snapshot? If we say C=old blocks and K=new blocks, then included blocks in the snapshot can be growing when K=new blocks are constant, and C=old blocks are linear. But it can also be shrinking depending on the smart contract applications. The problem of maintaining heavy loads of data by the miners can be solved by bootstrapping through NIPoPoWs. NIPoPoW Implementation Instead of accessing all of the blocks, superblocks (or light-clients) are enough to verify all of the blocks. This is accomplished by maintaining the historical data of the blockchain through smart contracts. The introduction of these superblock clients on NIPoPoWs can be done via 'velvet' or soft forks, and after that \"light\" miners can bootstrap through \"online\" mining. NIPoPoWs enable smart contracts to maintain historical data so that new \"light\" miners can work in a so-called \"online\" fashion. This is the main idea of Logarithmic Space Mining, where instead of saving all the blockchain data locally on nodes, the unnecessary part of it can be compiled into the blockchain itself. New miners do not need to carry the historical data, and as they continue to mine, new \"light\" miners will help other \"light\" miners bootstrap. There will be no need to carry old historical data, and old miners can abandon historical data for lighter mining. This is how the whole miner population can abandon old blocks and make the system much more efficient.","title":"Log-Space Mining"},{"location":"dev/protocol/nipopow/#sidechains","text":"Another implementation is cross-chain communication with Proof of Stake networks. PoS networks such as Cardano can interact with Ergo through NIPoPoW integration. Such verification schemes can erase the need for centralized DAO structures and create new non-interactive cross-chain operations. To put it simply, NiPoPoWs act as sidechains. Two or more separate chains can integrate through NiPoPoWs without the need for change in other chains. Such integration would erase the need for, for example, \"Wrapped Tokens,\" tokens that rely on DAO governance. NIPoPoW is a robust tool in creating blockchain networks and provides easier access to clients. They're also helpful in enhancing scalability by creating Layer 2 organizations. Side chains , on the other hand, are a completely different component of blockchain. They are beneficial for various elements such as private chains, scalability improvement, and cross-chain interoperability. Kushti mentioned that he will release a sidechain \"cookbook,\" entitled Ergo-Meta, in the following months. One application of NIPoPoWs that we have described in a previous article deals with logarithmic space mining . Logarithmic space mining allows for \"light miners.\" Similar to light clients, light miners can bootstrap with block headers without downloading the whole blockchain. It is also possible to store just a few necessary blocks to verify the whole blockchain in a blockchain. This essentially eradicates the need for miners to store all of the blockchains. Integrating logarithmic space mining in Ergo is possible via velvet (soft) forks, therefore preventing the need for painful hard forks. Another application of NIPoPoWs was proposed in the first ErgoHack by a team called SmartPools. SmartPools' proposal aims to increase the Nakamoto Coefficient , a metric for calculating the decentralization of the given network. In our case, the proposal aims to increase the decentralization of the Ergo Platform by bootstrapping mining entities with collateralized smart contracts. The purpose here is to provide returns for non-miner investors and prevent big GPU farms from taking control of the system. The most well-known example of NIPoPoWs is the implementation of the second layer blockchain. Second layers are helpful in interacting with different blockchains by increasing scalability and creating private sidechains for enterprise-grade applications. Second layers create blockchains on top of the primary blockchain for different use cases. Because transactions can happen on these second layers without constant synchronous updates, the network load can be lowered substantially by keeping everything on the main chain all the time. The Ergo blockchain has supported NIPoPoWs since its genesis, yet their use cases are still in their infancy. We continue to develop this field of research with our partners at IOHK and EMURGO , and we expect their application to increase with continued contributions from the community developers.","title":"Sidechains"},{"location":"dev/protocol/rent/","text":"Participate in community discussions around soft-fork! Ergo Emission: details, retargeting via a soft-fork We\u2019ve designed Ergo with long-term economic sustainability in mind, and storage rent is one of the ways we\u2019re ensuring miners stay profitable well into the future. One community member, Robert, describes this function as \u2018on-chain garbage collection\u2019 that reduces the problem of blockchain bloat \u2013 and even makes it profitable. The 2020 block reward reduction will probably be the most important halving Bitcoin ever experiences. This is the point where the narrative of programmatic scarcity and digital gold will truly be proven, in the context of the sharpest economic downturn in living memory. In previous halvings, Bitcoin has still been in its infancy, a niche experiment. Future halvings will confirm the principle. But this one is the watershed. Looking ahead, though, what happens in 20 or 30 years, when block rewards have fallen so far that miners have to rely on tx fees and potentially other sources of revenue? Will Bitcoin be sustainable? What will be the impact on the ecosystem? The simple answer is that we don\u2019t know. Mining rewards are a key feature in maintaining the security of proof-of-work blockchains like Bitcoin and Ergo. And so, while we have deliberately kept many of Bitcoin\u2019s tried and tested features, we have updated this one to give miners a boost when block rewards have fallen to zero. Lost coins Digital scarcity is an important feature of Ergo. Like Bitcoin, ERG are designed to be a finite resource and long-term store of value. We do not agree with the principle of infinite inflation. And yet, this has to be balanced against the needs to pay miners to secure the blockchain and process transactions. Without adequate compensation for miners, there is no viable blockchain at all. Ergo approaches this by slowly recycling lost coins, in a feature we call \u2018Storage rent\u2019. Studies suggest that as many as 4 million BTC may have been lost forever . These are coins that were mined in the early days of Bitcoin and stored on hard drives that were subsequently thrown away or destroyed because the owners forgot about them or thought they were worthless, as well as coins in addresses for which the private keys have been lost. (And, of course, there\u2019s Satoshi\u2019s estimated holdings of 1 million BTC, which may never move.) Where coins have genuinely been permanently taken out of circulation in this way, it makes sense to have a mechanism to recover them and put them back into the blockchain economy. That way, we can preserve digital scarcity without unnecessarily accelerating it. In other words, by attempting to stick to the intended algorithmic supply for any given point in time. Ergo\u2019s halving schedule is faster than Bitcoin\u2019s. Block rewards start at 75 ERG, and decrease steadily after the first two years. There is no \u2018long tail\u2019 of emission, and after eight years block rewards will fall to zero. After that, total supply will be fixed. The number of ERG in existence will never be more than 97,739,925. Storage fees From that point, however, miners will need further incentives to secure the network. Miners have ongoing costs in terms of bandwidth and storage, and in cases where coins are simply left for years, there is typically no charge for reflecting the value of securing them. The tx fee that is paid up-front in Bitcoin is the only charge ever made for storing those coins. In Ergo, in addition to transaction fees, miners will also be able to collect storage rent fees on UTXOs that have not been moved for four years or more. Fees will be deducted slowly, over time \u2013 the unmoved UTXOs will not simply be appropriated by miners. Anyone who wants to avoid this simply needs to move their balances once every four years, which is not an onerous requirement for helping incentivise miners and avoiding the deflationary consequences of lost coins. You can read more about how fees will be levied in this paper . In this way, Ergo seeks to ensure a balance between maintaining digital scarcity, on the one hand, and giving miners long-term incentives to secure the blockchain, on the other \u2013 long past the point where new coins have ceased to be released. Resources Storage rent details","title":"Storage Rent"},{"location":"dev/protocol/rent/#lost-coins","text":"Digital scarcity is an important feature of Ergo. Like Bitcoin, ERG are designed to be a finite resource and long-term store of value. We do not agree with the principle of infinite inflation. And yet, this has to be balanced against the needs to pay miners to secure the blockchain and process transactions. Without adequate compensation for miners, there is no viable blockchain at all. Ergo approaches this by slowly recycling lost coins, in a feature we call \u2018Storage rent\u2019. Studies suggest that as many as 4 million BTC may have been lost forever . These are coins that were mined in the early days of Bitcoin and stored on hard drives that were subsequently thrown away or destroyed because the owners forgot about them or thought they were worthless, as well as coins in addresses for which the private keys have been lost. (And, of course, there\u2019s Satoshi\u2019s estimated holdings of 1 million BTC, which may never move.) Where coins have genuinely been permanently taken out of circulation in this way, it makes sense to have a mechanism to recover them and put them back into the blockchain economy. That way, we can preserve digital scarcity without unnecessarily accelerating it. In other words, by attempting to stick to the intended algorithmic supply for any given point in time. Ergo\u2019s halving schedule is faster than Bitcoin\u2019s. Block rewards start at 75 ERG, and decrease steadily after the first two years. There is no \u2018long tail\u2019 of emission, and after eight years block rewards will fall to zero. After that, total supply will be fixed. The number of ERG in existence will never be more than 97,739,925.","title":"Lost coins"},{"location":"dev/protocol/rent/#storage-fees","text":"From that point, however, miners will need further incentives to secure the network. Miners have ongoing costs in terms of bandwidth and storage, and in cases where coins are simply left for years, there is typically no charge for reflecting the value of securing them. The tx fee that is paid up-front in Bitcoin is the only charge ever made for storing those coins. In Ergo, in addition to transaction fees, miners will also be able to collect storage rent fees on UTXOs that have not been moved for four years or more. Fees will be deducted slowly, over time \u2013 the unmoved UTXOs will not simply be appropriated by miners. Anyone who wants to avoid this simply needs to move their balances once every four years, which is not an onerous requirement for helping incentivise miners and avoiding the deflationary consequences of lost coins. You can read more about how fees will be levied in this paper . In this way, Ergo seeks to ensure a balance between maintaining digital scarcity, on the one hand, and giving miners long-term incentives to secure the blockchain, on the other \u2013 long past the point where new coins have ceased to be released. Resources Storage rent details","title":"Storage fees"},{"location":"dev/protocol/transaction/","text":"Model Transaction As the Ergo ecosystem grows, our community can now enjoy the functions of several of our key dApps. Ergo has a stablecoin protocol where users can mint SigUSD and SigRSV tokens. Ergo Auction House offers the ability to mint NFTs, and ErgoDEX (Beta) allows you to swap tokens and provide liquidity. These are the first unique and complex DeFi dApps on the UTXO model, which Bitcoin pioneered. It has often been debated whether the UTXO model can express rich, smart contracts, much like the Accounts model. That is why Ergo Platform built the ErgoScript language from scratch to progress on Bitcoin's legacy. For an in-depth comparison about UTXO and Accounts models, please read our previous blog post: Ergo: Advancing on Bitcoin As an Ergonaut, you may have experienced some confusion if you have checked the explorer to view your transaction details. The UTXO model is essentially different from the Accounts model via \"boxes\" for data-keeping. In the Accounts model, there is a single account where you receive your coins. In the UTXO model, however, every tx (transaction) creates a new box, and your balance is the sum of all the boxes linked to your addresses. To be clear, your Yoroi private key can consist of more than one box in a single address to hold your coins. As you generate a new address, you will create a secondary box to hold your coins. After it is created, you can send funds to this new address, and your funds will be seen as one with your private key. You can create an infinite number of new boxes to hold your coins. As such, every receiving and spending action will also create an additional unique box. This feature can create misconceptions by the user at first glance. When you make a transaction, the network scans your \"boxes\" to verify if you have your tokens and then initiates the transaction. Things get complex after this point because you can not guess which boxes are going to be spent. Imagine you have three different receiving addresses. You received a couple of coins in each of them, and you want to spend some of your coins. In a Yoroi wallet, you can hold any Ergo native coins such as SigRSV or SigUSD. When you initiate a transaction that accesses the boxes of these coins, you will see that they are taken away and then redeposited. Recently, an Ergonaut raised the following question : \"I just created a Yoroi Nightly wallet. I transferred 31 Erg from my main Yoroi wallet to the Yoroi Nightly wallet. The transaction shows 31 Erg plus a small fee, 0.0011. But it also says +92,000 SigRSV. My balance shows no change in SigRSV. What is the meaning of the +92,000 SigRSV in the transaction?\" Let's take a look at the details of this particular transaction : To make a transaction of '31 ERG`, the wallet selected three of the boxes with ERG: A box containing 0.029595 ERG that was received on 07/19/21 A second box containing 19.76 ERG that was received on 07/19/21 A third box containing 208.26 ERG that was received on 06/09/21 On the left section of the image above, you will see approximately 228 ERG taken, while on the right section, you will see 31 ERG sent and 197 ERG redeposited to your wallet. So your wallet used three of your boxes to spend the desired amount. This action includes all the assets in that box to the transaction. After the desired amount is spent, your funds are simply refunded to your address in a newly created UTXO box or boxes. Therefore, spending any coin in a box means spending the whole box and creating a new UTXO box, which is why you see your tokens are taken away and then redeposited. The selection of which boxes to spend is a secret of the wallet's random selection strategy. Whatever coins are in the selected boxes, be it SigRSV, SigUSD or NFT, will be displayed as per the example. Summary The Accounts model contains a single box, and this box is not spent. It remains the same so that non-related coins will remain unaffected. The UTXO model, on the other hand, contains a set of boxes that represents the total amount of the user's balance and the unspent transaction output has to change with each spending transaction. You may see a long list of tokens when swapping just 5 SigRSV as below: This is how UTXO model Transaction works - its storage is different from the Accounts model. In the UTXO model, coins will be stored in one-use UTXO boxes and not in long-living accounts.","title":"Transaction"},{"location":"dev/protocol/transaction/#model-transaction","text":"As the Ergo ecosystem grows, our community can now enjoy the functions of several of our key dApps. Ergo has a stablecoin protocol where users can mint SigUSD and SigRSV tokens. Ergo Auction House offers the ability to mint NFTs, and ErgoDEX (Beta) allows you to swap tokens and provide liquidity. These are the first unique and complex DeFi dApps on the UTXO model, which Bitcoin pioneered. It has often been debated whether the UTXO model can express rich, smart contracts, much like the Accounts model. That is why Ergo Platform built the ErgoScript language from scratch to progress on Bitcoin's legacy. For an in-depth comparison about UTXO and Accounts models, please read our previous blog post: Ergo: Advancing on Bitcoin As an Ergonaut, you may have experienced some confusion if you have checked the explorer to view your transaction details. The UTXO model is essentially different from the Accounts model via \"boxes\" for data-keeping. In the Accounts model, there is a single account where you receive your coins. In the UTXO model, however, every tx (transaction) creates a new box, and your balance is the sum of all the boxes linked to your addresses. To be clear, your Yoroi private key can consist of more than one box in a single address to hold your coins. As you generate a new address, you will create a secondary box to hold your coins. After it is created, you can send funds to this new address, and your funds will be seen as one with your private key. You can create an infinite number of new boxes to hold your coins. As such, every receiving and spending action will also create an additional unique box. This feature can create misconceptions by the user at first glance. When you make a transaction, the network scans your \"boxes\" to verify if you have your tokens and then initiates the transaction. Things get complex after this point because you can not guess which boxes are going to be spent. Imagine you have three different receiving addresses. You received a couple of coins in each of them, and you want to spend some of your coins. In a Yoroi wallet, you can hold any Ergo native coins such as SigRSV or SigUSD. When you initiate a transaction that accesses the boxes of these coins, you will see that they are taken away and then redeposited. Recently, an Ergonaut raised the following question : \"I just created a Yoroi Nightly wallet. I transferred 31 Erg from my main Yoroi wallet to the Yoroi Nightly wallet. The transaction shows 31 Erg plus a small fee, 0.0011. But it also says +92,000 SigRSV. My balance shows no change in SigRSV. What is the meaning of the +92,000 SigRSV in the transaction?\" Let's take a look at the details of this particular transaction : To make a transaction of '31 ERG`, the wallet selected three of the boxes with ERG: A box containing 0.029595 ERG that was received on 07/19/21 A second box containing 19.76 ERG that was received on 07/19/21 A third box containing 208.26 ERG that was received on 06/09/21 On the left section of the image above, you will see approximately 228 ERG taken, while on the right section, you will see 31 ERG sent and 197 ERG redeposited to your wallet. So your wallet used three of your boxes to spend the desired amount. This action includes all the assets in that box to the transaction. After the desired amount is spent, your funds are simply refunded to your address in a newly created UTXO box or boxes. Therefore, spending any coin in a box means spending the whole box and creating a new UTXO box, which is why you see your tokens are taken away and then redeposited. The selection of which boxes to spend is a secret of the wallet's random selection strategy. Whatever coins are in the selected boxes, be it SigRSV, SigUSD or NFT, will be displayed as per the example.","title":"Model Transaction"},{"location":"dev/protocol/transaction/#summary","text":"The Accounts model contains a single box, and this box is not spent. It remains the same so that non-related coins will remain unaffected. The UTXO model, on the other hand, contains a set of boxes that represents the total amount of the user's balance and the unspent transaction output has to change with each spending transaction. You may see a long list of tokens when swapping just 5 SigRSV as below: This is how UTXO model Transaction works - its storage is different from the Accounts model. In the UTXO model, coins will be stored in one-use UTXO boxes and not in long-living accounts.","title":"Summary"},{"location":"dev/protocol/utxo-state/","text":"","title":"UTXO State"},{"location":"dev/scs/crowdfunding/","text":"What is Crowdfunding? Crowdfunding is a way of raising capital through the collective efforts of individuals. The campaigns are mostly started via the world wide web and allow projects and businesses to be funded by raising small amounts of money from a large number of people. One of the best known examples for successful crowdfunding startups is Oculus Rift, a virtual reality headset. The company Oculus VR initiated its campaign in 2012 and was only two years later acquired by Facebook for $2 billion total. Besides the usual startups, there are also a lot of blockchain projects which went the way of crowdfunding, for example, Ethereum, Tron and EOS. Today, numerous platforms exist that allow you to publish your campaign. Some of the bigger ones are Indiegogo, Kickstarter, and Gofundme, only to name a few. Crowdfunding has a lot of benefits: a wide reach, efficiency, and marketing aspects being the most convincing... But for now, let's get onto what's really important! Introducing Crowdfunding on Ergo A few days ago, on August 28th, core developer Kushti stated on the (Ergo forum)[www.ergoforum.org] that he managed to successfully write and implement code that allows users to start a crowdfunding campaign on top of the Ergo blockchain (as mentioned in the whitepaper page 6 . This code even works with the current wallet API. Here is a quick guide on how to set up the wallet. In this article, you will learn how to do exactly that: crowdfunding on top of Ergo! It also takes you through the proposal of the first campaign ever, which is to fund the post-EIP1 crowdfunding script development. If you want to go into all the details, please read the following section, \u201cThe Script\u201d. Otherwise, you can simply skip to reading the \u201cHow To Donate\u201d, \"How To Collect Donations\", and \u201cCrowdfunding Project Proposal\u201d sections below that. The Script The simplest crowdfunding script, according to the ErgoScript White Paper (page 6) , is \u201ca script for the following crowdfunding situation: a project backer (with key backerPubKey) wishes to give money to a project (with key projectPubKey), but only if the project raises enough money (at least minToRaise) from other sources by a deadline (expressed in terms of HEIGHT). To give money to the project, the backer will create an output box protected by the following script. The script contains two conditions: one for the case the deadline has passed (enabling the backer to get the money back) and one for the case it succeeded (enabling the project to spend the money if the amount is at least minToRaise before the deadline). In order to ensure enough money has been raised, the script will search the output collection for a box with a sufficient value going to the projectPubKey. To check where the value of the output box is going, the script will read the script protecting the output box and compare it to the script corresponding to proveDlog(projectPubKey); this script can be obtained byprojectPubKey.propBytes. As currently the API does not support embedding of custom environment variables (only predefined ones like HEIGHT), the only way to compile the script is to replace such variables in the script from the white-paper with concrete values. For example, consider that a crowdfunding campaign is successful if it is raising 500 Ergs before block number 50,000. For backerPubKey and projectPubKey we can use PK() function which accepts only P2PK serialized keys at the moment. Then the modified script from the WhitePaper becomes the following: { val backerPubKey = PK(\"9h7DHKSDgE4uvP8313GVGdsEg3AvdAWSSTG7XZsLwBfeth4aePG\") val projectPubKey = PK(\"9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\") val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT >= deadline && backerPubKey val enoughRaised = {(outBox: Box) =>outBox.value >= minToRaise && outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT < deadline && projectPubKey && OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess } How to Donate First of all, JSON is not supporting multi-line strings, so you need to replace line breaks with \\n . Also, quotes are to be escaped, so use \" instead of \". The resulting JSON will be sent to /script/p2sAddress . To donate to a project, first get your address from /wallet/addresses, take e.g. the first of them. Put the address into the backerPubKey, so a request to /script/p2sAddress will look like the following after this step: { \"source\": \"{ val backerPubKey = PK(\\\"9...\\\") val projectPubKey = PK(\\\"9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\\\") val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT >= deadline && backerPubKey val enoughRaised = { (outBox: Box) => outBox.value >= minToRaise && outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT < deadline && projectPubKey && OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess }\" } with your address instead of \u201c9\u2026\u201d. Send the string to /script/p2sAddress to get a response like: { \"address\": \"GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\" } Copy address string (GB3\u2026 in our example) and send the money to it via /wallet/payment/send . A request to the API method to send 10 Ergs (10 Billion nanoErgs) will be like following: [ { \"address\": \"GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\", \"value\": 10000000000 } ] That\u2019s all! Now the wallet will automatically find the box on the blockchain, as it contains the public key which belongs to the wallet in the refund condition. The wallet then periodically checks whether the box is spendable by constructing a simplest transaction with the box as an input and just one output (to the same address). After refund height (50,000 in our example) the wallet will be able to spend the box and so the box value will be added to /wallet/balances. Please note that this will not be the case after EIP-1 3 implementation as the wallet will use narrow recognition patterns by then. How to Collect Donations The wallet which is associated with the project public key will find incoming boxes on the blockchain. However, it will fail to make sure that boxes are spendable, as the wallet currently is using a simplest transaction for that, and the script is failing for such a spending transaction. Before /wallet/boxes/uncertain method being implemented, the only way for a project to find incoming boxes. Then /wallet/transaction/send with manually provided (in \u201cinputsRaw\u201d) serialized boxes (use /utxo/byIdBinary to get the serialized box by its identifier). Kushti did that by himself and got the following transaction . Please note that EIP-1 will break this workflow as well. Kushti proposes to raise 500 Ergs before block 50,000 to develop command-line scripts (in Python) for organizing and participating in crowdfunding campaigns after EIP-1 implementation. Command-line scripts are more suitable than doing requests manually and also could be used for building graphic interfaces on top of them. The treasury did provide half of the funds , so others need to contribute the missing 250 Erg collectively. In case of a campaign failure refunds will be given automatically. As collecting pledges is not trivial at the moment, Kushti will lead the project role, so please use the following key, which is controlled by him: 9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq In order to donate any amount of money, please follow the \u201cHow To Donate\u201d section above with replacing backerPubKey with your public key, and pledge amount with a proper value (please note that it is in nanoErgs, 1 Erg = 1.000.000.000 nanoErgs ).","title":"CrowdFunding"},{"location":"dev/scs/crowdfunding/#what-is-crowdfunding","text":"Crowdfunding is a way of raising capital through the collective efforts of individuals. The campaigns are mostly started via the world wide web and allow projects and businesses to be funded by raising small amounts of money from a large number of people. One of the best known examples for successful crowdfunding startups is Oculus Rift, a virtual reality headset. The company Oculus VR initiated its campaign in 2012 and was only two years later acquired by Facebook for $2 billion total. Besides the usual startups, there are also a lot of blockchain projects which went the way of crowdfunding, for example, Ethereum, Tron and EOS. Today, numerous platforms exist that allow you to publish your campaign. Some of the bigger ones are Indiegogo, Kickstarter, and Gofundme, only to name a few. Crowdfunding has a lot of benefits: a wide reach, efficiency, and marketing aspects being the most convincing... But for now, let's get onto what's really important!","title":"What is Crowdfunding?"},{"location":"dev/scs/crowdfunding/#introducing-crowdfunding-on-ergo","text":"A few days ago, on August 28th, core developer Kushti stated on the (Ergo forum)[www.ergoforum.org] that he managed to successfully write and implement code that allows users to start a crowdfunding campaign on top of the Ergo blockchain (as mentioned in the whitepaper page 6 . This code even works with the current wallet API. Here is a quick guide on how to set up the wallet. In this article, you will learn how to do exactly that: crowdfunding on top of Ergo! It also takes you through the proposal of the first campaign ever, which is to fund the post-EIP1 crowdfunding script development. If you want to go into all the details, please read the following section, \u201cThe Script\u201d. Otherwise, you can simply skip to reading the \u201cHow To Donate\u201d, \"How To Collect Donations\", and \u201cCrowdfunding Project Proposal\u201d sections below that.","title":"Introducing Crowdfunding on Ergo"},{"location":"dev/scs/crowdfunding/#the-script","text":"The simplest crowdfunding script, according to the ErgoScript White Paper (page 6) , is \u201ca script for the following crowdfunding situation: a project backer (with key backerPubKey) wishes to give money to a project (with key projectPubKey), but only if the project raises enough money (at least minToRaise) from other sources by a deadline (expressed in terms of HEIGHT). To give money to the project, the backer will create an output box protected by the following script. The script contains two conditions: one for the case the deadline has passed (enabling the backer to get the money back) and one for the case it succeeded (enabling the project to spend the money if the amount is at least minToRaise before the deadline). In order to ensure enough money has been raised, the script will search the output collection for a box with a sufficient value going to the projectPubKey. To check where the value of the output box is going, the script will read the script protecting the output box and compare it to the script corresponding to proveDlog(projectPubKey); this script can be obtained byprojectPubKey.propBytes. As currently the API does not support embedding of custom environment variables (only predefined ones like HEIGHT), the only way to compile the script is to replace such variables in the script from the white-paper with concrete values. For example, consider that a crowdfunding campaign is successful if it is raising 500 Ergs before block number 50,000. For backerPubKey and projectPubKey we can use PK() function which accepts only P2PK serialized keys at the moment. Then the modified script from the WhitePaper becomes the following: { val backerPubKey = PK(\"9h7DHKSDgE4uvP8313GVGdsEg3AvdAWSSTG7XZsLwBfeth4aePG\") val projectPubKey = PK(\"9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\") val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT >= deadline && backerPubKey val enoughRaised = {(outBox: Box) =>outBox.value >= minToRaise && outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT < deadline && projectPubKey && OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess }","title":"The Script"},{"location":"dev/scs/crowdfunding/#how-to-donate","text":"First of all, JSON is not supporting multi-line strings, so you need to replace line breaks with \\n . Also, quotes are to be escaped, so use \" instead of \". The resulting JSON will be sent to /script/p2sAddress . To donate to a project, first get your address from /wallet/addresses, take e.g. the first of them. Put the address into the backerPubKey, so a request to /script/p2sAddress will look like the following after this step: { \"source\": \"{ val backerPubKey = PK(\\\"9...\\\") val projectPubKey = PK(\\\"9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\\\") val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT >= deadline && backerPubKey val enoughRaised = { (outBox: Box) => outBox.value >= minToRaise && outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT < deadline && projectPubKey && OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess }\" } with your address instead of \u201c9\u2026\u201d. Send the string to /script/p2sAddress to get a response like: { \"address\": \"GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\" } Copy address string (GB3\u2026 in our example) and send the money to it via /wallet/payment/send . A request to the API method to send 10 Ergs (10 Billion nanoErgs) will be like following: [ { \"address\": \"GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\", \"value\": 10000000000 } ] That\u2019s all! Now the wallet will automatically find the box on the blockchain, as it contains the public key which belongs to the wallet in the refund condition. The wallet then periodically checks whether the box is spendable by constructing a simplest transaction with the box as an input and just one output (to the same address). After refund height (50,000 in our example) the wallet will be able to spend the box and so the box value will be added to /wallet/balances. Please note that this will not be the case after EIP-1 3 implementation as the wallet will use narrow recognition patterns by then.","title":"How to Donate"},{"location":"dev/scs/crowdfunding/#how-to-collect-donations","text":"The wallet which is associated with the project public key will find incoming boxes on the blockchain. However, it will fail to make sure that boxes are spendable, as the wallet currently is using a simplest transaction for that, and the script is failing for such a spending transaction. Before /wallet/boxes/uncertain method being implemented, the only way for a project to find incoming boxes. Then /wallet/transaction/send with manually provided (in \u201cinputsRaw\u201d) serialized boxes (use /utxo/byIdBinary to get the serialized box by its identifier). Kushti did that by himself and got the following transaction . Please note that EIP-1 will break this workflow as well. Kushti proposes to raise 500 Ergs before block 50,000 to develop command-line scripts (in Python) for organizing and participating in crowdfunding campaigns after EIP-1 implementation. Command-line scripts are more suitable than doing requests manually and also could be used for building graphic interfaces on top of them. The treasury did provide half of the funds , so others need to contribute the missing 250 Erg collectively. In case of a campaign failure refunds will be given automatically. As collecting pledges is not trivial at the moment, Kushti will lead the project role, so please use the following key, which is controlled by him: 9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq In order to donate any amount of money, please follow the \u201cHow To Donate\u201d section above with replacing backerPubKey with your public key, and pledge amount with a proper value (please note that it is in nanoErgs, 1 Erg = 1.000.000.000 nanoErgs ).","title":"How to Collect Donations"},{"location":"dev/scs/ergoscript/","text":"ErgoScript Ergo Blockchain is a financial smart contract platform that is built on the UTXO model. Its language, \u201cErgoScript,\u201d is a rich language that supports Multi-Stage Contracts based on Scala. Even if you don\u2019t know Scala, you can get used to it easily by checking ErgoScript (or ErgoTree directly) to understand the logic behind it. To begin, take a look at the tutorials. There you can see the ErgoScript overview and application ideas using ErgoScript. Once you get an idea of the extended UTXO model and programming on top of Ergo, check ErgoScript on the right and download the latest library. After checking ErgoTree, the ErgoScript Whitepaper, ErgoScript Tutorials and downloading the latest library, you can start trying for yourself. As a simple example, the below script allows only Alice to spend a box before a certain height and only Bob to spend the box after that. if (HEIGHT < 100000) alicePubKey else bobPubKey The scripting language in itself is non-Turing complete, but applications run on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper . Proxy Contracts Outsourcing transaction generation to an external service/dApp can be useful or even needed in various circumstances. For example, avoiding wallet limitations to generate any transaction on behalf of the user - Ergo Assembler is designed for this purpose. Another example is to scale dApps to be able to fulfill many requests without double-spending or data invalidation - SigmaUSD dApp can use proxy contracts to avoid bank double-spending and ERG/USD oracle data invalidation. EIP-0017 Learn Tutorials (Video) Learn ErgoScript By Example Via The Ergo Playground with Robert Kornacki Advanced ErgoScript Tutorial ErgoScript tutorial How-to Guides Explanations ErgoScript Design patterns SigmaState Protocols References A Quick Primer on ErgoScript ErgoScript Language Description FlowCards A Declarative Framework for Development of Ergo dApps","title":"ErgoScript"},{"location":"dev/scs/ergoscript/#ergoscript","text":"Ergo Blockchain is a financial smart contract platform that is built on the UTXO model. Its language, \u201cErgoScript,\u201d is a rich language that supports Multi-Stage Contracts based on Scala. Even if you don\u2019t know Scala, you can get used to it easily by checking ErgoScript (or ErgoTree directly) to understand the logic behind it. To begin, take a look at the tutorials. There you can see the ErgoScript overview and application ideas using ErgoScript. Once you get an idea of the extended UTXO model and programming on top of Ergo, check ErgoScript on the right and download the latest library. After checking ErgoTree, the ErgoScript Whitepaper, ErgoScript Tutorials and downloading the latest library, you can start trying for yourself. As a simple example, the below script allows only Alice to spend a box before a certain height and only Bob to spend the box after that. if (HEIGHT < 100000) alicePubKey else bobPubKey The scripting language in itself is non-Turing complete, but applications run on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper .","title":"ErgoScript"},{"location":"dev/scs/ergoscript/#proxy-contracts","text":"Outsourcing transaction generation to an external service/dApp can be useful or even needed in various circumstances. For example, avoiding wallet limitations to generate any transaction on behalf of the user - Ergo Assembler is designed for this purpose. Another example is to scale dApps to be able to fulfill many requests without double-spending or data invalidation - SigmaUSD dApp can use proxy contracts to avoid bank double-spending and ERG/USD oracle data invalidation. EIP-0017","title":"Proxy Contracts"},{"location":"dev/scs/ergoscript/#learn","text":"","title":"Learn"},{"location":"dev/scs/ergoscript/#tutorials","text":"(Video) Learn ErgoScript By Example Via The Ergo Playground with Robert Kornacki Advanced ErgoScript Tutorial ErgoScript tutorial","title":"Tutorials"},{"location":"dev/scs/ergoscript/#how-to-guides","text":"","title":"How-to Guides"},{"location":"dev/scs/ergoscript/#explanations","text":"ErgoScript Design patterns SigmaState Protocols","title":"Explanations"},{"location":"dev/scs/ergoscript/#references","text":"A Quick Primer on ErgoScript ErgoScript Language Description","title":"References"},{"location":"dev/scs/ergoscript/#flowcards","text":"A Declarative Framework for Development of Ergo dApps","title":"FlowCards"},{"location":"dev/scs/flowcards/","text":"With thanks to Robert Kornacki for polishing of the draft. Introduction ErgoScript is the smart contract language used by the Ergo blockchain. While it has concise syntax adopted from Scala/Kotlin, it still may seem confusing at first because conceptually ErgoScript is quite different compared to conventional languages which we all know and love. This is because Ergo is a UTXO based blockchain, whereas smart contracts are traditionally associated with account based systems like Ethereum. However, Ergo's transaction model has many advantages over the account based model and with the right approach it can even be significantly easier to develop Ergo contracts than to write and debug Solidity code. Below we will cover the key aspects of the Ergo contract model which makes it different: Paradigm The account model of Ethereum is imperative. This means that the typical task of sending coins from Alice to Bob requires changing the balances in storage as a series of operations. Ergo's UTXO based programming model on the other hand is declarative. ErgoScript contracts specify conditions for a transaction to be accepted by the blockchain (not changes to be made in the storage state as result of the contract execution). Scalability In the account model of Ethereum both storage changes and validity checks are performed on-chain during code execution. In contrast, Ergo transactions are created off-chain and only validation checks are performed on-chain thus reducing the amount of operations performed by every node on the network. In addition, due to immutability of the transaction graph, various optimization strategies are possible to improve throughput of transactions per second in the network. Light verifying nodes are also possible thus further facilitating scalability and accessibility of the network. Shared state The account-based model is reliant on shared mutable state which is known to lead to complex semantics (and subtle million dollar bugs) in the context of concurrent/ distributed computation. Ergo's model is based on an immutable graph of transactions. This approach, inherited from Bitcoin, plays well with the concurrent and distributed nature of blockchains and facilitates light trustless clients. Expressive Power Ethereum advocated execution of a turing-complete language on the blockchain. It theoretically promised unlimited potential, however in practice severe limitations came to light from excessive blockchain bloat, subtle multi-million dollar bugs, gas costs which limit contract complexity, and other such problems. Ergo on the flip side extends UTXO to enable turing-completeness while limiting the complexity of the ErgoScript language itself. The same expressive power is achieved in a different and more semantically sound way. With the all of the above points, it should be clear that there are a lot of benefits to the model Ergo is using. In the rest of this article I will introduce you to the concept of FlowCards - a dApp developer component which allows for designing complex Ergo contracts in a declarative and visual way. From Imperative to Declarative In the imperative programming model of Ethereum a transaction is a sequence of operations executed by the Ethereum VM. The following Solidity function implements a transfer of tokens from sender to receiver . The transaction starts when sender calls this function on an instance of a contract and ends when the function returns. // Sends an amount of existing coins from any caller to an address function send(address receiver, uint amount) public { require(amount <= balances[msg.sender], \"Insufficient balance.\"); balances[msg.sender] -= amount; balances[receiver] += amount; emit Sent(msg.sender, receiver, amount); } The function first checks the pre-conditions, then updates the storage (i.e. balances) and finally publishes the post-condition as the Sent event. The gas which is consumed by the transaction is sent to the miner as a reward for executing this transaction. Unlike Ethereum, a transaction in Ergo is a data structure holding a list of input coins which it spends and a list of output coins which it creates preserving the total balances of ERGs and tokens (in which Ergo is similar to Bitcoin). Turning back to the example above, since Ergo natively supports tokens, therefore for this specific example of sending tokens we don't need to write any code in ErgoScript. Instead we need to create the 'send' transaction shown in the following figure, which describes the same token transfer but declaratively. The picture visually describes the following steps, which the network user needs to perform: 1) Select unspent sender's boxes, containing in total tB >= amount of tokens and B >= txFee + minErg ERGs. 2) Create an output target box which is protected by the receiver public key with minErg ERGs and amount of T tokens. 3) Create one fee output protected by the minerFee contract with txFee ERGs. 4) Create one change output protected by the sender public key, containing B - minErg - txFee ERGs and tB - amount of T tokens. 5) Create a new transaction, sign it using the sender's secret key and send to the Ergo network. What is important to understand here is that all of these steps are preformed off-chain (for example using Appkit Transaction API) by the user's application. Ergo network nodes don't need to repeat this transaction creation process, they only need to validate the already formed transaction. ErgoScript contracts are stored in the inputs of the transaction and check spending conditions. The node executes the contracts on-chain when the transaction is validated. The transaction is valid if all of the conditions are satisfied. Thus, in Ethereum when we \"send amount from sender to recipient\" we are literally editing balances and updating the storage with a concrete set of commands. This happens on-chain and thus a new transaction is also created on-chain as the result of this process. In Ergo (as in Bitcoin) transactions are created off-chain and the network nodes only verify them. The effects of the transaction on the blockchain state is that input coins (or Boxes in Ergo's parlance) are removed and output boxes are added to the UTXO set. In the example above we don't use an ErgoScript contract but instead assume a signature check is used as the spending pre-condition. However in more complex application scenarios we of course need to use ErgoScript which is what we are going to discuss next. From Changing State to Checking Context In the send function example we first checked the pre-condition ( require(amount <= balances[msg.sender],...) ) and then changed the state (i.e. update balances balances[msg.sender] -= amount ). This is typical in Ethereum transactions. Before we change anything we need to check if it is valid to do so. In Ergo, as we discussed previously, the state (i.e. UTXO set of boxes) is changed implicitly when a valid transaction is included in a block. Thus we only need to check the pre-conditions before the transaction can be added to the block. This is what ErgoScript contracts do. It is not possible to \"change the state\" in ErgoScript because it is a language to check pre-conditions for spending coins. ErgoScript is a purely functional language without side effects that operates on immutable data values. This means all the inputs, outputs and other transaction parameters available in a script are immutable. This, among other things, makes ErgoScript a very simple language that is easy to learn and safe to use. Similar to Bitcoin, each input box contains a script, which should return the true value in order to 1) allow spending of the box (i.e. removing from the UTXO set) and 2) adding the transaction to the block. If we are being pedantic, it is therefore incorrect (strictly speaking) to think of ErgoScript as the language of Ergo contracts, because it is the language of propositions (logical predicates, formulas, etc.) which protect boxes from \"illegal\" spending. Unlike Bitcoin, in Ergo the whole transaction and a part of the current blockchain context is available to every script. Therefore each script may check which outputs are created by the transaction, their ERG and token amounts (we will use this capability in our example DEX contracts), current block number etc. In ErgoScript you define the conditions of whether changes (i.e. coin spending) are allowed to happen in a given context. This is in contrast to programming the changes imperatively in the code of a contract. While Ergo's transaction model unlocks a whole range of applications like (DEX, DeFi Apps, LETS, etc), designing contracts as pre-conditions for coin spending (or guarding scripts) directly is not intuitive. In the next sections we will consider a useful graphical notation to design contracts declaratively using FlowCard Diagrams , which is a visual representation of executable components (FlowCards). FlowCards aim to radically simplify dApp development on the Ergo platform by providing a high-level declarative language, execution runtime, storage format and a graphical notation . We will start with a high level of diagrams and go down to FlowCard specification. FlowCard Diagrams The idea behind FlowCard diagrams is based on the following observations: 1) An Ergo box is immutable and can only be spent in the transaction which uses it as an input. 2) We therefore can draw a flow of boxes through transactions, so that boxes flowing in to the transaction are spent and those flowing out are created and added to the UTXO. 3) A transaction from this perspective is simply a transformer of old boxes to the new ones preserving the balances of ERGs and tokens involved. The following figure shows the main elements of the Ergo transaction we've already seen previously (now under the name of FlowCard Diagram). There is a strictly defined meaning (semantics) behind every element of the diagram , so that the diagram is a visual representation (or a view) of the underlying executable component (called FlowCard). The FlowCard can be used as a reusable component of an Ergo dApp to create and initiate the transaction on the Ergo blockchain. We will discuss this in the coming sections. Now let's look at the individual pieces of the FlowCard diagram one by one. 1. Name and Parameters Each flow card is given a name and a list of typed parameters. This is similar to a template with parameters. In the above figure we can see the Send flow card which has five parameters. The parameters are used in the specification. 2. Contract Wallet This is a key element of the flow card. Every box has a guarding script. Often it is the script that checks a signature against a public key. This script is trivial in ErgoScript and is defined like the def pk(pubkey: Address) = { pubkey } template where pubkey is a parameter of the type Address . In the figure, the script template is applied to the parameter pk(sender) and thus a concrete wallet contract is obtained. Therefore pk(sender) and pk(receiver) yield different scripts and represent different wallets on the diagram, even though they use the same template. Contract Wallet contains a set of all UTXO boxes which have a given script derived from the given script template using flow card parameters. For example, in the figure, the template is pk and parameter pubkey is substituted with the `sender' flow card parameter. 3. Contract Even though a contract is a property of a box, on the diagram we group the boxes by their contracts, therefore it looks like the boxes belong to the contracts, rather than the contracts belong to the boxes. In the example, we have three instantiated contracts pk(sender) , pk(receiver) and minerFee . Note, that pk(sender) is the instantiation of the pk template with the concrete parameter sender and minerFee is the instantiation of the pre-defined contract which protects the miner reward boxes. 4. Box name In the diagram we can give each box a name. Besides readability of the diagram, we also use the name as a synonym of a more complex indexed access to the box in the contract. For example, change is the name of the box, which can also be used in the ErgoScript conditions instead of OUTPUTS(2) . We also use box names to associate spending conditions with the boxes. 5. Boxes in the wallet In the diagram, we show boxes (darker rectangles) as belonging to the contract wallets (lighter rectangles). Each such box rectangle is connected with a grey transaction rectangle by either orange or green arrows or both. An output box (with an incoming green arrow) may include many lines of text where each line specifies a condition which should be checked as part of the transaction. The first line specifies the condition on the amount of ERG which should be placed in the box. Other lines may take one of the following forms: 1) amount: TOKEN - the box should contain the given amount of the given TOKEN 2) R == value - the box should contain the given value of the given register R 3) boxName ? condition - the box named boxName should check condition in its script. We discuss these conditions in the sections below. 6. Amount of ERGs in the box Each box should store a minimum amount of ERGs. This is checked when the creating transaction is validated. In the diagram the amount of ERGs is always shown as the first line (e.g. B: ERG or B - minErg - txFee ). The value type ascription B: ERG is optional and may be used for readability. When the value is given as a formula, then this formula should be respected by the transaction which creates the box. It is important to understand that variables like amount and txFee are not named properties of the boxes. They are parameters of the whole diagram and representing some amounts. Or put it another way, they are shared parameters between transactions (e.g. Sell Order and Swap transactions from DEX example below share the tAmt parameter). So the same name is tied to the same value throughout the diagram (this is where the tooling would help a lot). However, when it comes to on-chain validation of those values, only explicit conditions which are marked with ? are transformed to ErgoScript. At the same time, all other conditions are ensured off-chain during transaction building (for example in an application using Appkit API) and transaction validation when it is added to the blockchain. 7. Amount of T token A box can store values of many tokens. The tokens on the diagram are named and a value variable may be associated with the token T using value: T expression. The value may be given by formula. If the formula is prefixed with a box name like boxName ? formula , then it is should also be checked in the guarding script of the boxName box. This additional specification is very convenient because 1) it allows to validate the visual design automatically, and 2) the conditions specified in the boxes of a diagram are enough to synthesize the necessary guarding scripts. (more about this below at \"From Diagrams To ErgoScript Contracts\" ) 8. Tx Inputs Inputs are connected to the corresponding transaction by orange arrows. An input arrow may have a label of the following forms: 1) name@index - optional name with an index i.e. fee@0 or @2 . This is a property of the target endpoint of the arrow. The name is used in conditions of related boxes and the index is the position of the corresponding box in the INPUTS collection of the transaction. 2) !action - is a property of the source of the arrow and gives a name for an alternative spending path of the box (we will see this in DEX example) Because of alternative spending paths, a box may have many outgoing orange arrows, in which case they should be labeled with different actions. 9. Transaction A transaction spends input boxes and creates output boxes. The input boxes are given by the orange arrows and the labels are expected to put inputs at the right indexes in INPUTS collection. The output boxes are given by the green arrows. Each transaction should preserve a strict balance of ERG values (sum of inputs == sum of outputs) and for each token the sum of inputs >= the sum of outputs. The design diagram requires an explicit specification of the ERG and token values for all of the output boxes to avoid implicit errors and ensure better readability. 10. Tx Outputs Outputs are connected to the corresponding transaction by green arrows. An output arrow may have a label of the following form name@index , where an optional name is accompanied with an index i.e. fee@0 or @2 . This is a property of the source endpoint of the arrow. The name is used in conditions of the related boxes and the index is the position of the corresponding box in the OUTPUTS collection of the transaction. Example: Decentralized Exchange (DEX) Now let's use the above described notation to design a FlowCard for a DEX dApp. It is simple enough yet also illustrates all of the key features of FlowCard diagrams which we've introduced in the previous section. The dApp scenario is shown in the figure below: There are three participants (buyer, seller and DEX) of the DEX dApp and five different transaction types, which are created by participants. The buyer wants to swap ergAmt of ERGs for tAmt of TID tokens (or vice versa, the seller wants to sell TID tokens for ERGs, who sends the order first doesn't matter). Both the buyer and the seller can cancel their orders any time. The DEX off-chain matching service can find matching orders and create the Swap transaction to complete the exchange. The following diagram fully (and formally) specifies all of the five transactions that must be created off-chain by the DEX dApp. It also specifies all of the spending conditions that should be verified on-chain . Let's discuss the FlowCard diagram and the logic of each transaction in details: Buy Order Transaction A buyer creates a Buy Order transaction. The transaction spends E amount of ERGs (which we will write E: ERG ) from one or more boxes in the pk(buyer) wallet. The transaction creates a bid box with ergAmt: ERG protected by the buyOrder script. The buyOrder script is synthesized from the specification (see below at \"From Diagrams To ErgoScript Contracts\" ) either manually or automatically by a tool. Even though we don't need to define the buyOrder script explicitly during designing, at run time the bid box should contain the buyOrder script as the guarding proposition (which checks the box spending conditions), otherwise the conditions specified in the diagram will not be checked. The change box is created to make the input and output sums of the transaction balanced. The transaction fee box is omitted because it can be added automatically by the tools. In practice, however, the designer can add the fee box explicitly to the a diagram. It covers the cases of more complex transactions (like Swap) where there are many ways to pay the transaction fee. Cancel Buy, Cancel Sell Transactions At any time, the buyer can cancel the order by sending CancelBuy transaction. The transaction should satisfy the guarding buyOrder contract which protects the bid box. As you can see on the diagram, both the Cancel and the Swap transactions can spend the bid box. When a box has spending alternatives (or spending paths ) then each alternative is identified by a unique name prefixed with ! ( !cancel and !swap for the bid box). Each alternative path has specific spending conditions. In our example, when the Cancel Buy transaction spends the bid box the ?buyer condition should be satisfied, which we read as \"the signature for the buyer address should be presented in the transaction\". Therefore, only buyer can cancel the buy order. This \"signature\" condition is only required for the !cancel alternative spending path and not required for !swap . Sell Order Transaction The Sell Order transaction is similar to the BuyOrder in that it deals with tokens in addition to ERGs. The transaction spends E: ERG and T: TID tokens from seller's wallet (specified as pk(seller) contract). The two outputs are ask and change . The change is a standard box to balance transaction. The ask box keeps tAmt: TID tokens for the exchange and minErg: ERG - the minimum amount of ERGs required in every box. Swap Transaction This is a key transaction in the DEX dApp scenario. The transaction has several spending conditions on the input boxes and those conditions are included in the buyOrder and sellOrder scripts (which are verified when the transaction is added to the blockchain). However, on the diagram those conditions are not specified in the bid and ask boxes, they are instead defined in the output boxes of the transaction. This is a convention for improved usability because most of the conditions relate to the properties of the output boxes. We could specify those properties in the bid box, but then we would have to use more complex expressions. Let's consider the output created by the arrow labeled with buyerOut@0 . This label tells us that the output is at the index 0 in the OUTPUTS collection of the transaction and that in the diagram we can refer to this box by the buyerOut name. Thus we can label both the box itself and the arrow to give the box a name. The conditions shown in the buyerOut box have the form bid ? condition , which means they should be verified on-chain in order to spend the bid box. The conditions have the following meaning: - tAmt: TID requires the box to have tAmt amount of TID token - R4 == bid.id requires R4 register in the box to be equal to id of the bid box. - script == buyer requires the buyerOut box to have the script of the wallet where it is located on the diagram, i.e. pk(buyer) Similar properties are added to the sellerOut box, which is specified to be at index 1 and the name is given to it using the label on the box itself, rather than on the arrow. The Swap transaction spends two boxes bid and ask using the !swap spending path on both, however unlike !cancel the conditions on the path are not specified. This is where the bid ? and ask ? prefixes come into play. They are used so that the conditions listed in the buyerOut and sellerOut boxes are moved to the !swap spending path of the bid and ask boxes correspondingly. If you look at the conditions of the output boxes, you will see that they exactly specify the swap of values between seller's and buyer's wallets. The buyer gets the necessary amount of TID token and seller gets the corresponding amount of ERGs. The Swap transaction is created when there are two matching boxes with buyOrder and sellOrder contracts. From Diagrams To ErgoScript Contracts What is interesting about FlowCard specifications is that we can use them to automatically generate the necessary ErgoTree scripts. With the appropriate tooling support this can be done automatically, but with the lack of thereof, it can be done manually. Thus, the FlowCard allows us to capture and visually represent all of the design choices and semantic details of an Ergo dApp. What we are going to do next is to mechanically create the buyOrder contract from the information given in the DEX flow card. Recall that each script is a proposition (boolean valued expression) which should evaluate to true to allow spending of the box. When we have many conditions to be met at the same time we can combine them in a logical formula using the AND binary operation, and if we have alternatives (not necessarily exclusive) we can put them into the OR operation. The buyOrder box has the alternative spending paths !cancel and !swap . Thus the ErgoScript code should have OR operation with two arguments - one for each spending path. /** buyOrder contract */ { val cancelCondition = {} val swapCondition = {} cancelCondition || swapCondition } The formula for the cancelCondition expression is given in the !cancel spending path of the buyOrder box. We can directly include it in the script. /** buyOrder contract */ { val cancelCondition = { buyer } val swapCondition = {} cancelCondition || swapCondition } For the !swap spending path of the buyOrder box the conditions are specified in the buyerOut output box of the Swap transaction. If we simply include them in the swapCondition then we get a syntactically incorrect script. /** buyOrder contract */ { val cancelCondition = { buyer } val swapCondition = { tAmt: TID && R4 == bid.id && @contract } cancelCondition || swapCondition } We can however translate the conditions from the diagram syntax to ErgoScript expressions using the following simple rules 1) buyerOut@0 ==> val buyerOut = OUTPUTS(0) 2) tAmt: TID ==> tid._2 == tAmt where tid = buyerOut.tokens(TID) 3) R4 == bid.id ==> R4 == SELF.id where R4 = buyerOut.R4[Coll[Byte]].get 4) script == buyer ==> buyerOut.propositionBytes == buyer.propBytes Note, in the diagram TID represents a token id, but ErgoScript doesn't have access to the tokens by the ids so we cannot write tokens.getByKey(TID) . For this reason, when the diagram is translated into ErgoScript, TID becomes a named constant of the index in tokens collection of the box. The concrete value of the constant is assigned when the BuyOrder transaction with the buyOrder box is created. The correspondence and consistency between the actual tokenId, the TID constant and the actual tokens of the buyerOut box is ensured by the off-chain application code, which is completely possible since all of the transactions are created by the application using FlowCard as a guiding specification. This may sound too complicated, but this is part of the translation from diagram specification to actual executable application code, most of which can be automated. After the transformation we can obtain a correct script which checks all the required preconditions for spending the buyOrder box. /** buyOrder contract */ def DEX(buyer: Addrss, seller: Address, TID: Int, ergAmt: Long, tAmt: Long) { val cancelCondition: SigmaProp = { buyer } // verify buyer's sig (ProveDlog) val swapCondition = OUTPUTS.size > 0 && { // securing OUTPUTS access val buyerOut = OUTPUTS(0) // from buyerOut@0 buyerOut.tokens.size > TID && { // securing tokens access val tid = buyerOut.tokens(TID) val regR4 = buyerOut.R4[Coll[Byte]] regR4.isDefined && { // securing R4 access val R4 = regR4.get tid._2 == tAmt && // from tAmt: TID R4 == SELF.id && // from R4 == bid.id buyerOut.propositionBytes == buyer.propBytes // from script == buyer } } } cancelCondition || swapCondition } A similar script for the sellOrder box can be obtained using the same translation rules. With the help of the tooling the code of contracts can be mechanically generated from the diagram specification. Conclusions Declarative programming models have already won the battle against imperative programming in many application domains like Big Data, Stream Processing, Deep Learning, Databases, etc. Ergo is pioneering the declarative model of dApp development as a better and safer alternative to the now popular imperative model of smart contracts. The concept of FlowCard shifts the focus from writing ErgoScript contracts to the overall flow of values (hence the name), in such a way, that ErgoScript can always be generated from them. You will never need to look at the ErgoScript code once the tooling is in place. Here are the possible next steps for future work: 1) Storage format for FlowCard Spec and the corresponding EIP standardized file format (Json/XML/Protobuf). This will allow various tools (Diagram Editor, Runtime, dApps etc) to create and use *.flowcard files. 2) FlowCard Viewer, which can generate the diagrams from *.flowcard files. 3) FlowCard Runtime, which can run *.flowcard files, create and send transactions to Ergo network. 4) FlowCard Designer Tool, which can simplify development of complex diagrams . This will make designing and validation of Ergo contracts a pleasant experience, more like drawing rather than coding. In addition, the correctness of the whole dApp scenario can be verified and controlled by the tooling. References Ergo Ergo Appkit Introduction to Appkit Appkit Examples ErgoDex ScalaDocs ErgoTree Specification","title":"FlowCards"},{"location":"dev/scs/flowcards/#introduction","text":"ErgoScript is the smart contract language used by the Ergo blockchain. While it has concise syntax adopted from Scala/Kotlin, it still may seem confusing at first because conceptually ErgoScript is quite different compared to conventional languages which we all know and love. This is because Ergo is a UTXO based blockchain, whereas smart contracts are traditionally associated with account based systems like Ethereum. However, Ergo's transaction model has many advantages over the account based model and with the right approach it can even be significantly easier to develop Ergo contracts than to write and debug Solidity code. Below we will cover the key aspects of the Ergo contract model which makes it different:","title":"Introduction"},{"location":"dev/scs/flowcards/#paradigm","text":"The account model of Ethereum is imperative. This means that the typical task of sending coins from Alice to Bob requires changing the balances in storage as a series of operations. Ergo's UTXO based programming model on the other hand is declarative. ErgoScript contracts specify conditions for a transaction to be accepted by the blockchain (not changes to be made in the storage state as result of the contract execution).","title":"Paradigm"},{"location":"dev/scs/flowcards/#scalability","text":"In the account model of Ethereum both storage changes and validity checks are performed on-chain during code execution. In contrast, Ergo transactions are created off-chain and only validation checks are performed on-chain thus reducing the amount of operations performed by every node on the network. In addition, due to immutability of the transaction graph, various optimization strategies are possible to improve throughput of transactions per second in the network. Light verifying nodes are also possible thus further facilitating scalability and accessibility of the network.","title":"Scalability"},{"location":"dev/scs/flowcards/#shared-state","text":"The account-based model is reliant on shared mutable state which is known to lead to complex semantics (and subtle million dollar bugs) in the context of concurrent/ distributed computation. Ergo's model is based on an immutable graph of transactions. This approach, inherited from Bitcoin, plays well with the concurrent and distributed nature of blockchains and facilitates light trustless clients.","title":"Shared state"},{"location":"dev/scs/flowcards/#expressive-power","text":"Ethereum advocated execution of a turing-complete language on the blockchain. It theoretically promised unlimited potential, however in practice severe limitations came to light from excessive blockchain bloat, subtle multi-million dollar bugs, gas costs which limit contract complexity, and other such problems. Ergo on the flip side extends UTXO to enable turing-completeness while limiting the complexity of the ErgoScript language itself. The same expressive power is achieved in a different and more semantically sound way. With the all of the above points, it should be clear that there are a lot of benefits to the model Ergo is using. In the rest of this article I will introduce you to the concept of FlowCards - a dApp developer component which allows for designing complex Ergo contracts in a declarative and visual way.","title":"Expressive Power"},{"location":"dev/scs/flowcards/#from-imperative-to-declarative","text":"In the imperative programming model of Ethereum a transaction is a sequence of operations executed by the Ethereum VM. The following Solidity function implements a transfer of tokens from sender to receiver . The transaction starts when sender calls this function on an instance of a contract and ends when the function returns. // Sends an amount of existing coins from any caller to an address function send(address receiver, uint amount) public { require(amount <= balances[msg.sender], \"Insufficient balance.\"); balances[msg.sender] -= amount; balances[receiver] += amount; emit Sent(msg.sender, receiver, amount); } The function first checks the pre-conditions, then updates the storage (i.e. balances) and finally publishes the post-condition as the Sent event. The gas which is consumed by the transaction is sent to the miner as a reward for executing this transaction. Unlike Ethereum, a transaction in Ergo is a data structure holding a list of input coins which it spends and a list of output coins which it creates preserving the total balances of ERGs and tokens (in which Ergo is similar to Bitcoin). Turning back to the example above, since Ergo natively supports tokens, therefore for this specific example of sending tokens we don't need to write any code in ErgoScript. Instead we need to create the 'send' transaction shown in the following figure, which describes the same token transfer but declaratively. The picture visually describes the following steps, which the network user needs to perform: 1) Select unspent sender's boxes, containing in total tB >= amount of tokens and B >= txFee + minErg ERGs. 2) Create an output target box which is protected by the receiver public key with minErg ERGs and amount of T tokens. 3) Create one fee output protected by the minerFee contract with txFee ERGs. 4) Create one change output protected by the sender public key, containing B - minErg - txFee ERGs and tB - amount of T tokens. 5) Create a new transaction, sign it using the sender's secret key and send to the Ergo network. What is important to understand here is that all of these steps are preformed off-chain (for example using Appkit Transaction API) by the user's application. Ergo network nodes don't need to repeat this transaction creation process, they only need to validate the already formed transaction. ErgoScript contracts are stored in the inputs of the transaction and check spending conditions. The node executes the contracts on-chain when the transaction is validated. The transaction is valid if all of the conditions are satisfied. Thus, in Ethereum when we \"send amount from sender to recipient\" we are literally editing balances and updating the storage with a concrete set of commands. This happens on-chain and thus a new transaction is also created on-chain as the result of this process. In Ergo (as in Bitcoin) transactions are created off-chain and the network nodes only verify them. The effects of the transaction on the blockchain state is that input coins (or Boxes in Ergo's parlance) are removed and output boxes are added to the UTXO set. In the example above we don't use an ErgoScript contract but instead assume a signature check is used as the spending pre-condition. However in more complex application scenarios we of course need to use ErgoScript which is what we are going to discuss next.","title":"From Imperative to Declarative"},{"location":"dev/scs/flowcards/#from-changing-state-to-checking-context","text":"In the send function example we first checked the pre-condition ( require(amount <= balances[msg.sender],...) ) and then changed the state (i.e. update balances balances[msg.sender] -= amount ). This is typical in Ethereum transactions. Before we change anything we need to check if it is valid to do so. In Ergo, as we discussed previously, the state (i.e. UTXO set of boxes) is changed implicitly when a valid transaction is included in a block. Thus we only need to check the pre-conditions before the transaction can be added to the block. This is what ErgoScript contracts do. It is not possible to \"change the state\" in ErgoScript because it is a language to check pre-conditions for spending coins. ErgoScript is a purely functional language without side effects that operates on immutable data values. This means all the inputs, outputs and other transaction parameters available in a script are immutable. This, among other things, makes ErgoScript a very simple language that is easy to learn and safe to use. Similar to Bitcoin, each input box contains a script, which should return the true value in order to 1) allow spending of the box (i.e. removing from the UTXO set) and 2) adding the transaction to the block. If we are being pedantic, it is therefore incorrect (strictly speaking) to think of ErgoScript as the language of Ergo contracts, because it is the language of propositions (logical predicates, formulas, etc.) which protect boxes from \"illegal\" spending. Unlike Bitcoin, in Ergo the whole transaction and a part of the current blockchain context is available to every script. Therefore each script may check which outputs are created by the transaction, their ERG and token amounts (we will use this capability in our example DEX contracts), current block number etc. In ErgoScript you define the conditions of whether changes (i.e. coin spending) are allowed to happen in a given context. This is in contrast to programming the changes imperatively in the code of a contract. While Ergo's transaction model unlocks a whole range of applications like (DEX, DeFi Apps, LETS, etc), designing contracts as pre-conditions for coin spending (or guarding scripts) directly is not intuitive. In the next sections we will consider a useful graphical notation to design contracts declaratively using FlowCard Diagrams , which is a visual representation of executable components (FlowCards). FlowCards aim to radically simplify dApp development on the Ergo platform by providing a high-level declarative language, execution runtime, storage format and a graphical notation . We will start with a high level of diagrams and go down to FlowCard specification.","title":"From Changing State to Checking Context"},{"location":"dev/scs/flowcards/#flowcard-diagrams","text":"The idea behind FlowCard diagrams is based on the following observations: 1) An Ergo box is immutable and can only be spent in the transaction which uses it as an input. 2) We therefore can draw a flow of boxes through transactions, so that boxes flowing in to the transaction are spent and those flowing out are created and added to the UTXO. 3) A transaction from this perspective is simply a transformer of old boxes to the new ones preserving the balances of ERGs and tokens involved. The following figure shows the main elements of the Ergo transaction we've already seen previously (now under the name of FlowCard Diagram). There is a strictly defined meaning (semantics) behind every element of the diagram , so that the diagram is a visual representation (or a view) of the underlying executable component (called FlowCard). The FlowCard can be used as a reusable component of an Ergo dApp to create and initiate the transaction on the Ergo blockchain. We will discuss this in the coming sections. Now let's look at the individual pieces of the FlowCard diagram one by one.","title":"FlowCard Diagrams"},{"location":"dev/scs/flowcards/#1-name-and-parameters","text":"Each flow card is given a name and a list of typed parameters. This is similar to a template with parameters. In the above figure we can see the Send flow card which has five parameters. The parameters are used in the specification.","title":"1. Name and Parameters"},{"location":"dev/scs/flowcards/#2-contract-wallet","text":"This is a key element of the flow card. Every box has a guarding script. Often it is the script that checks a signature against a public key. This script is trivial in ErgoScript and is defined like the def pk(pubkey: Address) = { pubkey } template where pubkey is a parameter of the type Address . In the figure, the script template is applied to the parameter pk(sender) and thus a concrete wallet contract is obtained. Therefore pk(sender) and pk(receiver) yield different scripts and represent different wallets on the diagram, even though they use the same template. Contract Wallet contains a set of all UTXO boxes which have a given script derived from the given script template using flow card parameters. For example, in the figure, the template is pk and parameter pubkey is substituted with the `sender' flow card parameter.","title":"2. Contract Wallet"},{"location":"dev/scs/flowcards/#3-contract","text":"Even though a contract is a property of a box, on the diagram we group the boxes by their contracts, therefore it looks like the boxes belong to the contracts, rather than the contracts belong to the boxes. In the example, we have three instantiated contracts pk(sender) , pk(receiver) and minerFee . Note, that pk(sender) is the instantiation of the pk template with the concrete parameter sender and minerFee is the instantiation of the pre-defined contract which protects the miner reward boxes.","title":"3. Contract"},{"location":"dev/scs/flowcards/#4-box-name","text":"In the diagram we can give each box a name. Besides readability of the diagram, we also use the name as a synonym of a more complex indexed access to the box in the contract. For example, change is the name of the box, which can also be used in the ErgoScript conditions instead of OUTPUTS(2) . We also use box names to associate spending conditions with the boxes.","title":"4. Box name"},{"location":"dev/scs/flowcards/#5-boxes-in-the-wallet","text":"In the diagram, we show boxes (darker rectangles) as belonging to the contract wallets (lighter rectangles). Each such box rectangle is connected with a grey transaction rectangle by either orange or green arrows or both. An output box (with an incoming green arrow) may include many lines of text where each line specifies a condition which should be checked as part of the transaction. The first line specifies the condition on the amount of ERG which should be placed in the box. Other lines may take one of the following forms: 1) amount: TOKEN - the box should contain the given amount of the given TOKEN 2) R == value - the box should contain the given value of the given register R 3) boxName ? condition - the box named boxName should check condition in its script. We discuss these conditions in the sections below.","title":"5. Boxes in the wallet"},{"location":"dev/scs/flowcards/#6-amount-of-ergs-in-the-box","text":"Each box should store a minimum amount of ERGs. This is checked when the creating transaction is validated. In the diagram the amount of ERGs is always shown as the first line (e.g. B: ERG or B - minErg - txFee ). The value type ascription B: ERG is optional and may be used for readability. When the value is given as a formula, then this formula should be respected by the transaction which creates the box. It is important to understand that variables like amount and txFee are not named properties of the boxes. They are parameters of the whole diagram and representing some amounts. Or put it another way, they are shared parameters between transactions (e.g. Sell Order and Swap transactions from DEX example below share the tAmt parameter). So the same name is tied to the same value throughout the diagram (this is where the tooling would help a lot). However, when it comes to on-chain validation of those values, only explicit conditions which are marked with ? are transformed to ErgoScript. At the same time, all other conditions are ensured off-chain during transaction building (for example in an application using Appkit API) and transaction validation when it is added to the blockchain.","title":"6. Amount of ERGs in the box"},{"location":"dev/scs/flowcards/#7-amount-of-t-token","text":"A box can store values of many tokens. The tokens on the diagram are named and a value variable may be associated with the token T using value: T expression. The value may be given by formula. If the formula is prefixed with a box name like boxName ? formula , then it is should also be checked in the guarding script of the boxName box. This additional specification is very convenient because 1) it allows to validate the visual design automatically, and 2) the conditions specified in the boxes of a diagram are enough to synthesize the necessary guarding scripts. (more about this below at \"From Diagrams To ErgoScript Contracts\" )","title":"7. Amount of T token"},{"location":"dev/scs/flowcards/#8-tx-inputs","text":"Inputs are connected to the corresponding transaction by orange arrows. An input arrow may have a label of the following forms: 1) name@index - optional name with an index i.e. fee@0 or @2 . This is a property of the target endpoint of the arrow. The name is used in conditions of related boxes and the index is the position of the corresponding box in the INPUTS collection of the transaction. 2) !action - is a property of the source of the arrow and gives a name for an alternative spending path of the box (we will see this in DEX example) Because of alternative spending paths, a box may have many outgoing orange arrows, in which case they should be labeled with different actions.","title":"8. Tx Inputs"},{"location":"dev/scs/flowcards/#9-transaction","text":"A transaction spends input boxes and creates output boxes. The input boxes are given by the orange arrows and the labels are expected to put inputs at the right indexes in INPUTS collection. The output boxes are given by the green arrows. Each transaction should preserve a strict balance of ERG values (sum of inputs == sum of outputs) and for each token the sum of inputs >= the sum of outputs. The design diagram requires an explicit specification of the ERG and token values for all of the output boxes to avoid implicit errors and ensure better readability.","title":"9. Transaction"},{"location":"dev/scs/flowcards/#10-tx-outputs","text":"Outputs are connected to the corresponding transaction by green arrows. An output arrow may have a label of the following form name@index , where an optional name is accompanied with an index i.e. fee@0 or @2 . This is a property of the source endpoint of the arrow. The name is used in conditions of the related boxes and the index is the position of the corresponding box in the OUTPUTS collection of the transaction.","title":"10. Tx Outputs"},{"location":"dev/scs/flowcards/#example-decentralized-exchange-dex","text":"Now let's use the above described notation to design a FlowCard for a DEX dApp. It is simple enough yet also illustrates all of the key features of FlowCard diagrams which we've introduced in the previous section. The dApp scenario is shown in the figure below: There are three participants (buyer, seller and DEX) of the DEX dApp and five different transaction types, which are created by participants. The buyer wants to swap ergAmt of ERGs for tAmt of TID tokens (or vice versa, the seller wants to sell TID tokens for ERGs, who sends the order first doesn't matter). Both the buyer and the seller can cancel their orders any time. The DEX off-chain matching service can find matching orders and create the Swap transaction to complete the exchange. The following diagram fully (and formally) specifies all of the five transactions that must be created off-chain by the DEX dApp. It also specifies all of the spending conditions that should be verified on-chain . Let's discuss the FlowCard diagram and the logic of each transaction in details:","title":"Example: Decentralized Exchange (DEX)"},{"location":"dev/scs/flowcards/#buy-order-transaction","text":"A buyer creates a Buy Order transaction. The transaction spends E amount of ERGs (which we will write E: ERG ) from one or more boxes in the pk(buyer) wallet. The transaction creates a bid box with ergAmt: ERG protected by the buyOrder script. The buyOrder script is synthesized from the specification (see below at \"From Diagrams To ErgoScript Contracts\" ) either manually or automatically by a tool. Even though we don't need to define the buyOrder script explicitly during designing, at run time the bid box should contain the buyOrder script as the guarding proposition (which checks the box spending conditions), otherwise the conditions specified in the diagram will not be checked. The change box is created to make the input and output sums of the transaction balanced. The transaction fee box is omitted because it can be added automatically by the tools. In practice, however, the designer can add the fee box explicitly to the a diagram. It covers the cases of more complex transactions (like Swap) where there are many ways to pay the transaction fee.","title":"Buy Order Transaction"},{"location":"dev/scs/flowcards/#cancel-buy-cancel-sell-transactions","text":"At any time, the buyer can cancel the order by sending CancelBuy transaction. The transaction should satisfy the guarding buyOrder contract which protects the bid box. As you can see on the diagram, both the Cancel and the Swap transactions can spend the bid box. When a box has spending alternatives (or spending paths ) then each alternative is identified by a unique name prefixed with ! ( !cancel and !swap for the bid box). Each alternative path has specific spending conditions. In our example, when the Cancel Buy transaction spends the bid box the ?buyer condition should be satisfied, which we read as \"the signature for the buyer address should be presented in the transaction\". Therefore, only buyer can cancel the buy order. This \"signature\" condition is only required for the !cancel alternative spending path and not required for !swap .","title":"Cancel Buy, Cancel Sell Transactions"},{"location":"dev/scs/flowcards/#sell-order-transaction","text":"The Sell Order transaction is similar to the BuyOrder in that it deals with tokens in addition to ERGs. The transaction spends E: ERG and T: TID tokens from seller's wallet (specified as pk(seller) contract). The two outputs are ask and change . The change is a standard box to balance transaction. The ask box keeps tAmt: TID tokens for the exchange and minErg: ERG - the minimum amount of ERGs required in every box.","title":"Sell Order Transaction"},{"location":"dev/scs/flowcards/#swap-transaction","text":"This is a key transaction in the DEX dApp scenario. The transaction has several spending conditions on the input boxes and those conditions are included in the buyOrder and sellOrder scripts (which are verified when the transaction is added to the blockchain). However, on the diagram those conditions are not specified in the bid and ask boxes, they are instead defined in the output boxes of the transaction. This is a convention for improved usability because most of the conditions relate to the properties of the output boxes. We could specify those properties in the bid box, but then we would have to use more complex expressions. Let's consider the output created by the arrow labeled with buyerOut@0 . This label tells us that the output is at the index 0 in the OUTPUTS collection of the transaction and that in the diagram we can refer to this box by the buyerOut name. Thus we can label both the box itself and the arrow to give the box a name. The conditions shown in the buyerOut box have the form bid ? condition , which means they should be verified on-chain in order to spend the bid box. The conditions have the following meaning: - tAmt: TID requires the box to have tAmt amount of TID token - R4 == bid.id requires R4 register in the box to be equal to id of the bid box. - script == buyer requires the buyerOut box to have the script of the wallet where it is located on the diagram, i.e. pk(buyer) Similar properties are added to the sellerOut box, which is specified to be at index 1 and the name is given to it using the label on the box itself, rather than on the arrow. The Swap transaction spends two boxes bid and ask using the !swap spending path on both, however unlike !cancel the conditions on the path are not specified. This is where the bid ? and ask ? prefixes come into play. They are used so that the conditions listed in the buyerOut and sellerOut boxes are moved to the !swap spending path of the bid and ask boxes correspondingly. If you look at the conditions of the output boxes, you will see that they exactly specify the swap of values between seller's and buyer's wallets. The buyer gets the necessary amount of TID token and seller gets the corresponding amount of ERGs. The Swap transaction is created when there are two matching boxes with buyOrder and sellOrder contracts.","title":"Swap Transaction"},{"location":"dev/scs/flowcards/#from-diagrams-to-ergoscript-contracts","text":"What is interesting about FlowCard specifications is that we can use them to automatically generate the necessary ErgoTree scripts. With the appropriate tooling support this can be done automatically, but with the lack of thereof, it can be done manually. Thus, the FlowCard allows us to capture and visually represent all of the design choices and semantic details of an Ergo dApp. What we are going to do next is to mechanically create the buyOrder contract from the information given in the DEX flow card. Recall that each script is a proposition (boolean valued expression) which should evaluate to true to allow spending of the box. When we have many conditions to be met at the same time we can combine them in a logical formula using the AND binary operation, and if we have alternatives (not necessarily exclusive) we can put them into the OR operation. The buyOrder box has the alternative spending paths !cancel and !swap . Thus the ErgoScript code should have OR operation with two arguments - one for each spending path. /** buyOrder contract */ { val cancelCondition = {} val swapCondition = {} cancelCondition || swapCondition } The formula for the cancelCondition expression is given in the !cancel spending path of the buyOrder box. We can directly include it in the script. /** buyOrder contract */ { val cancelCondition = { buyer } val swapCondition = {} cancelCondition || swapCondition } For the !swap spending path of the buyOrder box the conditions are specified in the buyerOut output box of the Swap transaction. If we simply include them in the swapCondition then we get a syntactically incorrect script. /** buyOrder contract */ { val cancelCondition = { buyer } val swapCondition = { tAmt: TID && R4 == bid.id && @contract } cancelCondition || swapCondition } We can however translate the conditions from the diagram syntax to ErgoScript expressions using the following simple rules 1) buyerOut@0 ==> val buyerOut = OUTPUTS(0) 2) tAmt: TID ==> tid._2 == tAmt where tid = buyerOut.tokens(TID) 3) R4 == bid.id ==> R4 == SELF.id where R4 = buyerOut.R4[Coll[Byte]].get 4) script == buyer ==> buyerOut.propositionBytes == buyer.propBytes Note, in the diagram TID represents a token id, but ErgoScript doesn't have access to the tokens by the ids so we cannot write tokens.getByKey(TID) . For this reason, when the diagram is translated into ErgoScript, TID becomes a named constant of the index in tokens collection of the box. The concrete value of the constant is assigned when the BuyOrder transaction with the buyOrder box is created. The correspondence and consistency between the actual tokenId, the TID constant and the actual tokens of the buyerOut box is ensured by the off-chain application code, which is completely possible since all of the transactions are created by the application using FlowCard as a guiding specification. This may sound too complicated, but this is part of the translation from diagram specification to actual executable application code, most of which can be automated. After the transformation we can obtain a correct script which checks all the required preconditions for spending the buyOrder box. /** buyOrder contract */ def DEX(buyer: Addrss, seller: Address, TID: Int, ergAmt: Long, tAmt: Long) { val cancelCondition: SigmaProp = { buyer } // verify buyer's sig (ProveDlog) val swapCondition = OUTPUTS.size > 0 && { // securing OUTPUTS access val buyerOut = OUTPUTS(0) // from buyerOut@0 buyerOut.tokens.size > TID && { // securing tokens access val tid = buyerOut.tokens(TID) val regR4 = buyerOut.R4[Coll[Byte]] regR4.isDefined && { // securing R4 access val R4 = regR4.get tid._2 == tAmt && // from tAmt: TID R4 == SELF.id && // from R4 == bid.id buyerOut.propositionBytes == buyer.propBytes // from script == buyer } } } cancelCondition || swapCondition } A similar script for the sellOrder box can be obtained using the same translation rules. With the help of the tooling the code of contracts can be mechanically generated from the diagram specification.","title":"From Diagrams To ErgoScript Contracts"},{"location":"dev/scs/flowcards/#conclusions","text":"Declarative programming models have already won the battle against imperative programming in many application domains like Big Data, Stream Processing, Deep Learning, Databases, etc. Ergo is pioneering the declarative model of dApp development as a better and safer alternative to the now popular imperative model of smart contracts. The concept of FlowCard shifts the focus from writing ErgoScript contracts to the overall flow of values (hence the name), in such a way, that ErgoScript can always be generated from them. You will never need to look at the ErgoScript code once the tooling is in place. Here are the possible next steps for future work: 1) Storage format for FlowCard Spec and the corresponding EIP standardized file format (Json/XML/Protobuf). This will allow various tools (Diagram Editor, Runtime, dApps etc) to create and use *.flowcard files. 2) FlowCard Viewer, which can generate the diagrams from *.flowcard files. 3) FlowCard Runtime, which can run *.flowcard files, create and send transactions to Ergo network. 4) FlowCard Designer Tool, which can simplify development of complex diagrams . This will make designing and validation of Ergo contracts a pleasant experience, more like drawing rather than coding. In addition, the correctness of the whole dApp scenario can be verified and controlled by the tooling.","title":"Conclusions"},{"location":"dev/scs/flowcards/#references","text":"Ergo Ergo Appkit Introduction to Appkit Appkit Examples ErgoDex ScalaDocs ErgoTree Specification","title":"References"},{"location":"dev/scs/microcredit/","text":"A lot of blockchain-related news these days are saying us that a bank X or a corporation Y is going to use a \"blockchain\" to \"reduce costs\". Basically it means that just another buzzword is considered by big banksters as just another tool to extract value from everywhere in a more efficient way, and also to save on cutting job positions. While I am avoiding to say anything about \"Satoshi's vision\" (nothing but speculations could be dug there after his exodus), a broad view I witnessed in the early years around online forums users is that a cryptocurrency should provide tools to enrich the ordinary people behind their small businesses providing no much above making ends meet, not depersonalized big financial capital. The tools of a cryptocurrency in the eyes of the original broad community vision should allow people to do economic activity dependless on business size, geographic location, interest rates set by big players, and so on. The tools should allow people to do contracts (no paper contracts, but digital, self-enforcing, and reasonably smart contracts) dependless on differences in jurisdictions, traditions, followed business practices etc. I hope Ergo would be useful here. Thousands of small cooperatives and individual entrepreneurs are more important to healthy and sustainable wealth growth around the globe than a couple of corporations hiding profits in offshore heavens. As an example, let's consider a cooperative federation (such as Radical Routes ) willing to provide financial help to an entrepreneur thousands kilometers away (say, in Rojava). We need to assume some details now. In the first place, assume that there are four cooperatives in the network. They collectively lock 10,000 Ergs (in equal parts, so 2,500 Ergs each) in a contract, which says the following: The cooperatives are associated with public keys pubkeyA , pubkeyB , pubkeyC , pubkeyD . The entrepreneur is associated with a public key businessKey . The cooperatives are locking money in a coin protected by a funding contract, then doing due diligence and vote on whether to fund the entrepreneur or not. All the contract fund ( 10,000 Ergs) is going to the entrepreneur if 3 votes out of 4 are for that. Technically, the voting is done via 3-out-of-4 threshold signature. If voting is not successful ( 3 out of 4 signatures are not collected) before the block number 1,000 , any cooperative (actually, anyone) can submit withdraw transaction, which is returning 2,500 Ergs (at least) to every cooperative. Further, the funding contract will also be called the voting contract. The investments could be spent on three goals, with some strict bounds. Namely, the entrepreneur must spend at least 5,000 Ergs on equipment, at least 2,000 Ergs on construction of a building needed, other funds the entrepreneur may spend arbitrarily. To be sure that equipment money will be spent on equipment, the cooperative federation is using public keys of known equipment sellers in the area of the entrepreneur. For example, consider that there are equipment sellers with public keys pubkeyTool1 , pubkeyTool2 , pubkeyTool3 , pubkeyTool4 in the area. Technically, the transfer is organized as a collective signature of one equipment sellers (thus ring signature from equipment sellers ring AND entrepreneur's signature) Similarly, assume that there are 3 builders in the are cooperative federation is recognizing, associated with public keys pubkeyConstr1 , pubkeyConstr2 , and pubkeyConstr3 . Similarly to the voting contract, if equipment and construction contracts are not co-signed before block number 5000 , the federation cooperatives could withdraw funds. There are different ways to define contracts in Ergo. A script in the low-level language, ErgoTree , is describing a (single) logical condition on whether a coin could be spent according it, and also a spending proof provided by a spending transaction. Internally, the condition is represented as a typed syntax tree thus the name. The structure is allowing us to do ahead-of-time cost analysis etc. Higher-level language called ErgoScript allows to have more traditional and readable description, use variables and break logic into subroutines. Let's start with the main contract defined in (1-3) above: { val votingSuccess = atLeast(3, Array(pubkeyA, pubkeyB, pubkeyC, pubkeyD)) val properSpending = OUTPUTS(0).value >= 5000L && blake2b256(OUTPUTS(0).propositionBytes) == spendingContract1Hash && OUTPUTS(1).value >= 2000L && blake2b256(OUTPUTS(1).propositionBytes) == spendingContract2Hash val withdrawCondition = HEIGHT >= 1000L && OUTPUTS(0).value >= 2500L && OUTPUTS(0).propositionBytes == pubkeyA.propBytes && OUTPUTS(1).value >= 2500L && OUTPUTS(1).propositionBytes == pubkeyB.propBytes && OUTPUTS(2).value >= 2500L && OUTPUTS(2).propositionBytes == pubkeyC.propBytes && OUTPUTS(3).value >= 2500L && OUTPUTS(3).propositionBytes == pubkeyD.propBytes (votingSuccess && properSpending) || withdrawCondition } This script in the ErgoScript is to be compiled into a syntax tree (which is to be written into the blockchain in a serialized form) by binding it with concrete values for variables ( pubkeyA , pubkeyB , pubkeyC , pubkeyD , spendingContract1Hash , spendingContract2Hash ). spendingContract1Hash is a hash of (serialized) equipment spending script which will be provided below, spendingContract2Hash is a hash of construction spending script. The equipment spending script is below: { val spendingSuccess = (pubkeyTool1 || pubkeyTool2 || pubkeyTool3 || pubkeyTool4) && businessKey val withdrawCondition = HEIGHT > 5000L && OUTPUTS(0).value >= 1250L && OUTPUTS(0).propositionBytes == pubkeyA.propBytes && OUTPUTS(1).value >= 1250L && OUTPUTS(1).propositionBytes == pubkeyB.propBytes && OUTPUTS(2).value >= 1250L && OUTPUTS(2).propositionBytes == pubkeyC.propBytes && OUTPUTS(3).value >= 1250L && OUTPUTS(3).propositionBytes == pubkeyD.propBytes spendingSuccess || withdrawCondition } And the construction script is: { val spendingSuccess = (pubkeyConstr1 || pubkeyConstr2 || pubkeyConstr3) && businessKey val withdrawCondition = HEIGHT > 5000L && OUTPUTS(0).value >= 500L && OUTPUTS(0).propositionBytes == pubkeyA.propBytes && OUTPUTS(1).value >= 500L && OUTPUTS(1).propositionBytes == pubkeyB.propBytes && OUTPUTS(2).value >= 500L && OUTPUTS(2).propositionBytes == pubkeyC.propBytes && OUTPUTS(3).value >= 500L && OUTPUTS(3).propositionBytes == pubkeyD.propBytes spendingSuccess || withdrawCondition } Now assume that the cooperative federation has created a coin protected by the voting contract. Below is how the entrepreneur can do his business: Create a transaction which consumes the coin and create at least three coins, one with equipment spending contract, another with construction spending contract, third is creating a coin protected by entrepreneur's public key. Send the transaction to the cooperatives, wait for the transaction with the threshold-signed input being published on the blockchain. Consider a contract with an equipment seller, co-sign a spending transaction. Consider a contract with a builder, co-sign a spending transaction. The entrepreneur can easily run away without doing any business, but with no more than 3,000 Ergs. This can be fixed, e.g. this money could be made spendable only after block number 5,000 , and before that money could be withdrawn by the cooperatives. For equipment and construction spendings, the entrepreneur is working along with some, presumably already reputable, business. Thus the investor is reducing its risks. You can find code and example transactions online . Please note that we have more examples of complex signature schemes, multi-step contracts (with on-the-go execution paths revealing, like MAST in Bitcoin, but with cycles allowed), oracles, crowdfunding and so on. Please check our examples repository .","title":"Micro Credit"},{"location":"dev/scs/multi/","text":"Multi-Stage Contracts So you\u2019ve heard about smart contracts, but what are multi-stage contracts? Multi-stage contracts refer to smart contracts that are operating on a stateful level. Because Ergo uses the UTXO model, it is possible to process parallelized actions on top of smart contracts. For a blockchain to contain smart contracts, it should have loops. These loops can later refer to themselves and check whether an operation is working or not. Bitcoin\u2019s UTXO design is very primitive, and it doesn\u2019t contain Turing-complete smart contracts. Ethereum has this capability, but it\u2019s a primitive version of a Turing-complete language. Ergo Blockchain provides a different approach to multi-stage contracts, empowered by the extended UTXO model. Permitting a lighter network and broader use cases. Multi-Stage Contracts Multi-Stage Contracts in the UTXO Model: Delivery by Alexander Chepurnoy & Amitabh Saxena","title":"Multi-Stage Contracts"},{"location":"dev/scs/multi/#multi-stage-contracts","text":"So you\u2019ve heard about smart contracts, but what are multi-stage contracts? Multi-stage contracts refer to smart contracts that are operating on a stateful level. Because Ergo uses the UTXO model, it is possible to process parallelized actions on top of smart contracts. For a blockchain to contain smart contracts, it should have loops. These loops can later refer to themselves and check whether an operation is working or not. Bitcoin\u2019s UTXO design is very primitive, and it doesn\u2019t contain Turing-complete smart contracts. Ethereum has this capability, but it\u2019s a primitive version of a Turing-complete language. Ergo Blockchain provides a different approach to multi-stage contracts, empowered by the extended UTXO model. Permitting a lighter network and broader use cases. Multi-Stage Contracts Multi-Stage Contracts in the UTXO Model: Delivery by Alexander Chepurnoy & Amitabh Saxena","title":"Multi-Stage Contracts"},{"location":"dev/scs/sigma/","text":"Ergo aims to provide an efficient, secure, and easy way to implement financial contracts that will be useful and survivable in the long term. There is plenty of uniqueness in Ergo but the most significant is probably Sigma protocols. These allow a true P2P system with privacy in mind. No one else at the moment is able to build a trustless LETS system, multisig with no signers disclosure, trustless payment networks or has real ring signatures that preserve zero knowledge. The overwhelming majority of successful public blockchain use\u2010cases are related to financial applications. Ergo extends Bitcoin's way of writing contracts by attaching a guard script (together with additional custom data) to every coin. For example, in addition to regular protection by some m\u2010of\u2010n signature, Ergo allows specifying the possible recipients of these coins, which may also be a contract with similar complex conditions. This \"chaining\" approach enables the implementation of secure and efficient contracts of arbitrary complexity. This, along with Ergo's focus on sustainability, makes it uniquely valuable as contractual money. Privacy must remain an option to protect the individual. It does not have to be forced; let people make their own choices. Privacy is the ability to create barriers and erect boundaries to create a space and for the individual. It is up to each what borders and boundaries they choose to make. Civilization exists under a continuous tension between what is best for society and what is best for the individual. The only real entities in a community are individuals. All collectives, associations, and governments stem from individual participation and interaction. Ergo utilizes the eUTXO model for enhanced privacy & scalability options while also employing expressive smart contracts for DeFi applications. DarkFund0 - ZK Fund for privacy applications | sponsors new developments in regards with privacy and private DeFi - 4000 ERG up for grabs! Zero-Knowledge Proof Intro Let\u2019s say someone picks up a phone in a bar. You can prove it\u2019s yours by hiding the screen, entering the unlock code and showing the unlocked screen to the person who found it. This is a simple example of a zero-knowledge proof: you have proven you own the phone without giving away any sensitive information. In cryptography, most practical problems are associated with secrets. The most popular application lies in digital signatures, used by millions of people around the world every day. Essentially, these involve saying: \u2018This message proves I know the private key associated with this public key \u2013 but I\u2019m not revealing the private key itself\u2019. Sigma protocols ErgoScript is the language used to specify the conditions under which currency can be spent. The language supports a type of non-interactive zero-knowledge proofs called \u03a3-protocols and is flexible enough to allow for ring-signatures, multisignatures, multiple currencies, atomic swaps, self-replicating scripts, and long-term computation. The overwhelming majority of successful public blockchain use\u2010cases are related to financial applications. Ergo extends Bitcoin\u2019s way of writing contracts by attaching a guard script (together with additional custom data) to every coin. For example, in addition to regular protection by some m\u2010of\u2010n signature, Ergo allows specifying the possible recipients of these coins, which may another contract with similar complex conditions. This \"chaining\" approach allows the implementation of secure and efficient contracts of arbitrary complexity. Keeping all this in mind, we expect ErgoScript and Ergo\u2019s design to be uniquely useful as Contractual Money. Let's say you want to create a 'ring spending contract', where either of us can make a transaction from the same address, but we don't want anyone else to know which one of us is spending the funds. That's not possible with Bitcoin. While Ethereum can, it would be expensive and complicated \u2013 especially with a ring size of 10 or 20 members, required for robust privacy. With Ergo, this kind of application can be created quickly, thanks to the integration of Sigma protocols in the core. This enables self-sovereign application-level privacy: trustless scripts that can be used to access mixers or other functionality without any third parties required. val ringScript = s\"\"\" { atLeast( 3, Coll( PK(\"9f8ZQt1Sue6W5ACdMSPRzsHj3jjiZkbYy3CEtB4BisxEyk4RsNk\"), PK(\"9hFWPyhCJcw4KQyCGu4yAGfC1ieRAKyFg24FKjLJK2uDgA873uq\"), PK(\"9fdVP2jca1e5nCTT6q9ijZLssGj6v4juY8gEAxUhp7YTuSsLspS\"), PK(\"9gAKeRu1W4Dh6adWXnnYmfqjCTnxnSMtym2LPPMPErCkusCd6F3\"), PK(\"9gmNsqrqdSppLUBqg2UzREmmivgqh1r3jmNcLAc53hk3YCvAGWE\") ) ) } This an example 3-out-of-5 threshold signature which can be compiled to a P2S address sending ergs to resulting address (protected by the threshold sig) Here is a good intro to making a signature Use Cases When combined with a blockchain, these composable proofs enable some very powerful use cases. The logic for proofs can include conditions based on blockchain state. For example, \u2018If the deadline block height has been reached, Alice can provide knowledge of a secret key for a refund. OR a ring signature from Alice and Bob is required to spend coins.\u2019 Or \u2018If this account holds a minimum of 100 ERG, Alice OR Bob can remove funds above that amount.\u2019 It\u2019s relatively easy to swap coins or custom tokens trustlessly across any Bitcoin-like blockchains. But beyond that, Ergo allows partial swaps. Just like on a regular exchange, orders can be partially filled, if that\u2019s what the trader wants. This means it\u2019s possible to build a fully-fledged decentralised exchange (DEX) that enables cross-chain trading: a totally trustless version of existing crypto exchanges. There\u2019s no need for any gateways, token wrapping or other potential bottlenecks or points of failure. 'Optional' Privacy? A Rich smart-contract language and simplicity are the priority in Ergo, and smart-contracts make privacy a lot harder. There are plenty of reasons to want optional privacy - transparent ledgers are a feature for many use-cases. e.g. charities that want everyone to have full access to the flow of funds. The ability to operate with privacy or with transparency is a feature. There's also strong arguments for optional privacy for adoption and regulation. ErgoMixer is non-interactive so works with the blockchain alone, no off-chain coordination with others (and trusted coordinator) needed. In future, privacy by default could be enabled for every transaction in Ergo. Maybe the community will do it someday or maybe integrating mix-nets and on other novel ideas on the application layer will be sufficient. \"With non-optional privacy you can't have (efficient) powerful contracts. Even more, even for simple payments formalizing (in order to minimize with guarantee) leakage is hard, for arbitrary contracts not feasible at all I guess\" ErgoMixer ErgoMixer is a state of the art (and worlds first) non-interactive and non-custodial token mixer and the first real implementation of Sigma protocols on Ergo. Mac/Windows applications are available! . Check out this page on ergonaut.space for more information including research papers / presentations; and these discussions in Discords. Tornado Cash vs ErgoMixer anon2020s explaining the how ErgoMixer retains its anonymity Lots more applications possible, many still undiscovered! A Simpler Collective-Spending Approach for Everyone! trustless prediction markets and on-chain insurance Trustless LETS \"I think global mutual credit system (trustless, so collateralized) can be perfectly combined with ErgoFund, so funds collected can be used to open credit-line basically to spend money for services in the mutual credit system\" \"So at the same time off the peg ring and threshold signatures, where from k-out-of-n signatures, it could not be concluded which k signers were real, so you have i think first zero knowledge multisig with no signers disclosure in cryptocurrency at the same time(on app level).\" \"You have to look more into the base at the moment to see future possibilities, at the base you have multisig with no signers disclosure, then new features like covert address, multi hop withdrawals discovered slowly thanks to contracts possibilities, mixer can be just run locally at the same time. You can build Monero on top of Ergo, will it have better privacy guarantees? it is yet to be discovered. But you can think of private order books for example at the same time, similar to a simple and interesting payment network. I think that combining these things with NYM in the future can have more sense for scalable privacy.\"","title":"Sigma Protocols"},{"location":"dev/scs/sigma/#zero-knowledge-proof-intro","text":"Let\u2019s say someone picks up a phone in a bar. You can prove it\u2019s yours by hiding the screen, entering the unlock code and showing the unlocked screen to the person who found it. This is a simple example of a zero-knowledge proof: you have proven you own the phone without giving away any sensitive information. In cryptography, most practical problems are associated with secrets. The most popular application lies in digital signatures, used by millions of people around the world every day. Essentially, these involve saying: \u2018This message proves I know the private key associated with this public key \u2013 but I\u2019m not revealing the private key itself\u2019.","title":"Zero-Knowledge Proof Intro"},{"location":"dev/scs/sigma/#sigma-protocols","text":"ErgoScript is the language used to specify the conditions under which currency can be spent. The language supports a type of non-interactive zero-knowledge proofs called \u03a3-protocols and is flexible enough to allow for ring-signatures, multisignatures, multiple currencies, atomic swaps, self-replicating scripts, and long-term computation. The overwhelming majority of successful public blockchain use\u2010cases are related to financial applications. Ergo extends Bitcoin\u2019s way of writing contracts by attaching a guard script (together with additional custom data) to every coin. For example, in addition to regular protection by some m\u2010of\u2010n signature, Ergo allows specifying the possible recipients of these coins, which may another contract with similar complex conditions. This \"chaining\" approach allows the implementation of secure and efficient contracts of arbitrary complexity. Keeping all this in mind, we expect ErgoScript and Ergo\u2019s design to be uniquely useful as Contractual Money. Let's say you want to create a 'ring spending contract', where either of us can make a transaction from the same address, but we don't want anyone else to know which one of us is spending the funds. That's not possible with Bitcoin. While Ethereum can, it would be expensive and complicated \u2013 especially with a ring size of 10 or 20 members, required for robust privacy. With Ergo, this kind of application can be created quickly, thanks to the integration of Sigma protocols in the core. This enables self-sovereign application-level privacy: trustless scripts that can be used to access mixers or other functionality without any third parties required. val ringScript = s\"\"\" { atLeast( 3, Coll( PK(\"9f8ZQt1Sue6W5ACdMSPRzsHj3jjiZkbYy3CEtB4BisxEyk4RsNk\"), PK(\"9hFWPyhCJcw4KQyCGu4yAGfC1ieRAKyFg24FKjLJK2uDgA873uq\"), PK(\"9fdVP2jca1e5nCTT6q9ijZLssGj6v4juY8gEAxUhp7YTuSsLspS\"), PK(\"9gAKeRu1W4Dh6adWXnnYmfqjCTnxnSMtym2LPPMPErCkusCd6F3\"), PK(\"9gmNsqrqdSppLUBqg2UzREmmivgqh1r3jmNcLAc53hk3YCvAGWE\") ) ) } This an example 3-out-of-5 threshold signature which can be compiled to a P2S address sending ergs to resulting address (protected by the threshold sig) Here is a good intro to making a signature","title":"Sigma protocols"},{"location":"dev/scs/sigma/#use-cases","text":"When combined with a blockchain, these composable proofs enable some very powerful use cases. The logic for proofs can include conditions based on blockchain state. For example, \u2018If the deadline block height has been reached, Alice can provide knowledge of a secret key for a refund. OR a ring signature from Alice and Bob is required to spend coins.\u2019 Or \u2018If this account holds a minimum of 100 ERG, Alice OR Bob can remove funds above that amount.\u2019 It\u2019s relatively easy to swap coins or custom tokens trustlessly across any Bitcoin-like blockchains. But beyond that, Ergo allows partial swaps. Just like on a regular exchange, orders can be partially filled, if that\u2019s what the trader wants. This means it\u2019s possible to build a fully-fledged decentralised exchange (DEX) that enables cross-chain trading: a totally trustless version of existing crypto exchanges. There\u2019s no need for any gateways, token wrapping or other potential bottlenecks or points of failure.","title":"Use Cases"},{"location":"dev/scs/sigma/#optional-privacy","text":"A Rich smart-contract language and simplicity are the priority in Ergo, and smart-contracts make privacy a lot harder. There are plenty of reasons to want optional privacy - transparent ledgers are a feature for many use-cases. e.g. charities that want everyone to have full access to the flow of funds. The ability to operate with privacy or with transparency is a feature. There's also strong arguments for optional privacy for adoption and regulation. ErgoMixer is non-interactive so works with the blockchain alone, no off-chain coordination with others (and trusted coordinator) needed. In future, privacy by default could be enabled for every transaction in Ergo. Maybe the community will do it someday or maybe integrating mix-nets and on other novel ideas on the application layer will be sufficient. \"With non-optional privacy you can't have (efficient) powerful contracts. Even more, even for simple payments formalizing (in order to minimize with guarantee) leakage is hard, for arbitrary contracts not feasible at all I guess\"","title":"'Optional' Privacy?"},{"location":"dev/scs/sigma/#ergomixer","text":"ErgoMixer is a state of the art (and worlds first) non-interactive and non-custodial token mixer and the first real implementation of Sigma protocols on Ergo. Mac/Windows applications are available! . Check out this page on ergonaut.space for more information including research papers / presentations; and these discussions in Discords. Tornado Cash vs ErgoMixer anon2020s explaining the how ErgoMixer retains its anonymity","title":"ErgoMixer"},{"location":"dev/scs/sigma/#lots-more-applications-possible-many-still-undiscovered","text":"A Simpler Collective-Spending Approach for Everyone! trustless prediction markets and on-chain insurance Trustless LETS \"I think global mutual credit system (trustless, so collateralized) can be perfectly combined with ErgoFund, so funds collected can be used to open credit-line basically to spend money for services in the mutual credit system\" \"So at the same time off the peg ring and threshold signatures, where from k-out-of-n signatures, it could not be concluded which k signers were real, so you have i think first zero knowledge multisig with no signers disclosure in cryptocurrency at the same time(on app level).\" \"You have to look more into the base at the moment to see future possibilities, at the base you have multisig with no signers disclosure, then new features like covert address, multi hop withdrawals discovered slowly thanks to contracts possibilities, mixer can be just run locally at the same time. You can build Monero on top of Ergo, will it have better privacy guarantees? it is yet to be discovered. But you can think of private order books for example at the same time, similar to a simple and interesting payment network. I think that combining these things with NYM in the future can have more sense for scalable privacy.\"","title":"Lots more applications possible, many still undiscovered!"},{"location":"dev/stack/appkit/","text":"With thanks to Robert Kornacki and Denys Zadorozhnyi . Ergo Appkit is a library for polyglot development of Ergo Applications based on GraalVM . GraalVM has many great use cases . Expanding on that, in this article we will go through some of the Appkit features inherited from GraalVM and take you step-by-step in learning how to take advantage of them. Example Scenario 1. Java Ergo App Development 2. Low-footprint, Fast-startup Ergo Applications 3. Develop Ergo Applications in JavaScript, Python, Ruby JavaScript Python Ruby 4. Ergo Native Shared Libraries 5. Debugging Your Polyglot Ergo Application Conclusions References Example Scenario We will create a simple console application (called FreezeCoin ) in Java which uses the Appkit library. By using Appkit, we will be able to easily send a new transaction to an Ergo node programatically. The transaction will transfer a given amount of Erg into a new box protected by the following Ergo contract written in ErgoScript (see this introduction and more advanced examples to learn more about ErgoScript). // Freezer Contract { // Parameters // freezeDeadline: Int - some future block number after which the box can be spent // ownerPk: SigmaProp - public key of the new box owner sigmaProp(HEIGHT > freezeDeadline) && ownerPk } In short, a box (and therefore the funds within the box) are locked under a contract (or script) on the Ergo blockchain. In order for the box to be spent, the contract must evaluate to true. Thus the individual who wishes to spend the box must ensure that the contract evaluates to true based off of the encoded logic within it. Our Freezer contract above checks the following conditions before allowing the box to be spent: The current block number of the Ergo blockchain (aka blockchain HEIGHT) is greater than the specified deadline The spending transaction must be signed by the owner of the secret key corresponding to the ownerPk public key. The first condition forbids anyone from spending the box before the Ergo blockchain grows to the given height. Because new blocks on the blockchain are mined approximately every 2 minutes on average, using the current blockchain height it is easy to define any duration of delay we wish such as 1 day, 1 week, or 1 month. (i.e. (60 / 2) * 24 * 7 = 5040, which is the # of blocks per week) . We will now be going in depth on how we can take this Freezer Contract and integrate it with the Apkit library in order to create the FreezeCoin console application so that anyone and everyone can choose to freeze their coins if they so wish. (Granted, this contract/dApp is not actually useful, however it is an effective simple example for displaying how this technology stack works so that you yourself can build useful dApps down the line.) 1. Java Ergo App Development Appkit aims to provide a set of interfaces which can be used idiomatically in Java. You will feel right at home using Appkit if you are a Java veteran. Please follow the setup instructions for GraalVM and Appkit if you wish to reproduce the examples below. To use Appkit in our Java implementation of FreezeCoin we must add the following dependency in the gradle file dependencies { implementation(\"org.ergoplatform\", \"ergo-appkit_2.12\", \"3.1.0\", \"compile\") ... } Furthermore at runtime Appkit/our application needs to connect with an Ergo Node via REST API. Often, the node will be running locally and made available at http://localhost:9052/ . This is the standard scenario for anyone who has set up a full-node by following these instructions and is using the default configuration. Henceforth we will assume that you have setup and started your Ergo Node so that it is available for testing of the application. Next, our application will need to know how to be able to a connect to our local running node, in addition to other various settings in order to function properly. We will use a json file with the following configuration parameters which our FreezeCoin app will load at startup. freeze_coin_config.json: { \"node\": { \"nodeApi\": { \"apiUrl\": \"http://localhost:9052/\", \"apiKey\": \"put your secret apiKey generated during node setup here\" }, \"wallet\": { \"mnemonic\": \"the mnemonic key used to initialize or restore the wallet of the node\", \"password\": \"the password you chose to protect the wallet\", \"mnemonicPassword\": \"the password you chose to protect the mnemonic\" }, \"networkType\": \"TESTNET\" }, \"parameters\": { \"newBoxSpendingDelay\": \"30\", \"ownerAddress\": \"3WzR39tWQ5cxxWWX6ys7wNdJKLijPeyaKgx72uqg9FJRBCdZPovL\" } } Here apiKey is the secret key required for API authentication which can be acquired as described here . Your mnemonic is the secret phrase obtained during setup of a new wallet . How our app will work is that the user will launch it from the command line and provide one argument. This argument is the amount of value (in NanoErgs) which they wish to freeze/lock under the Freezer contract which we wrote above. Our first step for our FreezeCoin app will be to read the configuration json file we just created and to accept the command line argument from the user: public static void main(String[] args) { long amountToSend = Long.parseLong(args[0]); // positive value in NanoErg ErgoToolConfig conf = ErgoToolConfig.load(\"freeze_coin_config.json\"); // the rest of the code discussed below ... } With these acquired, we can now obtain the spending delay and the owner address which were defined in the json config file. int newBoxSpendingDelay = Integer.parseInt(conf.getParameters().get(\"newBoxSpendingDelay\")); Address ownerAddress = Address.create(conf.getParameters().get(\"ownerAddress\")); Next we need to connect to the running Ergo node from our Java application so that we can use the data we just parsed and post something on-chain. This is done by creating an ErgoClient instance which uses our pre-defined values for our node from the json config file as well. ErgoNodeConfig nodeConf = conf.getNode(); ErgoClient ergoClient = RestApiErgoClient.create(nodeConf); Now that we have an instance of ErgoClient , we can execute any block of code and have access to the current blockchain context. String txJson = ergoClient.execute((BlockchainContext ctx) -> { // use ctx here to create and sign a new transaction // then send it to the node }); The lambda passed to execute is called when the current blockchain context is loaded from the Ergo node. In this lambda we shall put our application logic. First we start with some auxiliary steps. // access the wallet embedded in the Ergo node // (using the wallet specified via mnemonic we put in freeze_coin_config.json) ErgoWallet wallet = ctx.getWallet(); // calculate total amount of NanoErgs we need to send to the new box // including paying for transaction fees long totalToSpend = amountToSend + Parameters.MinFee; // request for unspent boxes that cover the required amount of NanoErgs from the wallet Optional<List<InputBox>> boxes = wallet.getUnspentBoxes(totalToSpend); if (!boxes.isPresent()) throw new ErgoClientException( \"Not enough coins in your specified wallet to pay \" + totalToSpend, null); // create a \"prover\", which is a special object that will be used for signing the transaction // the prover should be configured with your wallet's secrets, which are necessary to generate signatures (aka proofs) ErgoProver prover = ctx.newProverBuilder() .withMnemonic( nodeConf.getWallet().getMnemonic(), nodeConf.getWallet().getPassword()) .build(); At this point we have the input boxes chosen for our spending transaction, but we now need to create an output box with the specified amountToSend and locked under the Freezer contract. // the only way to create a transaction is using the tx builder obtained from the context // the builder uses the context to access necessary blockchain data. UnsignedTransactionBuilder txB = ctx.newTxBuilder(); // create new box using new builder obtained from the transaction builder // in this case we compile a new ErgoContract from the Freezer ErgoScript code OutBox newBox = txB.outBoxBuilder() .value(amountToPay) .contract(ctx.compileContract( ConstantsBuilder.create() .item(\"freezeDeadline\", ctx.getHeight() + newBoxSpendingDelay) .item(\"ownerPk\", ownerAddress.getPublicKey()) .build(), \"{ sigmaProp(HEIGHT > freezeDeadline) && ownerPk }\")) .build(); Note, in order to compile ErgoContract from the Freezer script source code the compileContract method requires that we provide values for named constants which are used within the script. If no such constants are used, then ConstantsBuilder.empty() can be passed to it. In this case we pass the public key of the new box owner into the ownerPk placeholder in the script. To repeat from earlier, this means that the box can only be spent by the owner of the corresponding secret key. Next, we create an unsigned transaction using all the data we've put together thus far. // provide the transaction builder with which boxes we are going to spend, which outputs // should be created, the total transaction fees, and the address for change to be sent to UnsignedTransaction tx = txB.boxesToSpend(boxes.get()) .outputs(newBox) .fee(Parameters.MinFee) .sendChangeTo(prover.getP2PKAddress()) .build(); And finally we: Use the prover to sign the built transaction Thus obtain a SignedTransaction instance Use the blockchain context to send the signed transaction to the Ergo node. The resulting txId can be used to refer to this transaction later however we do not use it here. SignedTransaction signed = prover.sign(tx); String txId = ctx.sendTransaction(signed); return signed.toJson(true); As you may have noticed, for our final step we show off that it is possible to serialize the signed transaction into a Json string with pretty printing turned on. Look at the full source code of the example for more details and for using it as a template in your own application. Now with all of the code set in stone, we can run our FreezeCoin application using the following steps (assuming you are in the directory where you cloned ergo-appkit-examples ). $ pwd the/directory/you/cloned/ergo-appkit-examples $ ./gradlew clean shadowJar This will assemble the build/libs/appkit-examples-3.1.0-all.jar file containing our FreezeCoin Java application and all of its dependencies in a single fat jar. Note, this step has to be repeated after any changes are made to the Java source code of our application. Having created our application, we can now use our FreezeCoin app: $ java -cp build/libs/appkit-examples-3.1.0-all.jar \\ org.ergoplatform.appkit.examples.FreezeCoin 1000000000 You will get something along the lines of this output in the console . And with that your transaction was accepted by the Ergo node and broadcast into the network where it shall lay await in the transaction pool to be added to a block. Once a miner selects and adds it to a block, your coins will be officially \"frozen\" within the newly created box based off of the values you provided to the FreezeCoin application. The example assumes the Ergo node (and the embedded wallet) is owned by the FreezeCoin user. However this is not strictly required and the Appkit interfaces can be used to create and send new transactions using arbitrary public Ergo nodes. 2. Low-footprint, Fast-startup Ergo Applications As you may know, using Java for short-running processes has a lot of drawbacks. Applications tend to suffer from long startup times and relatively high memory usage. Let's run FreezeCoin using the time command to get the real (wall-clock elapsed time) it takes the entire program to run from start to finish. We use the -l flag to print the memory usage as well. $ /usr/bin/time -l java -cp build/libs/appkit-examples-3.1.0-all.jar \\ org.ergoplatform.appkit.examples.FreezeCoin 1000000000 ... 4.97 real 8.41 user 0.69 sys 513703936 maximum resident set size 0 average shared memory size 0 average unshared data size 0 average unshared stack size 125010 page reclaims 1216 page faults 0 swaps 0 block input operations 0 block output operations 13 messages sent 86 messages received 1 signals received 2384 voluntary context switches 17409 involuntary context switches As seen above, this tiny application took 2 parallel threads almost 4 seconds to run. Most of that time can be attributed to the JVM startup and the background JIT compiler running. This is quite sub-par performance, and we know we can do a lot better. Luckily, GraalVM provides us with the perfect solution. We can solve this inherent issue with the JVM by compiling the Java code ahead-of-time into a native executable image via GraalVM. This skips over the need to use the Java just-in-time compiler at runtime. The experience for us (the developer using GraalVM) is quite similar to a conventional compiler like gcc. Note, we may need to run ./gradlew clean shadowJar first. $ ./gradlew clean shadowJar $ native-image --no-server \\ -cp build/libs/appkit-examples-3.1.0-all.jar\\ --report-unsupported-elements-at-runtime\\ --no-fallback -H:+TraceClassInitialization -H:+ReportExceptionStackTraces\\ -H:+AddAllCharsets -H:+AllowVMInspection -H:-RuntimeAssertions\\ --allow-incomplete-classpath \\ --enable-url-protocols=http,https org.ergoplatform.appkit.examples.FreezeCoin freezecoin [freezecoin:3133] classlist: 35,217.78 ms [freezecoin:3133] (cap): 6,063.07 ms [freezecoin:3133] setup: 8,268.99 ms [freezecoin:3133] (typeflow): 60,238.25 ms [freezecoin:3133] (objects): 33,009.06 ms [freezecoin:3133] (features): 4,796.86 ms [freezecoin:3133] analysis: 102,876.01 ms [freezecoin:3133] (clinit): 11,642.43 ms [freezecoin:3133] universe: 13,718.96 ms [freezecoin:3133] (parse): 5,053.18 ms [freezecoin:3133] (inline): 18,317.24 ms [freezecoin:3133] (compile): 44,806.82 ms [freezecoin:3133] compile: 72,288.24 ms [freezecoin:3133] image: 7,955.29 ms [freezecoin:3133] write: 2,872.25 ms [freezecoin:3133] [total]: 243,813.30 ms The simple command above produces a complete native executable called freezecoin . To emphasize, this executable isn\u2019t a mere launcher for the JVM. In fact it doesn\u2019t link to the JVM or bundle the JVM in any way. native-image compiles the FreezeCoin code, as well as any Java libraries it depends on, all the way down to simple machine code. If we look at the libraries which freezecoin uses you can see that it only uses standard system libraries. Thus, we can move just this one executable to another system which doesn't have a JVM installed and it will run there without issue. $ otool -L freezecoin # ldd freezecoin on Linux freezecoin: /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4) /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1455.12.0) /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11) If we time this new freezecoin executable, we can see that it starts approximately 8x faster, and uses around 6x less memory. What this means is that you don\u2019t feel that palpable pause you always get when running a short-running program with the JVM. $ DYLD_LIBRARY_PATH=$GRAAL_HOME/jre/lib /usr/bin/time -l ./freezecoin 1800000000 0.43 real 0.15 user 0.03 sys 81289216 maximum resident set size 0 average shared memory size 0 average unshared data size 0 average unshared stack size 20079 page reclaims 0 page faults 0 swaps 0 block input operations 0 block output operations 13 messages sent 86 messages received 0 signals received 11 voluntary context switches 138 involuntary context switches This is just one of the great benefits of GraalVM which we get to take advantage of with Appkit. 3. Develop Ergo Applications in JavaScript, Python, Ruby GraalVM supports so called polyglot programming in which different components of an application can be developed using the most suitable language and then seamlessly combine together at runtime. In this way a unique library written in say Java can be used in a node.js application written in JavaScript for example. To support polyglot programming GraalVM platform has it's own high performance implementations of popular languages. We are going to take advantage of this for our FreezeCoin example project to show you how easy this is to use your preferred language. Before running the examples below (in JavaScript, Python and Ruby) please make sure that you have the Java version of FreezeCoin working locally in order to ensure everything is set up correctly. JavaScript GraalVM can run JavaScript and Node.js applications out of the box. It is compatible with the ECMAScript 2019 specification . Additionally, js and node launchers accept special --jvm and --polyglot command line options which allow JS scripts to access Java objects and classes. Given that being the case, a JS implementation of FreezeCoin can be easily written using the Appkit API interface. Please see the full source code of FreezeCoin JS implementation for details. The following command use node launcher to execute FreezeCoin.js script. $ node --jvm --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\ js-examples/FreezeCoin.js 1000000000 Note, the paths in the command are relative to the root of ergo-appkit-examples project directory. Python GraalVM can run Python scripts , though the Python implementation is still experimental (see also compatibility section for details). Python example of FreezeCoin can be executed using the following command $ graalpython --jvm --polyglot --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\ python-examples/FreezeCoin.py 1900000000 Ruby GraalVM can run Ruby scripts using TruffleRuby implementation, which is however still experimental (see also compatibility section for details). TruffleRuby aims to be fully compatible with the standard implementation of Ruby, MRI, version 2.6.2 Ruby example of FreezeCoin can be executed using the following command $ truffleruby --polyglot --jvm --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\ ruby-examples/FreezeCoin.rb 1900000000 4. Ergo Native Shared Libraries Another great benefit of GraalVM is that we can compile Java classes down into a native shared library instead of an executable. To do this we declare one or more static methods as the @CEntryPoint . public class FreezeCoin { ... /** * Entry point callable from C which wraps {@link FreezeCoin#sendTx} */ @CEntryPoint(name = \"sendTx\") public static void sendTxEntryPoint( IsolateThread thread, SignedWord amountToSendW, CCharPointer configFileNameC, CCharPointer resBuffer, UnsignedWord bufferSize) throws FileNotFoundException { long amountToSend = amountToSendW.rawValue(); // Convert the C strings to the target Java strings. String configFileName = CTypeConversion.toJavaString(configFileNameC); String txJson = sendTx(amountToSend, configFileName); // put resulting string into provided buffer CTypeConversion.toCString(txJson, resBuffer, bufferSize); } ... } We can then compile down to a shared library and an automatically generated header file. Notice the use of the --shared option. $ native-image --no-server \\ -cp build/libs/appkit-examples-3.1.0-all.jar\\ --report-unsupported-elements-at-runtime\\ --no-fallback -H:+TraceClassInitialization -H:+ReportExceptionStackTraces\\ -H:+AddAllCharsets -H:+AllowVMInspection -H:-RuntimeAssertions\\ --allow-incomplete-classpath \\ --enable-url-protocols=http,https --shared -H:Name=libfreezecoin -H:Path=c-examples $ otool -L c-examples/libfreezecoin.dylib c-examples/libfreezecoin.dylib: .../c-examples/libfreezecoin.dylib (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4) /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1455.12.0) /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11) Now we have the ability to write a C program which uses the library. The interface to our native library does have a bit of boilerplate (because the VM needs to manage a heap, threads, a garbage collector and more), and thus we need to create an instance and provide it our main thread. #include <stdlib.h> #include <stdio.h> #include <libfreezecoin.h> int main(int argc, char **argv) { graal_isolate_t *isolate = NULL; graal_isolatethread_t *thread = NULL; if (graal_create_isolate(NULL, &isolate, &thread) != 0) { fprintf(stderr, \"graal_create_isolate error\\n\"); return 1; } char * configFileName = \"freeze_coin_config.json\"; // get amountToSend from cmd args and call transaction creation long amountToSend = atol(argv[1]); char result[1024 * 16]; sendTx(thread, amountToSend, configFileName, result, sizeof(result)); // print out serialized result printf(\"%s\\n\", result); if (graal_detach_thread(thread) != 0) { fprintf(stderr, \"graal_detach_thread error\\n\"); return 1; } return 0; } We can compile this with our standard system tools and easily run our executable (set LD_LIBRARY_PATH=. on Linux). $ clang -Ic-examples -Lc-examples -lfreezecoin c-examples/freezecoin.c -o call_freezecoin $ otool -L call_freezecoin $ DYLD_LIBRARY_PATH=$GRAAL_HOME/jre/lib ./call_freezecoin 1000000000 5. Debugging Your Polyglot Ergo Application You can debug JS, Python and Ruby in IntelliJ, but if for some reason this doesn't work for you or fit with your preferred editor, GraalVM offers another option. All of the GraalVM languages (except for Java) are implemented using the common Truffle framework . Truffle allows for tooling like debuggers to be implemented once and be available for all supported languages. As such we can run our program with the flag --inspect which will give us a link to open in Chrome and will pause the program in the debugger. $ ruby --polyglot --jvm --inspect --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\ ruby-examples/FreezeCoin.rb 1900000000 Debugger listening on port 9229. To start debugging, open the following URL in Chrome: chrome-devtools://devtools/bundled/js_app.html?ws=127.0.0.1:9229/30c7da1e-7558a47d09b ... From here we can set breakpoints and continue execution. When it breaks we\u2019ll see values of the variables, can continue again until the next breakpoint, and do everything we've come to expect from debuggers. Conclusions And with all of that said and done, we see just how easy it is to use Appkit to develop Ergo Applications. Appkit relies on the same exact core libraries which were used in implementing the Ergo consensus protocol. These libraries include the ErgoScript compiler, cryptography, byte code interpreter, data serialisers and the other core components. Using GraalVM we are able to reuse these tried and tested components in different application contexts without any modification or rewriting them ourselves. No matter if you are using Java, JavaScript, Python or Ruby, you can take advantage of Appkit with GraalVM to drastically simplify the process of interacting with the Ergo blockchain while creating native-running (d)Apps. Stay tuned. In future posts we will introduce you to other interesting potential applications powered by Appkit. References Ergo Site Ergo Sources Ergo Appkit Ergo Appkit Examples GraalVM","title":"AppKit"},{"location":"dev/stack/appkit/#example-scenario","text":"We will create a simple console application (called FreezeCoin ) in Java which uses the Appkit library. By using Appkit, we will be able to easily send a new transaction to an Ergo node programatically. The transaction will transfer a given amount of Erg into a new box protected by the following Ergo contract written in ErgoScript (see this introduction and more advanced examples to learn more about ErgoScript). // Freezer Contract { // Parameters // freezeDeadline: Int - some future block number after which the box can be spent // ownerPk: SigmaProp - public key of the new box owner sigmaProp(HEIGHT > freezeDeadline) && ownerPk } In short, a box (and therefore the funds within the box) are locked under a contract (or script) on the Ergo blockchain. In order for the box to be spent, the contract must evaluate to true. Thus the individual who wishes to spend the box must ensure that the contract evaluates to true based off of the encoded logic within it. Our Freezer contract above checks the following conditions before allowing the box to be spent: The current block number of the Ergo blockchain (aka blockchain HEIGHT) is greater than the specified deadline The spending transaction must be signed by the owner of the secret key corresponding to the ownerPk public key. The first condition forbids anyone from spending the box before the Ergo blockchain grows to the given height. Because new blocks on the blockchain are mined approximately every 2 minutes on average, using the current blockchain height it is easy to define any duration of delay we wish such as 1 day, 1 week, or 1 month. (i.e. (60 / 2) * 24 * 7 = 5040, which is the # of blocks per week) . We will now be going in depth on how we can take this Freezer Contract and integrate it with the Apkit library in order to create the FreezeCoin console application so that anyone and everyone can choose to freeze their coins if they so wish. (Granted, this contract/dApp is not actually useful, however it is an effective simple example for displaying how this technology stack works so that you yourself can build useful dApps down the line.)","title":"Example Scenario"},{"location":"dev/stack/appkit/#1-java-ergo-app-development","text":"Appkit aims to provide a set of interfaces which can be used idiomatically in Java. You will feel right at home using Appkit if you are a Java veteran. Please follow the setup instructions for GraalVM and Appkit if you wish to reproduce the examples below. To use Appkit in our Java implementation of FreezeCoin we must add the following dependency in the gradle file dependencies { implementation(\"org.ergoplatform\", \"ergo-appkit_2.12\", \"3.1.0\", \"compile\") ... } Furthermore at runtime Appkit/our application needs to connect with an Ergo Node via REST API. Often, the node will be running locally and made available at http://localhost:9052/ . This is the standard scenario for anyone who has set up a full-node by following these instructions and is using the default configuration. Henceforth we will assume that you have setup and started your Ergo Node so that it is available for testing of the application. Next, our application will need to know how to be able to a connect to our local running node, in addition to other various settings in order to function properly. We will use a json file with the following configuration parameters which our FreezeCoin app will load at startup. freeze_coin_config.json: { \"node\": { \"nodeApi\": { \"apiUrl\": \"http://localhost:9052/\", \"apiKey\": \"put your secret apiKey generated during node setup here\" }, \"wallet\": { \"mnemonic\": \"the mnemonic key used to initialize or restore the wallet of the node\", \"password\": \"the password you chose to protect the wallet\", \"mnemonicPassword\": \"the password you chose to protect the mnemonic\" }, \"networkType\": \"TESTNET\" }, \"parameters\": { \"newBoxSpendingDelay\": \"30\", \"ownerAddress\": \"3WzR39tWQ5cxxWWX6ys7wNdJKLijPeyaKgx72uqg9FJRBCdZPovL\" } } Here apiKey is the secret key required for API authentication which can be acquired as described here . Your mnemonic is the secret phrase obtained during setup of a new wallet . How our app will work is that the user will launch it from the command line and provide one argument. This argument is the amount of value (in NanoErgs) which they wish to freeze/lock under the Freezer contract which we wrote above. Our first step for our FreezeCoin app will be to read the configuration json file we just created and to accept the command line argument from the user: public static void main(String[] args) { long amountToSend = Long.parseLong(args[0]); // positive value in NanoErg ErgoToolConfig conf = ErgoToolConfig.load(\"freeze_coin_config.json\"); // the rest of the code discussed below ... } With these acquired, we can now obtain the spending delay and the owner address which were defined in the json config file. int newBoxSpendingDelay = Integer.parseInt(conf.getParameters().get(\"newBoxSpendingDelay\")); Address ownerAddress = Address.create(conf.getParameters().get(\"ownerAddress\")); Next we need to connect to the running Ergo node from our Java application so that we can use the data we just parsed and post something on-chain. This is done by creating an ErgoClient instance which uses our pre-defined values for our node from the json config file as well. ErgoNodeConfig nodeConf = conf.getNode(); ErgoClient ergoClient = RestApiErgoClient.create(nodeConf); Now that we have an instance of ErgoClient , we can execute any block of code and have access to the current blockchain context. String txJson = ergoClient.execute((BlockchainContext ctx) -> { // use ctx here to create and sign a new transaction // then send it to the node }); The lambda passed to execute is called when the current blockchain context is loaded from the Ergo node. In this lambda we shall put our application logic. First we start with some auxiliary steps. // access the wallet embedded in the Ergo node // (using the wallet specified via mnemonic we put in freeze_coin_config.json) ErgoWallet wallet = ctx.getWallet(); // calculate total amount of NanoErgs we need to send to the new box // including paying for transaction fees long totalToSpend = amountToSend + Parameters.MinFee; // request for unspent boxes that cover the required amount of NanoErgs from the wallet Optional<List<InputBox>> boxes = wallet.getUnspentBoxes(totalToSpend); if (!boxes.isPresent()) throw new ErgoClientException( \"Not enough coins in your specified wallet to pay \" + totalToSpend, null); // create a \"prover\", which is a special object that will be used for signing the transaction // the prover should be configured with your wallet's secrets, which are necessary to generate signatures (aka proofs) ErgoProver prover = ctx.newProverBuilder() .withMnemonic( nodeConf.getWallet().getMnemonic(), nodeConf.getWallet().getPassword()) .build(); At this point we have the input boxes chosen for our spending transaction, but we now need to create an output box with the specified amountToSend and locked under the Freezer contract. // the only way to create a transaction is using the tx builder obtained from the context // the builder uses the context to access necessary blockchain data. UnsignedTransactionBuilder txB = ctx.newTxBuilder(); // create new box using new builder obtained from the transaction builder // in this case we compile a new ErgoContract from the Freezer ErgoScript code OutBox newBox = txB.outBoxBuilder() .value(amountToPay) .contract(ctx.compileContract( ConstantsBuilder.create() .item(\"freezeDeadline\", ctx.getHeight() + newBoxSpendingDelay) .item(\"ownerPk\", ownerAddress.getPublicKey()) .build(), \"{ sigmaProp(HEIGHT > freezeDeadline) && ownerPk }\")) .build(); Note, in order to compile ErgoContract from the Freezer script source code the compileContract method requires that we provide values for named constants which are used within the script. If no such constants are used, then ConstantsBuilder.empty() can be passed to it. In this case we pass the public key of the new box owner into the ownerPk placeholder in the script. To repeat from earlier, this means that the box can only be spent by the owner of the corresponding secret key. Next, we create an unsigned transaction using all the data we've put together thus far. // provide the transaction builder with which boxes we are going to spend, which outputs // should be created, the total transaction fees, and the address for change to be sent to UnsignedTransaction tx = txB.boxesToSpend(boxes.get()) .outputs(newBox) .fee(Parameters.MinFee) .sendChangeTo(prover.getP2PKAddress()) .build(); And finally we: Use the prover to sign the built transaction Thus obtain a SignedTransaction instance Use the blockchain context to send the signed transaction to the Ergo node. The resulting txId can be used to refer to this transaction later however we do not use it here. SignedTransaction signed = prover.sign(tx); String txId = ctx.sendTransaction(signed); return signed.toJson(true); As you may have noticed, for our final step we show off that it is possible to serialize the signed transaction into a Json string with pretty printing turned on. Look at the full source code of the example for more details and for using it as a template in your own application. Now with all of the code set in stone, we can run our FreezeCoin application using the following steps (assuming you are in the directory where you cloned ergo-appkit-examples ). $ pwd the/directory/you/cloned/ergo-appkit-examples $ ./gradlew clean shadowJar This will assemble the build/libs/appkit-examples-3.1.0-all.jar file containing our FreezeCoin Java application and all of its dependencies in a single fat jar. Note, this step has to be repeated after any changes are made to the Java source code of our application. Having created our application, we can now use our FreezeCoin app: $ java -cp build/libs/appkit-examples-3.1.0-all.jar \\ org.ergoplatform.appkit.examples.FreezeCoin 1000000000 You will get something along the lines of this output in the console . And with that your transaction was accepted by the Ergo node and broadcast into the network where it shall lay await in the transaction pool to be added to a block. Once a miner selects and adds it to a block, your coins will be officially \"frozen\" within the newly created box based off of the values you provided to the FreezeCoin application. The example assumes the Ergo node (and the embedded wallet) is owned by the FreezeCoin user. However this is not strictly required and the Appkit interfaces can be used to create and send new transactions using arbitrary public Ergo nodes.","title":"1. Java Ergo App Development"},{"location":"dev/stack/appkit/#2-low-footprint-fast-startup-ergo-applications","text":"As you may know, using Java for short-running processes has a lot of drawbacks. Applications tend to suffer from long startup times and relatively high memory usage. Let's run FreezeCoin using the time command to get the real (wall-clock elapsed time) it takes the entire program to run from start to finish. We use the -l flag to print the memory usage as well. $ /usr/bin/time -l java -cp build/libs/appkit-examples-3.1.0-all.jar \\ org.ergoplatform.appkit.examples.FreezeCoin 1000000000 ... 4.97 real 8.41 user 0.69 sys 513703936 maximum resident set size 0 average shared memory size 0 average unshared data size 0 average unshared stack size 125010 page reclaims 1216 page faults 0 swaps 0 block input operations 0 block output operations 13 messages sent 86 messages received 1 signals received 2384 voluntary context switches 17409 involuntary context switches As seen above, this tiny application took 2 parallel threads almost 4 seconds to run. Most of that time can be attributed to the JVM startup and the background JIT compiler running. This is quite sub-par performance, and we know we can do a lot better. Luckily, GraalVM provides us with the perfect solution. We can solve this inherent issue with the JVM by compiling the Java code ahead-of-time into a native executable image via GraalVM. This skips over the need to use the Java just-in-time compiler at runtime. The experience for us (the developer using GraalVM) is quite similar to a conventional compiler like gcc. Note, we may need to run ./gradlew clean shadowJar first. $ ./gradlew clean shadowJar $ native-image --no-server \\ -cp build/libs/appkit-examples-3.1.0-all.jar\\ --report-unsupported-elements-at-runtime\\ --no-fallback -H:+TraceClassInitialization -H:+ReportExceptionStackTraces\\ -H:+AddAllCharsets -H:+AllowVMInspection -H:-RuntimeAssertions\\ --allow-incomplete-classpath \\ --enable-url-protocols=http,https org.ergoplatform.appkit.examples.FreezeCoin freezecoin [freezecoin:3133] classlist: 35,217.78 ms [freezecoin:3133] (cap): 6,063.07 ms [freezecoin:3133] setup: 8,268.99 ms [freezecoin:3133] (typeflow): 60,238.25 ms [freezecoin:3133] (objects): 33,009.06 ms [freezecoin:3133] (features): 4,796.86 ms [freezecoin:3133] analysis: 102,876.01 ms [freezecoin:3133] (clinit): 11,642.43 ms [freezecoin:3133] universe: 13,718.96 ms [freezecoin:3133] (parse): 5,053.18 ms [freezecoin:3133] (inline): 18,317.24 ms [freezecoin:3133] (compile): 44,806.82 ms [freezecoin:3133] compile: 72,288.24 ms [freezecoin:3133] image: 7,955.29 ms [freezecoin:3133] write: 2,872.25 ms [freezecoin:3133] [total]: 243,813.30 ms The simple command above produces a complete native executable called freezecoin . To emphasize, this executable isn\u2019t a mere launcher for the JVM. In fact it doesn\u2019t link to the JVM or bundle the JVM in any way. native-image compiles the FreezeCoin code, as well as any Java libraries it depends on, all the way down to simple machine code. If we look at the libraries which freezecoin uses you can see that it only uses standard system libraries. Thus, we can move just this one executable to another system which doesn't have a JVM installed and it will run there without issue. $ otool -L freezecoin # ldd freezecoin on Linux freezecoin: /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4) /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1455.12.0) /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11) If we time this new freezecoin executable, we can see that it starts approximately 8x faster, and uses around 6x less memory. What this means is that you don\u2019t feel that palpable pause you always get when running a short-running program with the JVM. $ DYLD_LIBRARY_PATH=$GRAAL_HOME/jre/lib /usr/bin/time -l ./freezecoin 1800000000 0.43 real 0.15 user 0.03 sys 81289216 maximum resident set size 0 average shared memory size 0 average unshared data size 0 average unshared stack size 20079 page reclaims 0 page faults 0 swaps 0 block input operations 0 block output operations 13 messages sent 86 messages received 0 signals received 11 voluntary context switches 138 involuntary context switches This is just one of the great benefits of GraalVM which we get to take advantage of with Appkit.","title":"2. Low-footprint, Fast-startup Ergo Applications"},{"location":"dev/stack/appkit/#3-develop-ergo-applications-in-javascript-python-ruby","text":"GraalVM supports so called polyglot programming in which different components of an application can be developed using the most suitable language and then seamlessly combine together at runtime. In this way a unique library written in say Java can be used in a node.js application written in JavaScript for example. To support polyglot programming GraalVM platform has it's own high performance implementations of popular languages. We are going to take advantage of this for our FreezeCoin example project to show you how easy this is to use your preferred language. Before running the examples below (in JavaScript, Python and Ruby) please make sure that you have the Java version of FreezeCoin working locally in order to ensure everything is set up correctly.","title":"3. Develop Ergo Applications in JavaScript, Python, Ruby"},{"location":"dev/stack/appkit/#javascript","text":"GraalVM can run JavaScript and Node.js applications out of the box. It is compatible with the ECMAScript 2019 specification . Additionally, js and node launchers accept special --jvm and --polyglot command line options which allow JS scripts to access Java objects and classes. Given that being the case, a JS implementation of FreezeCoin can be easily written using the Appkit API interface. Please see the full source code of FreezeCoin JS implementation for details. The following command use node launcher to execute FreezeCoin.js script. $ node --jvm --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\ js-examples/FreezeCoin.js 1000000000 Note, the paths in the command are relative to the root of ergo-appkit-examples project directory.","title":"JavaScript"},{"location":"dev/stack/appkit/#python","text":"GraalVM can run Python scripts , though the Python implementation is still experimental (see also compatibility section for details). Python example of FreezeCoin can be executed using the following command $ graalpython --jvm --polyglot --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\ python-examples/FreezeCoin.py 1900000000","title":"Python"},{"location":"dev/stack/appkit/#ruby","text":"GraalVM can run Ruby scripts using TruffleRuby implementation, which is however still experimental (see also compatibility section for details). TruffleRuby aims to be fully compatible with the standard implementation of Ruby, MRI, version 2.6.2 Ruby example of FreezeCoin can be executed using the following command $ truffleruby --polyglot --jvm --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\ ruby-examples/FreezeCoin.rb 1900000000","title":"Ruby"},{"location":"dev/stack/appkit/#4-ergo-native-shared-libraries","text":"Another great benefit of GraalVM is that we can compile Java classes down into a native shared library instead of an executable. To do this we declare one or more static methods as the @CEntryPoint . public class FreezeCoin { ... /** * Entry point callable from C which wraps {@link FreezeCoin#sendTx} */ @CEntryPoint(name = \"sendTx\") public static void sendTxEntryPoint( IsolateThread thread, SignedWord amountToSendW, CCharPointer configFileNameC, CCharPointer resBuffer, UnsignedWord bufferSize) throws FileNotFoundException { long amountToSend = amountToSendW.rawValue(); // Convert the C strings to the target Java strings. String configFileName = CTypeConversion.toJavaString(configFileNameC); String txJson = sendTx(amountToSend, configFileName); // put resulting string into provided buffer CTypeConversion.toCString(txJson, resBuffer, bufferSize); } ... } We can then compile down to a shared library and an automatically generated header file. Notice the use of the --shared option. $ native-image --no-server \\ -cp build/libs/appkit-examples-3.1.0-all.jar\\ --report-unsupported-elements-at-runtime\\ --no-fallback -H:+TraceClassInitialization -H:+ReportExceptionStackTraces\\ -H:+AddAllCharsets -H:+AllowVMInspection -H:-RuntimeAssertions\\ --allow-incomplete-classpath \\ --enable-url-protocols=http,https --shared -H:Name=libfreezecoin -H:Path=c-examples $ otool -L c-examples/libfreezecoin.dylib c-examples/libfreezecoin.dylib: .../c-examples/libfreezecoin.dylib (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4) /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1455.12.0) /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11) Now we have the ability to write a C program which uses the library. The interface to our native library does have a bit of boilerplate (because the VM needs to manage a heap, threads, a garbage collector and more), and thus we need to create an instance and provide it our main thread. #include <stdlib.h> #include <stdio.h> #include <libfreezecoin.h> int main(int argc, char **argv) { graal_isolate_t *isolate = NULL; graal_isolatethread_t *thread = NULL; if (graal_create_isolate(NULL, &isolate, &thread) != 0) { fprintf(stderr, \"graal_create_isolate error\\n\"); return 1; } char * configFileName = \"freeze_coin_config.json\"; // get amountToSend from cmd args and call transaction creation long amountToSend = atol(argv[1]); char result[1024 * 16]; sendTx(thread, amountToSend, configFileName, result, sizeof(result)); // print out serialized result printf(\"%s\\n\", result); if (graal_detach_thread(thread) != 0) { fprintf(stderr, \"graal_detach_thread error\\n\"); return 1; } return 0; } We can compile this with our standard system tools and easily run our executable (set LD_LIBRARY_PATH=. on Linux). $ clang -Ic-examples -Lc-examples -lfreezecoin c-examples/freezecoin.c -o call_freezecoin $ otool -L call_freezecoin $ DYLD_LIBRARY_PATH=$GRAAL_HOME/jre/lib ./call_freezecoin 1000000000","title":"4. Ergo Native Shared Libraries"},{"location":"dev/stack/appkit/#5-debugging-your-polyglot-ergo-application","text":"You can debug JS, Python and Ruby in IntelliJ, but if for some reason this doesn't work for you or fit with your preferred editor, GraalVM offers another option. All of the GraalVM languages (except for Java) are implemented using the common Truffle framework . Truffle allows for tooling like debuggers to be implemented once and be available for all supported languages. As such we can run our program with the flag --inspect which will give us a link to open in Chrome and will pause the program in the debugger. $ ruby --polyglot --jvm --inspect --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\ ruby-examples/FreezeCoin.rb 1900000000 Debugger listening on port 9229. To start debugging, open the following URL in Chrome: chrome-devtools://devtools/bundled/js_app.html?ws=127.0.0.1:9229/30c7da1e-7558a47d09b ... From here we can set breakpoints and continue execution. When it breaks we\u2019ll see values of the variables, can continue again until the next breakpoint, and do everything we've come to expect from debuggers.","title":"5. Debugging Your Polyglot Ergo Application"},{"location":"dev/stack/appkit/#conclusions","text":"And with all of that said and done, we see just how easy it is to use Appkit to develop Ergo Applications. Appkit relies on the same exact core libraries which were used in implementing the Ergo consensus protocol. These libraries include the ErgoScript compiler, cryptography, byte code interpreter, data serialisers and the other core components. Using GraalVM we are able to reuse these tried and tested components in different application contexts without any modification or rewriting them ourselves. No matter if you are using Java, JavaScript, Python or Ruby, you can take advantage of Appkit with GraalVM to drastically simplify the process of interacting with the Ergo blockchain while creating native-running (d)Apps. Stay tuned. In future posts we will introduce you to other interesting potential applications powered by Appkit.","title":"Conclusions"},{"location":"dev/stack/appkit/#references","text":"Ergo Site Ergo Sources Ergo Appkit Ergo Appkit Examples GraalVM","title":"References"},{"location":"dev/stack/back-end/","text":"Back-end This page provides an overview of the tools used to interact with the Ergo blockchain. Developers can use these tools to read data from the blockchain, compute using that data and optionally create transactions to be broadcast. Each tool requires the developer to \"program\" in some language. Users of AppKit will usually write Scala code (although AppKit supports many other languages). HDF users will need to write Rust code. JDE users will have to write JSON. JDE Ergo JDE Tutorials How-to Guides Example: Minting Reserve Coins Writing JDE Scripts Using the web service Explanations References Sample Scripts Syntax Headless dApp Framework Ergo Headless dApp Framework . The premier Rust framework for developing Ergo Headless dApps. The Ergo HDF provides developers with the very first portable UTXO-based headless dApp development framework on any blockchain. Tutorials Math Bounty Headless dApp - Getting Started Writing Your First Action Math Bounty Headless dApp - Finishing The Headless dApp Math Bounty Headless dApp - Writing A CLI Frontend For Creating Bounties Explanations Understanding The Ergo Headless dApp Framework Appkit AppKit provides methods for the following Fetch data from Ergo Explorer API Interact with Ergo Node, both public and private methods Build transactions and sign them Helper methods to handle cryptographics like calculating PK addresses from secrets Appkit: A Library for Polyglot Development of Ergo Applications has an idiomatic Java API and is written in Java/Scala. It is a thin wrapper around core components provided by the ErgoScript interpreter and Ergo protocol implementations which are written in Scala. It is published on maven repository and cross compiled to both Java 7 and Java 8+ jars. Using Appkit Ergo applications can be written in one of the languages supported by GraalVM (i.e. Java, JavaScript, C/C++, Python, Ruby, R) and using this library applications can communicate with Ergo nodes via unified API and programming model provided by Appkit. In addition Appkit based Ergo applications can be compiled into native code using native-image ahead of time compiler and then executed without Java VM with very fast startup time and lower runtime memory overhead compared to a Java VM. This is attractive option for high-performance low-latency microservices. Tutorials Tutorial starting with Appkit on Gradle projects AppKit by Example (Video) Appkit Examples How-to Guides Ergo Android | Example Android application which demonstrates how Ergo Appkit can be used to develop Ergo applications running on Android. Explanations AppKit Introduction . References ErgoTool | A Command Line Interface for Ergo based on Appkit and GraalVM native-image. Read the introduction and overview .","title":"Backend"},{"location":"dev/stack/back-end/#back-end","text":"This page provides an overview of the tools used to interact with the Ergo blockchain. Developers can use these tools to read data from the blockchain, compute using that data and optionally create transactions to be broadcast. Each tool requires the developer to \"program\" in some language. Users of AppKit will usually write Scala code (although AppKit supports many other languages). HDF users will need to write Rust code. JDE users will have to write JSON.","title":"Back-end"},{"location":"dev/stack/back-end/#jde","text":"Ergo JDE","title":"JDE"},{"location":"dev/stack/back-end/#tutorials","text":"","title":"Tutorials"},{"location":"dev/stack/back-end/#how-to-guides","text":"Example: Minting Reserve Coins Writing JDE Scripts Using the web service","title":"How-to Guides"},{"location":"dev/stack/back-end/#explanations","text":"","title":"Explanations"},{"location":"dev/stack/back-end/#references","text":"Sample Scripts Syntax","title":"References"},{"location":"dev/stack/back-end/#headless-dapp-framework","text":"Ergo Headless dApp Framework . The premier Rust framework for developing Ergo Headless dApps. The Ergo HDF provides developers with the very first portable UTXO-based headless dApp development framework on any blockchain.","title":"Headless dApp Framework"},{"location":"dev/stack/back-end/#tutorials_1","text":"Math Bounty Headless dApp - Getting Started Writing Your First Action Math Bounty Headless dApp - Finishing The Headless dApp Math Bounty Headless dApp - Writing A CLI Frontend For Creating Bounties","title":"Tutorials"},{"location":"dev/stack/back-end/#explanations_1","text":"Understanding The Ergo Headless dApp Framework","title":"Explanations"},{"location":"dev/stack/back-end/#appkit","text":"AppKit provides methods for the following Fetch data from Ergo Explorer API Interact with Ergo Node, both public and private methods Build transactions and sign them Helper methods to handle cryptographics like calculating PK addresses from secrets Appkit: A Library for Polyglot Development of Ergo Applications has an idiomatic Java API and is written in Java/Scala. It is a thin wrapper around core components provided by the ErgoScript interpreter and Ergo protocol implementations which are written in Scala. It is published on maven repository and cross compiled to both Java 7 and Java 8+ jars. Using Appkit Ergo applications can be written in one of the languages supported by GraalVM (i.e. Java, JavaScript, C/C++, Python, Ruby, R) and using this library applications can communicate with Ergo nodes via unified API and programming model provided by Appkit. In addition Appkit based Ergo applications can be compiled into native code using native-image ahead of time compiler and then executed without Java VM with very fast startup time and lower runtime memory overhead compared to a Java VM. This is attractive option for high-performance low-latency microservices.","title":"Appkit"},{"location":"dev/stack/back-end/#tutorials_2","text":"Tutorial starting with Appkit on Gradle projects AppKit by Example (Video) Appkit Examples","title":"Tutorials"},{"location":"dev/stack/back-end/#how-to-guides_1","text":"Ergo Android | Example Android application which demonstrates how Ergo Appkit can be used to develop Ergo applications running on Android.","title":"How-to Guides"},{"location":"dev/stack/back-end/#explanations_2","text":"AppKit Introduction .","title":"Explanations"},{"location":"dev/stack/back-end/#references_1","text":"ErgoTool | A Command Line Interface for Ergo based on Appkit and GraalVM native-image. Read the introduction and overview .","title":"References"},{"location":"dev/stack/ergotool/","text":"Introduction ErgoTool is a command line interface (CLI) for Ergo blockchain . You can use ErgoTool without running your own Ergo node. Even though running a node is the most secure way to communicate with the Ergo blockchain network, ErgoTool however, aims to provide more foundational tools at your disposal. Surely, you still can use it with your own running node. In this post we will walk through simple steps to generate a mnemonic phrase, create a local secret storage and use it to send ERGs between addresses, all with the help of ErgoTool commands. Getting Started First of all we need to install ErgoTool on our system from sources by following the installation instructions . In the directory where we cloned ErgoTool there is ergo-tool.sh script which we are going to use to run commands. Run the following command to check ErgoTool is installed correctly. $ ./ergo-tool.sh help command name is not specified (run ergo-tool without arguments to list commands) Command Name: help Usage Syntax: ergo-tool help <commandName> Description: prints usage help for a command Doc page: https://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/HelpCmd.html Let's see what we get here. ErgoTool outputs the error message with the information about help command. This is a typical output of ErgoTool when one of the known commands is specified, but it is used incorrectly. As we can learn from the message, the help command requires us to specify additional <commandName> argument. Also, each command has an API doc page with all the details about command execution, so its url is shown here. Create a New Mnemonic Phrase Mnemonic is a random sequence of characters which is used to generate a master key according to Hierarchical Deterministic Wallets specification. For convenience random sequence of english words is used, but this is not required. Run the following command to generate a new mnemonic phrase: $ ./ergo-tool.sh mnemonic bird harbor wheat innocent business disease busy quick yellow trust time oil enter situate moon Write it down on a paper and keep in a safe and secret place. As an additional security measure you can create an arbitrary mnemonic password. In some sense it can serve like an additional non-vocabulary word in the mnemonic. Mnemonic password is optional and is used for additional security. If you decide to use mnemonic password you should also write it down and keep in a secret and probably different from mnemonic place. Important, both mnemonic phrase and mnemonic password are required to restore secret keys, if you lose any of them then you will not be able to regenerate you master key again. Next let's use the generated mnemonic to create a storage with a master secret key. Create a New Encrypted Storage For better security neither mnemonic phrase nor password is required by ErgoTool to perform the transaction signing. Instead, the secret key from the encrypted storage is required to sign spending transaction. We can generate a secret key and store it in an encrypted storage using createStorage command. $ ./ergo-tool.sh help createStorage Command Name: createStorage Usage Syntax: ergo-tool createStorage [<storageDir>=\"storage\"] [<storageFileName>=\"secret.json\"] Description: Creates an encrypted storage file for the mnemonic entered by the user Doc page: https://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/CreateStorageCmd.html $ ./ergo-tool.sh createStorage Enter mnemonic phrase> bird harbor wheat innocent business disease busy quick yellow trust time oil enter situate moon Mnemonic password> Repeat mnemonic password> Storage password> Repeat storage password> Storage File: storage/secret.json A master secret key is generated from the (mnemonic phrase, mnemonic password) pair and saved encrypted in the storage/secret.json file. Mnemonic itself is not stored in the file and there is no way to restore it from the file, even if you know the passwords. Please take care to enter correct mnemonic password, the one you chose and saved before. Since a mnemonic password is optional you can leave it empty by pressing enter. If you forget the storage password (aka encryption password), you will not be able to use that storage file anymore, however, you can always restore your secret keys from (mnemonic phrase, mnemonic password) pair and thus create a new storage file with a new password. Keep your storage file and storage password in secret, anyone who obtain both your storage file and storage password will be able to decipher it and access secret keys. Extracting Data From Storage Secret storage contains master secret key and as a result can be used to compute both the public key and the pay-to-public-key address which correspond to that secret key. The extractStorage command is doing just that. $ ./ergo-tool.sh help extractStorage Command Name: extractStorage Usage Syntax: ergo-tool extractStorage <storage file> address|masterKey|publicKey|secretKey mainnet|testnet Description: Reads the file, unlocks it using password and extract the requested property from the given storage file. Doc page: https://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/ExtractStorageCmd.html $ ./ergo-tool.sh extractStorage storage/secret.json address mainnet Storage password> 9iHiSAg3ko2ZGxR2vhc1Aem3tShqfzEPDAF7XK5cdtbZ3Ut2CCf Here the command transforms the secret key to the corresponding public key and then creates the pay-to-public-key address on the mainnet. The same way we can obtain public key, private key and other data from the storage. $ ./ergo-tool.sh extractStorage storage/secret.json secretKey mainnet Storage password> 55dfde63c9b6b4f47683592e85ee997ba2e93507f38ba3f9c82933bcfbc677ca $ ./ergo-tool.sh extractStorage storage/secret.json publicKey mainnet Storage password> 03f07aecb145a85920bf6e9be80efe5f1cd1a165b45ad3aa8e5c4ca3ba50856bb8 Listing Unspent Boxes ErgoTool has the special command to list all available (aka unspent) boxes for a given address. $ ./ergo-tool.sh listAddressBoxes 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v BoxId NanoERGs 4840cb6facc20b765085db0ad24768ed0c5e7afd413e8e58e597c33a993f8119 4987000000 if we specify --print-json option, then ErgoTool will output all the boxes in json format $ ./ergo-tool.sh listAddressBoxes --print-json 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v [{\"boxId\":\"4840cb6facc20b765085db0ad24768ed0c5e7afd413e8e58e597c33a993f8119\",\"value\":4987000000,\"ergoTree\":\"0008cd02472963123ce32c057907c7a7268bc09f45d9ca57819d3327b9e7497d7b1cc347\",\"creationHeight\":125646,\"assets\":[],\"additionalRegisters\":{},\"transactionId\":\"820c688f4b9d709924ba0186ee930a7df374d8852920bc769fc1f1d0b313e5ab\",\"index\":2}] Transfer Coins Now, with secret key stored securely in the encrypted storage file, we can use ErgoTool to transfer coins from our address to some other recipient address. The command to do that is send . ./ergo-tool.sh help send Command Name: send Usage Syntax: ergo-tool send <storageFile> <recipientAddr> <amountToSend> Description: send the given <amountToSend> to the given <recipientAddr> using the given <storageFile> to sign transaction (requests storage password) Doc page: https://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/SendCmd.html The storage file is necessary in order to access secret key and generate a signature. The storage password will be requested by ErgoTool to unlock and decipher the file content. The command send supports the --dry-run option which forces ErgoTool to create the signed transaction, but instead of sending it to the blockchain, ErgoTool prints the transaction on the console. $ ./ergo-tool.sh send --dry-run storage/E1.json 9hHDQb26AjnJUXxcqriqY1mnhpLuUeC81C4pggtK7tupr92Ea1K 5000000 Storage password> Creating prover... Ok Loading unspent boxes from at address 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v... Ok Signing the transaction... Ok Tx: { \"id\": \"2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\", \"inputs\": [ { \"boxId\": \"4840cb6facc20b765085db0ad24768ed0c5e7afd413e8e58e597c33a993f8119\", \"spendingProof\": { \"proofBytes\": \"060e7c99c9c9cecf89ec5c3e7b692075e0b3415318f8064c64f7f01401ac29c6637b44535151e51d43d4cd25e05ad459dbe33718a99a22dd\", \"extension\": {} } } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"4eaed414ae763158126859bbf912fa9ffb9ea67ac13d81d473b1c81ec65b06fd\", \"value\": 5000000, \"ergoTree\": \"ErgoTree(0,WrappedArray(),Right(ConstantNode(SigmaProp(ProveDlog(ECPoint(6ba5cf,8ae5ac,...))),SSigmaProp)),80,[B@1117fff48)\", \"creationHeight\": 130508, \"assets\": [], \"additionalRegisters\": {}, \"transactionId\": \"2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\", \"index\": 0 }, { \"boxId\": \"059b426fe2aaef10b6a9a618f0c5b4e97d4dd9931328bf4f52bcf92b0943a42c\", \"value\": 1000000, \"ergoTree\": \"ErgoTree(16,WrappedArray(IntConstant(0), IntConstant(0), ConstantNode(Coll(16,2,4,-96,11,8,-51,2,121,-66,102,126,-7,-36,-69,-84,85,-96,98,-107,-50,-121,11,7,2,-101,-4,-37,45,-50,40,-39,89,-14,-127,91,22,-8,23,-104,-22,2,-47,-110,-93,-102,-116,-57,-89,1,115,0,115,1),Coll[SByte$]), ConstantNode(Coll(1),Coll[SInt$]), IntConstant(1)),Right(BoolToSigmaProp(AND(ConcreteCollection(WrappedArray(EQ(Height$(163),SelectField(ExtractCreationInfo(ByIndex(Outputs$(165),ConstantPlaceholder(0,SInt$),None)),1)), EQ(ExtractScriptBytes(ByIndex(Outputs$(165),ConstantPlaceholder(1,SInt$),None)),SubstConstants(ConstantPlaceholder(2,Coll[SByte$]),ConstantPlaceholder(3,Coll[SInt$]),ConcreteCollection(WrappedArray(CreateProveDlog(DecodePoint(MinerPubkey$(172)))),SSigmaProp))), EQ(SizeOf(Outputs$(165)),ConstantPlaceholder(4,SInt$))),SBoolean)))),4836,[B@111805c40)\", \"creationHeight\": 130508, \"assets\": [], \"additionalRegisters\": {}, \"transactionId\": \"2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\", \"index\": 1 }, { \"boxId\": \"0638ddb0fe6a8cc6ca4f981f71777f4a6e8aad72d57fdf945b24e0ef4ca714e1\", \"value\": 4981000000, \"ergoTree\": \"ErgoTree(0,WrappedArray(),Right(ConstantNode(SigmaProp(ProveDlog(ECPoint(472963,7c85fd,...))),SSigmaProp)),80,[B@111816258)\", \"creationHeight\": 130508, \"assets\": [], \"additionalRegisters\": {}, \"transactionId\": \"2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\", \"index\": 2 } ] } Note the \"ergoTree\" scripts are deserialized and printed as abstract syntax trees. This printing format can be regulated by additional options so that the scripts can be printed as human readable ErgoScript. (Not yet implemented, but somewhere on the roadmap.) If we exclude --dry-run option, the transaction will be sent and included in the blockchain. $ ./ergo-tool.sh send storage/E1.json 9hHDQb26AjnJUXxcqriqY1mnhpLuUeC81C4pggtK7tupr92Ea1K 5000000 Storage password> Creating prover... Ok Loading unspent boxes from at address 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v... Ok Signing the transaction... Ok Sendng the transaction... Ok Server returned tx id: \"c5710af17f5124a232a5ef731fdf94a493025334c2a7d5a79e9923210972b962\" The newly created transaction will be broadcast all over the blockchain and miners start to include it in a new block. Once the new block with our transaction is mined and accepted by the network our transfer is confirmed and we can see it in Explorer . We can also list boxes of the recipient address and see the coin we created among others (until it is spent by the recipient) $ ./ergo-tool.sh listAddressBoxes 9hHDQb26AjnJUXxcqriqY1mnhpLuUeC81C4pggtK7tupr92Ea1K BoxId NanoERGs 252c5ce38fc367001ea48fa6813e6252ebc169288d9b5392c572edb55380b3cd 5000000 6df9dbf08b4859b7e280afbd0822dcf20dba5bf8e3e33b78fe278df6597276f1 2000000 d47f958b201dc7162f641f7eb055e9fa7a9cb65cc24d4447a10f86675fc58328 1000000 e050a3af38241ce444c34eb25c0ab880674fc23a0e63632633ae14f547141c37 1000000 b50ed8c2953fd33b52af816c4caa63ec5b6d236a262a5a192534695c3478da78 1000000 26d6e08027e005270b38e5c5f4a73ffdb6d65a3289efb51ac37f98ad395d887c 10000000000 Security Notes ErgoTool is created with security in mind and tries its best to safeguard the usage of sensitive information like mnemonic phrases (which are never stored persistently), passwords (which are never shown on the screen) etc. In addition, secret keys are never stored on local disk unencrypted and surely never sent anywhere. Conclusion ErgoTool is designed to look and feel like a typical CLI utility: which is easy to use and fast to run from command line can be scriptable via shell scripts has built-in usage help At the same time ErgoTool is designed to be easily extensible: implemented in high-level language Scala reuses the core libraries which are used in Ergo network client open-sourced and fully documented This last point is especially important as many new commands can be easily added to ErgoTool, thanks to its architecture. If you need a specific feature or a command please file an issue or maybe even a PR. The extensibility of ErgoTool is a subject of the next planned blog post, stay tuned! References Ergo Site Ergo Sources Ergo Appkit Ergo Tool","title":"ErgoTool"},{"location":"dev/stack/ergotool/#introduction","text":"ErgoTool is a command line interface (CLI) for Ergo blockchain . You can use ErgoTool without running your own Ergo node. Even though running a node is the most secure way to communicate with the Ergo blockchain network, ErgoTool however, aims to provide more foundational tools at your disposal. Surely, you still can use it with your own running node. In this post we will walk through simple steps to generate a mnemonic phrase, create a local secret storage and use it to send ERGs between addresses, all with the help of ErgoTool commands.","title":"Introduction"},{"location":"dev/stack/ergotool/#getting-started","text":"First of all we need to install ErgoTool on our system from sources by following the installation instructions . In the directory where we cloned ErgoTool there is ergo-tool.sh script which we are going to use to run commands. Run the following command to check ErgoTool is installed correctly. $ ./ergo-tool.sh help command name is not specified (run ergo-tool without arguments to list commands) Command Name: help Usage Syntax: ergo-tool help <commandName> Description: prints usage help for a command Doc page: https://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/HelpCmd.html Let's see what we get here. ErgoTool outputs the error message with the information about help command. This is a typical output of ErgoTool when one of the known commands is specified, but it is used incorrectly. As we can learn from the message, the help command requires us to specify additional <commandName> argument. Also, each command has an API doc page with all the details about command execution, so its url is shown here.","title":"Getting Started"},{"location":"dev/stack/ergotool/#create-a-new-mnemonic-phrase","text":"Mnemonic is a random sequence of characters which is used to generate a master key according to Hierarchical Deterministic Wallets specification. For convenience random sequence of english words is used, but this is not required. Run the following command to generate a new mnemonic phrase: $ ./ergo-tool.sh mnemonic bird harbor wheat innocent business disease busy quick yellow trust time oil enter situate moon Write it down on a paper and keep in a safe and secret place. As an additional security measure you can create an arbitrary mnemonic password. In some sense it can serve like an additional non-vocabulary word in the mnemonic. Mnemonic password is optional and is used for additional security. If you decide to use mnemonic password you should also write it down and keep in a secret and probably different from mnemonic place. Important, both mnemonic phrase and mnemonic password are required to restore secret keys, if you lose any of them then you will not be able to regenerate you master key again. Next let's use the generated mnemonic to create a storage with a master secret key.","title":"Create a New Mnemonic Phrase"},{"location":"dev/stack/ergotool/#create-a-new-encrypted-storage","text":"For better security neither mnemonic phrase nor password is required by ErgoTool to perform the transaction signing. Instead, the secret key from the encrypted storage is required to sign spending transaction. We can generate a secret key and store it in an encrypted storage using createStorage command. $ ./ergo-tool.sh help createStorage Command Name: createStorage Usage Syntax: ergo-tool createStorage [<storageDir>=\"storage\"] [<storageFileName>=\"secret.json\"] Description: Creates an encrypted storage file for the mnemonic entered by the user Doc page: https://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/CreateStorageCmd.html $ ./ergo-tool.sh createStorage Enter mnemonic phrase> bird harbor wheat innocent business disease busy quick yellow trust time oil enter situate moon Mnemonic password> Repeat mnemonic password> Storage password> Repeat storage password> Storage File: storage/secret.json A master secret key is generated from the (mnemonic phrase, mnemonic password) pair and saved encrypted in the storage/secret.json file. Mnemonic itself is not stored in the file and there is no way to restore it from the file, even if you know the passwords. Please take care to enter correct mnemonic password, the one you chose and saved before. Since a mnemonic password is optional you can leave it empty by pressing enter. If you forget the storage password (aka encryption password), you will not be able to use that storage file anymore, however, you can always restore your secret keys from (mnemonic phrase, mnemonic password) pair and thus create a new storage file with a new password. Keep your storage file and storage password in secret, anyone who obtain both your storage file and storage password will be able to decipher it and access secret keys.","title":"Create a New Encrypted Storage"},{"location":"dev/stack/ergotool/#extracting-data-from-storage","text":"Secret storage contains master secret key and as a result can be used to compute both the public key and the pay-to-public-key address which correspond to that secret key. The extractStorage command is doing just that. $ ./ergo-tool.sh help extractStorage Command Name: extractStorage Usage Syntax: ergo-tool extractStorage <storage file> address|masterKey|publicKey|secretKey mainnet|testnet Description: Reads the file, unlocks it using password and extract the requested property from the given storage file. Doc page: https://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/ExtractStorageCmd.html $ ./ergo-tool.sh extractStorage storage/secret.json address mainnet Storage password> 9iHiSAg3ko2ZGxR2vhc1Aem3tShqfzEPDAF7XK5cdtbZ3Ut2CCf Here the command transforms the secret key to the corresponding public key and then creates the pay-to-public-key address on the mainnet. The same way we can obtain public key, private key and other data from the storage. $ ./ergo-tool.sh extractStorage storage/secret.json secretKey mainnet Storage password> 55dfde63c9b6b4f47683592e85ee997ba2e93507f38ba3f9c82933bcfbc677ca $ ./ergo-tool.sh extractStorage storage/secret.json publicKey mainnet Storage password> 03f07aecb145a85920bf6e9be80efe5f1cd1a165b45ad3aa8e5c4ca3ba50856bb8","title":"Extracting Data From Storage"},{"location":"dev/stack/ergotool/#listing-unspent-boxes","text":"ErgoTool has the special command to list all available (aka unspent) boxes for a given address. $ ./ergo-tool.sh listAddressBoxes 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v BoxId NanoERGs 4840cb6facc20b765085db0ad24768ed0c5e7afd413e8e58e597c33a993f8119 4987000000 if we specify --print-json option, then ErgoTool will output all the boxes in json format $ ./ergo-tool.sh listAddressBoxes --print-json 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v [{\"boxId\":\"4840cb6facc20b765085db0ad24768ed0c5e7afd413e8e58e597c33a993f8119\",\"value\":4987000000,\"ergoTree\":\"0008cd02472963123ce32c057907c7a7268bc09f45d9ca57819d3327b9e7497d7b1cc347\",\"creationHeight\":125646,\"assets\":[],\"additionalRegisters\":{},\"transactionId\":\"820c688f4b9d709924ba0186ee930a7df374d8852920bc769fc1f1d0b313e5ab\",\"index\":2}]","title":"Listing Unspent Boxes"},{"location":"dev/stack/ergotool/#transfer-coins","text":"Now, with secret key stored securely in the encrypted storage file, we can use ErgoTool to transfer coins from our address to some other recipient address. The command to do that is send . ./ergo-tool.sh help send Command Name: send Usage Syntax: ergo-tool send <storageFile> <recipientAddr> <amountToSend> Description: send the given <amountToSend> to the given <recipientAddr> using the given <storageFile> to sign transaction (requests storage password) Doc page: https://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/SendCmd.html The storage file is necessary in order to access secret key and generate a signature. The storage password will be requested by ErgoTool to unlock and decipher the file content. The command send supports the --dry-run option which forces ErgoTool to create the signed transaction, but instead of sending it to the blockchain, ErgoTool prints the transaction on the console. $ ./ergo-tool.sh send --dry-run storage/E1.json 9hHDQb26AjnJUXxcqriqY1mnhpLuUeC81C4pggtK7tupr92Ea1K 5000000 Storage password> Creating prover... Ok Loading unspent boxes from at address 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v... Ok Signing the transaction... Ok Tx: { \"id\": \"2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\", \"inputs\": [ { \"boxId\": \"4840cb6facc20b765085db0ad24768ed0c5e7afd413e8e58e597c33a993f8119\", \"spendingProof\": { \"proofBytes\": \"060e7c99c9c9cecf89ec5c3e7b692075e0b3415318f8064c64f7f01401ac29c6637b44535151e51d43d4cd25e05ad459dbe33718a99a22dd\", \"extension\": {} } } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"4eaed414ae763158126859bbf912fa9ffb9ea67ac13d81d473b1c81ec65b06fd\", \"value\": 5000000, \"ergoTree\": \"ErgoTree(0,WrappedArray(),Right(ConstantNode(SigmaProp(ProveDlog(ECPoint(6ba5cf,8ae5ac,...))),SSigmaProp)),80,[B@1117fff48)\", \"creationHeight\": 130508, \"assets\": [], \"additionalRegisters\": {}, \"transactionId\": \"2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\", \"index\": 0 }, { \"boxId\": \"059b426fe2aaef10b6a9a618f0c5b4e97d4dd9931328bf4f52bcf92b0943a42c\", \"value\": 1000000, \"ergoTree\": \"ErgoTree(16,WrappedArray(IntConstant(0), IntConstant(0), ConstantNode(Coll(16,2,4,-96,11,8,-51,2,121,-66,102,126,-7,-36,-69,-84,85,-96,98,-107,-50,-121,11,7,2,-101,-4,-37,45,-50,40,-39,89,-14,-127,91,22,-8,23,-104,-22,2,-47,-110,-93,-102,-116,-57,-89,1,115,0,115,1),Coll[SByte$]), ConstantNode(Coll(1),Coll[SInt$]), IntConstant(1)),Right(BoolToSigmaProp(AND(ConcreteCollection(WrappedArray(EQ(Height$(163),SelectField(ExtractCreationInfo(ByIndex(Outputs$(165),ConstantPlaceholder(0,SInt$),None)),1)), EQ(ExtractScriptBytes(ByIndex(Outputs$(165),ConstantPlaceholder(1,SInt$),None)),SubstConstants(ConstantPlaceholder(2,Coll[SByte$]),ConstantPlaceholder(3,Coll[SInt$]),ConcreteCollection(WrappedArray(CreateProveDlog(DecodePoint(MinerPubkey$(172)))),SSigmaProp))), EQ(SizeOf(Outputs$(165)),ConstantPlaceholder(4,SInt$))),SBoolean)))),4836,[B@111805c40)\", \"creationHeight\": 130508, \"assets\": [], \"additionalRegisters\": {}, \"transactionId\": \"2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\", \"index\": 1 }, { \"boxId\": \"0638ddb0fe6a8cc6ca4f981f71777f4a6e8aad72d57fdf945b24e0ef4ca714e1\", \"value\": 4981000000, \"ergoTree\": \"ErgoTree(0,WrappedArray(),Right(ConstantNode(SigmaProp(ProveDlog(ECPoint(472963,7c85fd,...))),SSigmaProp)),80,[B@111816258)\", \"creationHeight\": 130508, \"assets\": [], \"additionalRegisters\": {}, \"transactionId\": \"2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\", \"index\": 2 } ] } Note the \"ergoTree\" scripts are deserialized and printed as abstract syntax trees. This printing format can be regulated by additional options so that the scripts can be printed as human readable ErgoScript. (Not yet implemented, but somewhere on the roadmap.) If we exclude --dry-run option, the transaction will be sent and included in the blockchain. $ ./ergo-tool.sh send storage/E1.json 9hHDQb26AjnJUXxcqriqY1mnhpLuUeC81C4pggtK7tupr92Ea1K 5000000 Storage password> Creating prover... Ok Loading unspent boxes from at address 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v... Ok Signing the transaction... Ok Sendng the transaction... Ok Server returned tx id: \"c5710af17f5124a232a5ef731fdf94a493025334c2a7d5a79e9923210972b962\" The newly created transaction will be broadcast all over the blockchain and miners start to include it in a new block. Once the new block with our transaction is mined and accepted by the network our transfer is confirmed and we can see it in Explorer . We can also list boxes of the recipient address and see the coin we created among others (until it is spent by the recipient) $ ./ergo-tool.sh listAddressBoxes 9hHDQb26AjnJUXxcqriqY1mnhpLuUeC81C4pggtK7tupr92Ea1K BoxId NanoERGs 252c5ce38fc367001ea48fa6813e6252ebc169288d9b5392c572edb55380b3cd 5000000 6df9dbf08b4859b7e280afbd0822dcf20dba5bf8e3e33b78fe278df6597276f1 2000000 d47f958b201dc7162f641f7eb055e9fa7a9cb65cc24d4447a10f86675fc58328 1000000 e050a3af38241ce444c34eb25c0ab880674fc23a0e63632633ae14f547141c37 1000000 b50ed8c2953fd33b52af816c4caa63ec5b6d236a262a5a192534695c3478da78 1000000 26d6e08027e005270b38e5c5f4a73ffdb6d65a3289efb51ac37f98ad395d887c 10000000000","title":"Transfer Coins"},{"location":"dev/stack/ergotool/#security-notes","text":"ErgoTool is created with security in mind and tries its best to safeguard the usage of sensitive information like mnemonic phrases (which are never stored persistently), passwords (which are never shown on the screen) etc. In addition, secret keys are never stored on local disk unencrypted and surely never sent anywhere.","title":"Security Notes"},{"location":"dev/stack/ergotool/#conclusion","text":"ErgoTool is designed to look and feel like a typical CLI utility: which is easy to use and fast to run from command line can be scriptable via shell scripts has built-in usage help At the same time ErgoTool is designed to be easily extensible: implemented in high-level language Scala reuses the core libraries which are used in Ergo network client open-sourced and fully documented This last point is especially important as many new commands can be easily added to ErgoTool, thanks to its architecture. If you need a specific feature or a command please file an issue or maybe even a PR. The extensibility of ErgoTool is a subject of the next planned blog post, stay tuned!","title":"Conclusion"},{"location":"dev/stack/ergotool/#references","text":"Ergo Site Ergo Sources Ergo Appkit Ergo Tool","title":"References"},{"location":"dev/stack/front-end/","text":"Front-end Ergo JS Template The Ergo JS Template aims to serve as an entry point to Ergo dApp Development Bootstrapped with Create React App. It contains ergo-ts and ergo-lib libraries as dependencies and some examples to present how to use these libraries. Explanations The following examples can be seen on the Ergo JS Template repository Interacting with the explorer Encoding different data types Decoding fields (registers) of tokens References ergo-ts with support of tokens and complex transactions ergo-js with basic transaction operations Other Examples The Ergo Raffle documentation provides a detailed description of their implmenetion. hypo10use/quid-games (Angular)","title":"Frontend"},{"location":"dev/stack/front-end/#front-end","text":"","title":"Front-end"},{"location":"dev/stack/front-end/#ergo-js-template","text":"The Ergo JS Template aims to serve as an entry point to Ergo dApp Development Bootstrapped with Create React App. It contains ergo-ts and ergo-lib libraries as dependencies and some examples to present how to use these libraries.","title":"Ergo JS Template"},{"location":"dev/stack/front-end/#explanations","text":"The following examples can be seen on the Ergo JS Template repository Interacting with the explorer Encoding different data types Decoding fields (registers) of tokens","title":"Explanations"},{"location":"dev/stack/front-end/#references","text":"ergo-ts with support of tokens and complex transactions ergo-js with basic transaction operations","title":"References"},{"location":"dev/stack/front-end/#other-examples","text":"The Ergo Raffle documentation provides a detailed description of their implmenetion. hypo10use/quid-games (Angular)","title":"Other Examples"},{"location":"dev/stack/jde/","text":"JSON dApp Environment (JDE) first release Introduction This is to announce the first release of JSON dApp Environment (JDE), a tool for interacting with the Ergo blockchain. https://github.com/ergoplatform/ergo-jde Background The Ergo platform allows sophisticated dApps via smart contracts written in ErgoScript. Some notable examples are the Sigma-USD stable coin bank and ErgoMixer. Interacting with such smart contracts requires a developer to write code in a language such as Scala (using the App-Kit framework) or Rust (using HDF / sigma-rust) JSON dApp Environment (JDE) is another programming tool that can be used to interact with Ergo dApps. The differentiating feature of JDE is that its programming language is JSON. Goals JDE is designed with the following goals: Enable tech-savvy users and developers to interact with existing (and future) Ergo dApps such as Sigma USD by programming the off-chain logic in a user-friendly way. Provide a \"sandbox\" mode, where users can send arbitrary scripts for execution such that the server does not have to worry about malicious programs. This enables JDE service to be hosted remotely. An example is Kiosk-Web , where you can post arbitrary scripts (such as this , which gets the reserve coin rate) in \"Tx Builder\" and obtain results. Goal #2 rules out many programming languages such as Java/Scala and Rust. In fact, this rules out all the so-called \"Turing-complete\" languages. Capabilities Let us take the use-case of purchasing, say, 10 Sigma-USD reserve coins as an example, which involves the following steps: 1. Find the current oracle pool box and obtain the rate from register R4. 2. Find the current bank box and obtain the relevant parameters (tokens in circulation and base reserves). 3. Use the formulae to obtain the delta in base-reserves. 4. Compute the details of the new bank box to be created (nano-Ergs, tokens, registers) 5. Compute the details of the new receipt box to be created (nano-Ergs, tokens, registers) 6. Make a transaction creation request to the Ergo node with above details. All the above tasks can be programmed in JDE, as done in this script . In general, JDE allows us to do the following: 1. Find some boxes by address and/or box Id 2. Extract values from those boxes (nanoErgs, registers and tokens), and define variables using those. 3. Define constant values 4. Perform computation using the constants and variables. JDE supports if-then-else construct for control flow. However, it does not support loops. 5. Define outputs using the values computed 6. Make a transaction creation request to the Ergo node How to use JDE A compiled JAR is available in the release page. You can also generate the JAR yourself using the command sbt assembly . The following are the steps in using JDE. 1. Understand the scripting language by looking at the sample scripts and the documentation. 2. Ensure you have a fully synced Ergo node running. 3. Write your script or edit existing script for the task at hand. 4. Invoke JDE via CLI to generate a transaction creation request (aka unsigned transaction) along with some returned values. Depending on your use-case, you will be using the output of Step 4 differently End users will use the it to send a transaction on the Ergo blockchain Wallet authors will append some of their own inputs/outputs before sending the transaction. dApp authors will use the returned values for further computation. JDE also includes a web-service mode for the last two use-cases. Please see the documentation for details. Important Notes JDE is experimental. Please use with caution at your own risk. Always inspect the created transaction before sending. If you discover a bug, please make an issue and a PR if possible. If you find some feature missing, please make an issue.","title":"JDE"},{"location":"dev/stack/jde/#json-dapp-environment-jde-first-release","text":"","title":"JSON dApp Environment (JDE) first release"},{"location":"dev/stack/jde/#introduction","text":"This is to announce the first release of JSON dApp Environment (JDE), a tool for interacting with the Ergo blockchain. https://github.com/ergoplatform/ergo-jde","title":"Introduction"},{"location":"dev/stack/jde/#background","text":"The Ergo platform allows sophisticated dApps via smart contracts written in ErgoScript. Some notable examples are the Sigma-USD stable coin bank and ErgoMixer. Interacting with such smart contracts requires a developer to write code in a language such as Scala (using the App-Kit framework) or Rust (using HDF / sigma-rust) JSON dApp Environment (JDE) is another programming tool that can be used to interact with Ergo dApps. The differentiating feature of JDE is that its programming language is JSON.","title":"Background"},{"location":"dev/stack/jde/#goals","text":"JDE is designed with the following goals: Enable tech-savvy users and developers to interact with existing (and future) Ergo dApps such as Sigma USD by programming the off-chain logic in a user-friendly way. Provide a \"sandbox\" mode, where users can send arbitrary scripts for execution such that the server does not have to worry about malicious programs. This enables JDE service to be hosted remotely. An example is Kiosk-Web , where you can post arbitrary scripts (such as this , which gets the reserve coin rate) in \"Tx Builder\" and obtain results. Goal #2 rules out many programming languages such as Java/Scala and Rust. In fact, this rules out all the so-called \"Turing-complete\" languages.","title":"Goals"},{"location":"dev/stack/jde/#capabilities","text":"Let us take the use-case of purchasing, say, 10 Sigma-USD reserve coins as an example, which involves the following steps: 1. Find the current oracle pool box and obtain the rate from register R4. 2. Find the current bank box and obtain the relevant parameters (tokens in circulation and base reserves). 3. Use the formulae to obtain the delta in base-reserves. 4. Compute the details of the new bank box to be created (nano-Ergs, tokens, registers) 5. Compute the details of the new receipt box to be created (nano-Ergs, tokens, registers) 6. Make a transaction creation request to the Ergo node with above details. All the above tasks can be programmed in JDE, as done in this script . In general, JDE allows us to do the following: 1. Find some boxes by address and/or box Id 2. Extract values from those boxes (nanoErgs, registers and tokens), and define variables using those. 3. Define constant values 4. Perform computation using the constants and variables. JDE supports if-then-else construct for control flow. However, it does not support loops. 5. Define outputs using the values computed 6. Make a transaction creation request to the Ergo node","title":"Capabilities"},{"location":"dev/stack/jde/#how-to-use-jde","text":"A compiled JAR is available in the release page. You can also generate the JAR yourself using the command sbt assembly . The following are the steps in using JDE. 1. Understand the scripting language by looking at the sample scripts and the documentation. 2. Ensure you have a fully synced Ergo node running. 3. Write your script or edit existing script for the task at hand. 4. Invoke JDE via CLI to generate a transaction creation request (aka unsigned transaction) along with some returned values. Depending on your use-case, you will be using the output of Step 4 differently End users will use the it to send a transaction on the Ergo blockchain Wallet authors will append some of their own inputs/outputs before sending the transaction. dApp authors will use the returned values for further computation. JDE also includes a web-service mode for the last two use-cases. Please see the documentation for details.","title":"How to use JDE"},{"location":"dev/stack/jde/#important-notes","text":"JDE is experimental. Please use with caution at your own risk. Always inspect the created transaction before sending. If you discover a bug, please make an issue and a PR if possible. If you find some feature missing, please make an issue.","title":"Important Notes"},{"location":"dev/stack/kiosk/","text":"ErgoScript playground using Kiosk I created a tool called Kiosk that allows one to play with ErgoScript using a basic web-based UI. In particular, we can do the following: Define boxes with arbitrary ErgoScript code and register values Create transaction outputting some predefined boxes URL: https://github.com/scalahub/Kiosk An online instance of Kiosk for experimental use is deployed at https://ergo.kioskweb.org/ This is running the exact code at https://github.com/scalahub/Kiosk Please use the above instance only for experiments and not for transferring any large amounts. For actual use, run your local instance as explained below. Kiosk is opensource and written in Scala. To run it from source, first, clone the repository and do sbt run (requires SBT to be installed). The web-interface will open in http://localhost:8080 Kiosk requires a fully configured Ergo node running and by default assumes that its REST API is available at http://localhost:9052. This can be changed by calling the method org.sh.kiosk.ergo.ErgoAPI.setUrl from the web-UI. A precompiled jar is available here , which can be run using java -jar <jarfile> . You can generate the jar from sources by issuing the command sbt assembly . Use it as follows: Set the environment to use in ErgoScript. This is a map of (key, value) pairs where keys will be referenced within ErgoScript code and also for setting registers of boxes. See the first image. Define one or more boxes using ErgoScript code and some registers if needed. See the second image. Create and send a transaction with some given boxes defined earlier in Step 2. See the third image. The final output will be txid of the transaction along with the request that was made to the Ergo node's API. To run you own copy (which is the right way to use it), you must clone the project and then do one of the following. Run sbt using the command sbt Then inside sbt prompt type the following jetty:start This will run the project using built in jetty web server on port 8080 which you can access at http://localhost:8080 Compile the war file using sbt package . (the file is in target/scala-2.12 folder in my case). Then run the war file as you would run any other J2EE app. Kiosk currently depends only on ergo-appkit and uses the public explorer to post transactions. In particular it does not require a local running Ergo node. Signing is performed via Appkit, which replicates a large part of the Ergo node wallet's functionality locally. after all both are JVM based). Kiosk is \"multi-tenant\" because each URL corresponds to a private copy of the script environment and box storage. Hence you can bookmark a URL and visit it later, and your declared variables and boxes should be present. Without the same URL, no one else will be able to see or modify your environment.","title":"Kiosk"},{"location":"dev/stack/kiosk/#ergoscript-playground-using-kiosk","text":"I created a tool called Kiosk that allows one to play with ErgoScript using a basic web-based UI. In particular, we can do the following: Define boxes with arbitrary ErgoScript code and register values Create transaction outputting some predefined boxes URL: https://github.com/scalahub/Kiosk An online instance of Kiosk for experimental use is deployed at https://ergo.kioskweb.org/ This is running the exact code at https://github.com/scalahub/Kiosk Please use the above instance only for experiments and not for transferring any large amounts. For actual use, run your local instance as explained below. Kiosk is opensource and written in Scala. To run it from source, first, clone the repository and do sbt run (requires SBT to be installed). The web-interface will open in http://localhost:8080 Kiosk requires a fully configured Ergo node running and by default assumes that its REST API is available at http://localhost:9052. This can be changed by calling the method org.sh.kiosk.ergo.ErgoAPI.setUrl from the web-UI. A precompiled jar is available here , which can be run using java -jar <jarfile> . You can generate the jar from sources by issuing the command sbt assembly . Use it as follows: Set the environment to use in ErgoScript. This is a map of (key, value) pairs where keys will be referenced within ErgoScript code and also for setting registers of boxes. See the first image. Define one or more boxes using ErgoScript code and some registers if needed. See the second image. Create and send a transaction with some given boxes defined earlier in Step 2. See the third image. The final output will be txid of the transaction along with the request that was made to the Ergo node's API. To run you own copy (which is the right way to use it), you must clone the project and then do one of the following. Run sbt using the command sbt Then inside sbt prompt type the following jetty:start This will run the project using built in jetty web server on port 8080 which you can access at http://localhost:8080 Compile the war file using sbt package . (the file is in target/scala-2.12 folder in my case). Then run the war file as you would run any other J2EE app. Kiosk currently depends only on ergo-appkit and uses the public explorer to post transactions. In particular it does not require a local running Ergo node. Signing is performed via Appkit, which replicates a large part of the Ergo node wallet's functionality locally. after all both are JVM based). Kiosk is \"multi-tenant\" because each URL corresponds to a private copy of the script environment and box storage. Hence you can bookmark a URL and visit it later, and your declared variables and boxes should be present. Without the same URL, no one else will be able to see or modify your environment.","title":"ErgoScript playground using Kiosk"},{"location":"dev/stack/transactions/","text":"Tx Assembler Service - Bypassing Node Requirement For dApps The Problem Currently, with libraries like ergo-appkit, ergo-lib (aka sigma-rust), and ergo-ts, development on Ergo has become a lot more convenient and is becoming easier with further developments of ergo-lib. However, there are some big barriers for dApps to be extensively used by ordinary users. One of the main ones is that users can't use their assets to participate in dApps because current wallets don't support some key features needed by dApps like: - specifying input boxes - p2s protected boxes in inputs - specifying output registers - and simply not supporting dApp requests These issues will be resolved in the future for sure with wallets like Yoroi, but not so soon maybe! In this situation, dApps have no workarounds other than requiring users to have their node running or implement kind of a wallet themselves and ask users to trust and deposit there! The former is the case with Ergo Auction House which prevents it from being extensively used by everyone! Specifically, the problem that this topic is going to address is to bypass the node requirements by having an off-chain service to assemble arbitrary transactions for dApps. A Solution The off-chain service will allow dApps to register some requests by proving an address (which user will deposit her assets to) and some other specifications. This topic is just for getting feedback and I still haven't designed the APIs to provide concrete examples, however: { \"address\":\"address which user deposits to\", // p2s address explained in Trusting Issues section \"returnTo\":\"address to return assets to in case of failure\", \"startWhen\":{ // start assembling when all needed assets are deposited maybe with multiple transactions \"erg\":1002000000, \"d01bdce3959ff6b675f7ab40ec2479ca5ce1edf3ae6314631f09c0f9807752aa\":71 }, \"txSpec\":{ \"requests\":[ { \"address\":\"MFrQp7bsMkG9u1AQT33hn5ydUAcrqNMxhocS1RvvJqmUcHaiyXcCE3Sg7DbphepEXHXPkhEBzC6Kqw7jzQDzd4a9SX9M96b4NV8vTVp1zJGepnX41yuLzdWPzbB3k1XRTCUe7An26NDozTD3L5brAu5Nu5Pxkk28kNiFMtfG76n4yfF5YB1wbzXrfoaM9qVTFKhjLTRpJ1pwFZgzPnDC3LXEDyk4EPRjqnRe4WSnMhqa6ngfdGG79J4ZphMuDtamsJY7RD1PoWwxvidk9by7iQrQ3v9EGn1QkrtpxFN9Di7nsyKzUzQS6vxhpdcGXTRBhghaZPMnqRyzdhtspJxiYewSB14Q2cF1uR7vz3m6cqLuS7Fw8jKMpfsY9wXLRaHqUnzfJtEf7LTJfGHtCxifo2iuiHowkLWtwgZDNjH5UAiwAXubSuCzFVSZaDDyxdA5mqBSSRbSC8LoZvQwPcfFLvjjnx2nNznokdG6vA7LU8BbmXrnVXR\", \"value\":1000000000, \"assets\":[ { \"tokenId\":\"d01bdce3959ff6b675f7ab40ec2479ca5ce1edf3ae6314631f09c0f9807752aa\", \"amount\":71 } ], \"registers\":{ \"R4\":\"0e240008cd02d84d2e1ca735ce23f224bd43cd43ed67053356713a8a6920965b3bde933648dc\", \"R5\":\"04bacf2a\", \"R6\":\"0580a8d6b907\", \"R7\":\"0e0131\", \"R8\":\"0e240008cd02d84d2e1ca735ce23f224bd43cd43ed67053356713a8a6920965b3bde933648dc\", \"R9\":\"0e1c313030303030303030302c313030303030303030302c333439313433\" } } ], \"inputs\":[ \"$userIns\", \"boxId1\", \"boxId2\", \"...\" ], \"dataInputs\":[ \"boxId1\", \"...\" ], \"fee\":2000000 } } The above is a potential request that Ergo Auction House can register to the service which will start a new auction! So the Ergo Auction House app will ask the user to deposit the required assets to the address (will discuss what this address actually is in the next sections) using their favorite wallet and registers the request to the service. After such a request, the service will follow the address and when the conditions are met, assembles the tx and makes sure it will be mined. In case of failures, assets will be returned to the user; for example if the tx is for placing a bid and someone else places a bid before us! Note that all input and data input boxes are in ids and no input raw will be required, makes it safe for dApps to avoid running nodes for themselves, or use random nodes in the network to get raw inputs. Also, note that the above approach doesn't solve the problem of finding necessary boxes (e.g. in case of placing a bid, the auction box) for dApps and it isn't the aim of this topic as well! Furthermore, the txSpec is pretty raw, can be improved so that the service encodes the register to make it easier for dApps, but with the mentioned libraries around, I don't see it as a problem for dApps to encode registers themselves. With some improvements on the node's side, the service can be very fast and effective by using chained transactions to avoid wasting time for the deposits to be mined! So basically it will be like the user is running a node and is generating the tx directly without intermediate operations. Last but not least, the service will of course provide some other APIs for dApps to see the result of their registered requests. Trusting Issues How dApps and users should trust such a service is still a big problem. Several solutions: - With the service being open-sourced and maybe being provided by a trusted party - dApps can run the service for themselves, resolving the trust issue for at least themselves - Using well-designed p2s addresses to prevent the service from stealing Although one can argue that the first two options can work under some circumstances, the last option is the one which I think is applicable for most use-cases and doesn't require trust! For example, the Ergo Auction House can use p2s addresses which will allow the assets to be spent only for placing a specific bid, and the user's address being specified as auction's bidder in the auction box and register it to the service! Service Provider Incentives Although I personally don't have plans to make profits out of the service, one can have multiple options and plans to make some profits with the service. For example, the service can follow the registered request for some minutes for free and after that remove the request if the conditions are not met to assemble the transaction, then dApps can pay the service to follow the request longer! Until the dApp bridge in wallets is built, I think such a service will help a lot for the growth of dApps. Even after some wallets provide APIs for dApps, users still can benefit from such service by using any wallet they wish! Please let me know if something is overlooked. Motivation Currently, to craft a transaction, we need to use Kiosk, sigma-rust, Appkit or some other tool, which makes the entry barrier quite high. Motivated from @anon_real's Tx Assembler and other proposals, I had been working on a tool to automate tx building for the off-chain components of an Ergo dApp. The tool, called simply \"Tx Builder\" can be used to create transactions for participating in several Ergo application protocols. The goal of Tx Builder is to allow people with just knowledge of Json to craft a transaction following certain rules. Documentation There is a very short introduction here . For further details, please refer to the source code here and the examples here . More details will follow soon. Example Script As an example, the following Json can be used for creating a timestamp using the service described here { \"constants\": [ { \"name\": \"myBoxId\", \"type\": \"CollByte\", \"value\": \"ae57e4add0f181f5d1e8fd462969e4cc04f13b0da183676660d280ad0b64563f\" }, { \"name\": \"emissionAddress\", \"type\": \"Address\", \"value\": \"2z93aPPTpVrZJHkQN54V7PatEfg3Ac1zKesFxUz8TGGZwPT4Rr5q6tBwsjEjounQU4KNZVqbFAUsCNipEKZmMdx2WTqFEyUURcZCW2CrSqKJ8YNtSVDGm7eHcrbPki9VRsyGpnpEQvirpz6GKZgghcTRDwyp1XtuXoG7XWPC4bT1U53LhiM3exE2iUDgDkme2e5hx9dMyBUi9TSNLNY1oPy2MjJ5seYmGuXCTRPLqrsi\" }, { \"name\": \"timestampAddress\", \"type\": \"Address\", \"value\": \"4MQyMKvMbnCJG3aJ\" }, { \"name\": \"myTokenId\", \"type\": \"CollByte\", \"value\": \"dbea46d988e86b1e60181b69936a3b927c3a4871aa6ed5258d3e4df155750bea\" }, { \"name\": \"minTokenAmount\", \"type\": \"Long\", \"value\": \"2\" }, { \"name\": \"one\", \"type\": \"Long\", \"value\": \"1\" }, { \"name\": \"minStorageRent\", \"type\": \"Long\", \"value\": \"2000000\" } ], \"dataInputs\": [ { \"id\": { \"value\": \"myBoxId\" } } ], \"inputs\": [ { \"address\": { \"value\": \"emissionAddress\" }, \"tokens\": [ { \"index\": 0, \"id\": { \"value\": \"myTokenId\" }, \"amount\": { \"name\": \"inputTokenAmount\", \"value\": \"minTokenAmount\", \"filter\": \"Ge\" } } ], \"nanoErgs\": { \"name\": \"inputNanoErgs\" } } ], \"outputs\": [ { \"address\": { \"value\": \"emissionAddress\" }, \"tokens\": [ { \"index\": 0, \"id\": { \"value\": \"myTokenId\" }, \"amount\": { \"value\": \"balanceTokenAmount\" } } ], \"nanoErgs\": { \"value\": \"inputNanoErgs\" } }, { \"address\": { \"value\": \"timestampAddress\" }, \"registers\": [ { \"value\": \"myBoxId\", \"num\": \"R4\", \"type\": \"CollByte\" }, { \"value\": \"HEIGHT\", \"num\": \"R5\", \"type\": \"Int\" } ], \"tokens\": [ { \"index\": 0, \"id\": { \"value\": \"myTokenId\" }, \"amount\": { \"value\": \"one\" } } ], \"nanoErgs\": { \"value\": \"minStorageRent\" } } ], \"binaryOps\": [ { \"name\": \"balanceTokenAmount\", \"first\": \"inputTokenAmount\", \"op\": \"Sub\", \"second\": \"one\" } ] } Using with KioskWallet The above script was used to automatically generate this transaction using KioskWallet . Please refer to the screenshot for details","title":"Transactions"},{"location":"dev/stack/transactions/#tx-assembler-service-bypassing-node-requirement-for-dapps","text":"","title":"Tx Assembler Service - Bypassing Node Requirement For dApps"},{"location":"dev/stack/transactions/#the-problem","text":"Currently, with libraries like ergo-appkit, ergo-lib (aka sigma-rust), and ergo-ts, development on Ergo has become a lot more convenient and is becoming easier with further developments of ergo-lib. However, there are some big barriers for dApps to be extensively used by ordinary users. One of the main ones is that users can't use their assets to participate in dApps because current wallets don't support some key features needed by dApps like: - specifying input boxes - p2s protected boxes in inputs - specifying output registers - and simply not supporting dApp requests These issues will be resolved in the future for sure with wallets like Yoroi, but not so soon maybe! In this situation, dApps have no workarounds other than requiring users to have their node running or implement kind of a wallet themselves and ask users to trust and deposit there! The former is the case with Ergo Auction House which prevents it from being extensively used by everyone! Specifically, the problem that this topic is going to address is to bypass the node requirements by having an off-chain service to assemble arbitrary transactions for dApps.","title":"The Problem"},{"location":"dev/stack/transactions/#a-solution","text":"The off-chain service will allow dApps to register some requests by proving an address (which user will deposit her assets to) and some other specifications. This topic is just for getting feedback and I still haven't designed the APIs to provide concrete examples, however: { \"address\":\"address which user deposits to\", // p2s address explained in Trusting Issues section \"returnTo\":\"address to return assets to in case of failure\", \"startWhen\":{ // start assembling when all needed assets are deposited maybe with multiple transactions \"erg\":1002000000, \"d01bdce3959ff6b675f7ab40ec2479ca5ce1edf3ae6314631f09c0f9807752aa\":71 }, \"txSpec\":{ \"requests\":[ { \"address\":\"MFrQp7bsMkG9u1AQT33hn5ydUAcrqNMxhocS1RvvJqmUcHaiyXcCE3Sg7DbphepEXHXPkhEBzC6Kqw7jzQDzd4a9SX9M96b4NV8vTVp1zJGepnX41yuLzdWPzbB3k1XRTCUe7An26NDozTD3L5brAu5Nu5Pxkk28kNiFMtfG76n4yfF5YB1wbzXrfoaM9qVTFKhjLTRpJ1pwFZgzPnDC3LXEDyk4EPRjqnRe4WSnMhqa6ngfdGG79J4ZphMuDtamsJY7RD1PoWwxvidk9by7iQrQ3v9EGn1QkrtpxFN9Di7nsyKzUzQS6vxhpdcGXTRBhghaZPMnqRyzdhtspJxiYewSB14Q2cF1uR7vz3m6cqLuS7Fw8jKMpfsY9wXLRaHqUnzfJtEf7LTJfGHtCxifo2iuiHowkLWtwgZDNjH5UAiwAXubSuCzFVSZaDDyxdA5mqBSSRbSC8LoZvQwPcfFLvjjnx2nNznokdG6vA7LU8BbmXrnVXR\", \"value\":1000000000, \"assets\":[ { \"tokenId\":\"d01bdce3959ff6b675f7ab40ec2479ca5ce1edf3ae6314631f09c0f9807752aa\", \"amount\":71 } ], \"registers\":{ \"R4\":\"0e240008cd02d84d2e1ca735ce23f224bd43cd43ed67053356713a8a6920965b3bde933648dc\", \"R5\":\"04bacf2a\", \"R6\":\"0580a8d6b907\", \"R7\":\"0e0131\", \"R8\":\"0e240008cd02d84d2e1ca735ce23f224bd43cd43ed67053356713a8a6920965b3bde933648dc\", \"R9\":\"0e1c313030303030303030302c313030303030303030302c333439313433\" } } ], \"inputs\":[ \"$userIns\", \"boxId1\", \"boxId2\", \"...\" ], \"dataInputs\":[ \"boxId1\", \"...\" ], \"fee\":2000000 } } The above is a potential request that Ergo Auction House can register to the service which will start a new auction! So the Ergo Auction House app will ask the user to deposit the required assets to the address (will discuss what this address actually is in the next sections) using their favorite wallet and registers the request to the service. After such a request, the service will follow the address and when the conditions are met, assembles the tx and makes sure it will be mined. In case of failures, assets will be returned to the user; for example if the tx is for placing a bid and someone else places a bid before us! Note that all input and data input boxes are in ids and no input raw will be required, makes it safe for dApps to avoid running nodes for themselves, or use random nodes in the network to get raw inputs. Also, note that the above approach doesn't solve the problem of finding necessary boxes (e.g. in case of placing a bid, the auction box) for dApps and it isn't the aim of this topic as well! Furthermore, the txSpec is pretty raw, can be improved so that the service encodes the register to make it easier for dApps, but with the mentioned libraries around, I don't see it as a problem for dApps to encode registers themselves. With some improvements on the node's side, the service can be very fast and effective by using chained transactions to avoid wasting time for the deposits to be mined! So basically it will be like the user is running a node and is generating the tx directly without intermediate operations. Last but not least, the service will of course provide some other APIs for dApps to see the result of their registered requests.","title":"A Solution"},{"location":"dev/stack/transactions/#trusting-issues","text":"How dApps and users should trust such a service is still a big problem. Several solutions: - With the service being open-sourced and maybe being provided by a trusted party - dApps can run the service for themselves, resolving the trust issue for at least themselves - Using well-designed p2s addresses to prevent the service from stealing Although one can argue that the first two options can work under some circumstances, the last option is the one which I think is applicable for most use-cases and doesn't require trust! For example, the Ergo Auction House can use p2s addresses which will allow the assets to be spent only for placing a specific bid, and the user's address being specified as auction's bidder in the auction box and register it to the service!","title":"Trusting Issues"},{"location":"dev/stack/transactions/#service-provider-incentives","text":"Although I personally don't have plans to make profits out of the service, one can have multiple options and plans to make some profits with the service. For example, the service can follow the registered request for some minutes for free and after that remove the request if the conditions are not met to assemble the transaction, then dApps can pay the service to follow the request longer! Until the dApp bridge in wallets is built, I think such a service will help a lot for the growth of dApps. Even after some wallets provide APIs for dApps, users still can benefit from such service by using any wallet they wish! Please let me know if something is overlooked.","title":"Service Provider Incentives"},{"location":"dev/stack/transactions/#motivation","text":"Currently, to craft a transaction, we need to use Kiosk, sigma-rust, Appkit or some other tool, which makes the entry barrier quite high. Motivated from @anon_real's Tx Assembler and other proposals, I had been working on a tool to automate tx building for the off-chain components of an Ergo dApp. The tool, called simply \"Tx Builder\" can be used to create transactions for participating in several Ergo application protocols. The goal of Tx Builder is to allow people with just knowledge of Json to craft a transaction following certain rules.","title":"Motivation"},{"location":"dev/stack/transactions/#documentation","text":"There is a very short introduction here . For further details, please refer to the source code here and the examples here . More details will follow soon.","title":"Documentation"},{"location":"dev/stack/transactions/#example-script","text":"As an example, the following Json can be used for creating a timestamp using the service described here { \"constants\": [ { \"name\": \"myBoxId\", \"type\": \"CollByte\", \"value\": \"ae57e4add0f181f5d1e8fd462969e4cc04f13b0da183676660d280ad0b64563f\" }, { \"name\": \"emissionAddress\", \"type\": \"Address\", \"value\": \"2z93aPPTpVrZJHkQN54V7PatEfg3Ac1zKesFxUz8TGGZwPT4Rr5q6tBwsjEjounQU4KNZVqbFAUsCNipEKZmMdx2WTqFEyUURcZCW2CrSqKJ8YNtSVDGm7eHcrbPki9VRsyGpnpEQvirpz6GKZgghcTRDwyp1XtuXoG7XWPC4bT1U53LhiM3exE2iUDgDkme2e5hx9dMyBUi9TSNLNY1oPy2MjJ5seYmGuXCTRPLqrsi\" }, { \"name\": \"timestampAddress\", \"type\": \"Address\", \"value\": \"4MQyMKvMbnCJG3aJ\" }, { \"name\": \"myTokenId\", \"type\": \"CollByte\", \"value\": \"dbea46d988e86b1e60181b69936a3b927c3a4871aa6ed5258d3e4df155750bea\" }, { \"name\": \"minTokenAmount\", \"type\": \"Long\", \"value\": \"2\" }, { \"name\": \"one\", \"type\": \"Long\", \"value\": \"1\" }, { \"name\": \"minStorageRent\", \"type\": \"Long\", \"value\": \"2000000\" } ], \"dataInputs\": [ { \"id\": { \"value\": \"myBoxId\" } } ], \"inputs\": [ { \"address\": { \"value\": \"emissionAddress\" }, \"tokens\": [ { \"index\": 0, \"id\": { \"value\": \"myTokenId\" }, \"amount\": { \"name\": \"inputTokenAmount\", \"value\": \"minTokenAmount\", \"filter\": \"Ge\" } } ], \"nanoErgs\": { \"name\": \"inputNanoErgs\" } } ], \"outputs\": [ { \"address\": { \"value\": \"emissionAddress\" }, \"tokens\": [ { \"index\": 0, \"id\": { \"value\": \"myTokenId\" }, \"amount\": { \"value\": \"balanceTokenAmount\" } } ], \"nanoErgs\": { \"value\": \"inputNanoErgs\" } }, { \"address\": { \"value\": \"timestampAddress\" }, \"registers\": [ { \"value\": \"myBoxId\", \"num\": \"R4\", \"type\": \"CollByte\" }, { \"value\": \"HEIGHT\", \"num\": \"R5\", \"type\": \"Int\" } ], \"tokens\": [ { \"index\": 0, \"id\": { \"value\": \"myTokenId\" }, \"amount\": { \"value\": \"one\" } } ], \"nanoErgs\": { \"value\": \"minStorageRent\" } } ], \"binaryOps\": [ { \"name\": \"balanceTokenAmount\", \"first\": \"inputTokenAmount\", \"op\": \"Sub\", \"second\": \"one\" } ] }","title":"Example Script"},{"location":"dev/stack/transactions/#using-with-kioskwallet","text":"The above script was used to automatically generate this transaction using KioskWallet . Please refer to the screenshot for details","title":"Using with KioskWallet"},{"location":"dev/start/api/","text":"An Ergo node provides a REST API accessible via HTTP. The full API specification (in OpenAPI format) is available here . Accessing the API Once the node is running, the API can be accessed at 127.0.0.1:9052 . You can also use Swagger to make API requests by going to 127.0.0.1:9052/swagger . To access protected API routes (such as for wallet), you must provide your secret phrase in the request headers [api_key, Content-Type] , or click the Authorize button in swagger and enter your secret phrase there. Setting an API key For accessing any protected methods you must configure apiKeyHash parameter in the node configuration file: scorex.restApi.apiKeyHash = \"replace_this_with_your_unique_api_key_hash\" The parameter is the hex-encoded Blake2b256 hash of your secret phrase that will be used to authenticate your API requests. You can use this Python script or any other script to securely generate the secret and the blake2b256 hash of it. The secret phrase acts as an API key and can be any string but please ensure that it remains secret and is not sent to any untrusted services. The following REST API endpoint also provides a (non-protected) method to compute the hash: /utils/hashBlake2b","title":"Api"},{"location":"dev/start/api/#accessing-the-api","text":"Once the node is running, the API can be accessed at 127.0.0.1:9052 . You can also use Swagger to make API requests by going to 127.0.0.1:9052/swagger . To access protected API routes (such as for wallet), you must provide your secret phrase in the request headers [api_key, Content-Type] , or click the Authorize button in swagger and enter your secret phrase there.","title":"Accessing the API"},{"location":"dev/start/api/#setting-an-api-key","text":"For accessing any protected methods you must configure apiKeyHash parameter in the node configuration file: scorex.restApi.apiKeyHash = \"replace_this_with_your_unique_api_key_hash\" The parameter is the hex-encoded Blake2b256 hash of your secret phrase that will be used to authenticate your API requests. You can use this Python script or any other script to securely generate the secret and the blake2b256 hash of it. The secret phrase acts as an API key and can be any string but please ensure that it remains secret and is not sent to any untrusted services. The following REST API endpoint also provides a (non-protected) method to compute the hash: /utils/hashBlake2b","title":"Setting an API key"},{"location":"dev/start/dApp-dev/","text":"Everyone is talking about DeFi. Few people are asking what DeFi should look like. Ergo has a vision for what the sector can become. 2020 is shaping up to be the year in which Decentralised Finance rose to mainstream attention, in the same way that Bitcoin and blockchain did in 2016 and 2017. In July alone, Total Value Locked \u2013 the amount of funds committed to DeFi dApps\u2019 smart contracts \u2013 doubled from $2 billion to $4 billion, largely driven by Compound\u2019s distribution of its COMP governance tokens. DeFi is all the rage, with several well-known projects pioneering the space before our eyes. But while the crypto world is gripped with the short-term opportunities of DeFi, fewer are talking about what it actually is \u2013 and fewer still about what it should be. In building a DeFi platform like Ergo, though, that\u2019s exactly the kind of question we have to ask. DeFi dislikes limits In talking about what DeFi \u2018should\u2019 be, it\u2019s easy to fall into a trap of being prescriptive, of introducing arbitrary conditions and limits. But that\u2019s not what blockchain is about. As we\u2019ve seen with Bitcoin and blockchain more generally, there\u2019s a free market of ideas and nothing is off the table. It\u2019s reasonable (though not particularly helpful) to say that DeFi should be \u2018anything and everything\u2019. Just like blockchain, DeFi brings advantages of transparency, immutability and efficiency (often including speed and/or cost) to financial processes. But in terms of what we believe this new set of technologies should offer, and what decentralised finance can bring to the conventional financial system, it\u2019s worth focusing the conversation on a few other key areas that have been overlooked or under-represented to date: Privacy, Scalability, Interoperability , and Decentralisation . 1. Privacy As Eric Hughes wrote in A Cypherpunk\u2019s Manifesto back in 1993, \u2018Privacy is necessary for an open society in the electronic age.\u2019 That is never more true than for financial privacy. Privacy must be a built-in feature of DeFi \u2013 not a bolt on extra or a desirable feature. It must be integral. But, as Hughes continues, \u2018Privacy is the power to selectively reveal oneself to the world.\u2019 There is always a balance to be struck between privacy and compliance, between transparency and anonymity. Large scale adoption of DeFi requires auditability, and the regulatory approval that enables. Thanks to the latest advances in zero-knowledge proofs, Ergo can offer both privacy and transparency, where required. The platform\u2019s Sigma Protocols offer robust, customisable cryptography \u2013 and, at the same time, the ability to selectively reveal information where necessary. 2. Scalability The ability to process thousands of transactions per second is also a non-negotiable feature for a thriving DeFi sector. How this is achieved is less important than that it is achieved; in practice, there will be many different approaches, with different users and protocols selecting the ones they prefer. For example, while we have seen the rise of sidechains and child chains, the reality is that exchanges remain a gateway to the blockchain world for a large proportion of users. Popular exchanges are increasingly integrating DeFi functionality, allowing their vast user bases to access it from their individual accounts, without interacting directly with the protocol. While this may be less than ideal from a security perspective, it\u2019s a simple reality that centralised services are not going out of fashion, but are integrating decentralised technologies thanks to the advantages they offer. Ergo has its own approach to scalability , but we can\u2019t and won\u2019t ignore the importance of businesses in driving forward user adoption. 3. Interoperability One of DeFi\u2019s key strengths is composability: the ability to build new applications from existing components, leveraging the network effect of established dApps and tokens. This is one of the main factors that has enabled TVL to explode over the past month. But composability currently has its limits. Cross-platform composability currently isn\u2019t possible. Even atomic swaps \u2013 the first stage of interoperability \u2013 are in their infancy, though Ergo is working on an atomic swap-powered DEX . Full interoperability means the ability for a user to execute a smart contract on one platform and have it seamlessly interact with another blockchain. This would allow truly frictionless cross-protocol interaction, and is what is needed to enable the flow of liquidity fully throughout the DeFi world. At that point, applications become blockchain agnostic, and the platforms are really more like the programming languages for accessing dApps\u2019 functionality. 4. Decentralisation Lastly, and specifically in the context of scalability and interoperability, we cannot forget the importance of decentralisation \u2013 something Ergo has always taken seriously . Of course DeFi is decentralised \u2013 but there are different types of decentralisation. Ethereum, the home of almost every major DeFi dApp, is just one platform. Ethereum\u2019s developers are working on a plan for scaling, but even if this is successful, it is still one blockchain. Should we entrust all our funds to one network? What if a critical bug or exploit is found? Interoperability does more than enable cross-chain liquidity. It decentralises the decentralised infrastructure for DeFi, adding layers of redundancy and security. In the process, it strengthens every blockchain that is a part of that ecosystem, creating a whole that is more than the sum of its parts. At a time when relatively large blockchains still suffer double spend attacks and serious reorgs , and catastrophic vulnerabilities are found in smart contracts holding tens of millions of dollars of value, we cannot assume that one single blockchain will or should rule them all. As blockchain technology gains traction, central bank digital currencies are among the most significant applications being developed. But these will inevitably fall far short of the ideal, for one simple reason: control. In particular, that has implications for composability and privacy, and much else besides. Central bank digital currencies are no longer a theoretical application of blockchain technology. The list of countries developing CBDCs is growing rapidly, with several now trialing state-backed digital cash. CDBCs are not built on classic, open blockchain technology. While there are various approaches, they are all based on permissioned ledgers that restrict the role of securing the network and processing transactions to a group of approved entities. They also include a control layer that gives administrators the ability to intervene in transactions, blocking or reversing those they deem invalid. It\u2019s a far cry from the ideals of Bitcoin, and the Ergo platform that aims to build on these. But it\u2019s only to be expected. The state has a role and a remit, and it\u2019s unlikely to give up the control it exercises. Unfortunately, though, there are two ways that holding onto control will mean that CBDCs fall far short of what they could be, meaning they may ultimately cede ground to open platforms like Ergo. Composability As we wrote in a recent blog, composability is a core feature of DeFi. It\u2019s what gives applications network effect, instantly adding value by plugging into existing dapps\u2019 user bases and functionality. Programmable money is a huge development. The current system is clunky and complicated to use, at best. It\u2019s not possible to attach detailed conditions to transactions, and have them interact seamlessly with software, as can be done with blockchain and smart contracts. Imagine the value that could be unlocked if CBDCs were programmable, and smart cash could be integrated frictionlessly into new applications \u2013 banking interfaces, investment services, stores, social networks, games. The list is endless. But this is hardly likely. The freedom to program money will exist, for many years at least, in the open blockchain space alone. Privacy Secondly, we consider privacy to be a core requirement of DeFi. Money is too important to be used as a tool of surveillance, but there is no question that this is what it will become as soon as the first CBDCs are rolled out to a large user base. China is one of the furthest ahead in its creation of state-backed digital cash. This is a state that is notorious for its internet censorship and online surveillance of its population. Its human rights record is dire, and in recent days we have learned more about its oppression of the Uighur minority. Moreover, China already uses a social credit system, which grants or denies citizens access to certain services and amenities depending on their social score, with model citizens enjoying greater privileges. There is, again, no question that a state-backed, traceable CBDC will be used as a tool of surveillance on a scale that is unprecedented in human history. And it will be the same across any nation that implements money within the same framework. That giant eye on the dollar bill? You ain\u2019t seen nothing yet. Private, programmable financial services Ergo has a very different vision for blockchain-based cash and financial services. In the new paradigm of blockchain, value is not retained by constraining it. It is only maximised through open systems that make it as accessible as people want it to be. Money without borders, in both senses: cash that can be programmed, sent and received freely but privately, between any two individuals or organisations \u2013 and even blockchains \u2013 anywhere in the world. This is what money needs to be, and what Ergo is building. This is the first in a series of articles speculating on how the fast-emerging DeFi sector might evolve in the coming years. The DeFi movement as it currently exists is only a few months old, and blockchain itself has barely existed a decade. Already, though, we are beginning to see themes crystallising and the first popular use cases becoming established. As a DeFi platform that takes positioning for the future seriously, it\u2019s important that Ergo has a vision \u2013 not only a sense of where things might be heading, but the role that it should itself be playing as these new decentralised financial services consolidate and grow in popularity. While no one can know the future, least of all in this space, a number of trends, technologies, products and use cases are emerging, and it seems that these are starting to plot a certain trajectory. Allowing for necessary course correction as time goes on, where might we see DeFi end up in ten years? Tokens will be the fuel for DeFi, and everything will be tokenised One of the major themes that was becoming apparent, long before the yield farming craze brought DeFi to global attention, is tokenisation. We already have blockchain tokens representing cryptocurrencies and digital assets, and the first shares and other securities have been issued on the blockchain. The benefits are such that the direction of travel is clear. Sooner or later, everything will end up as tokens. For regular, fungible (interchangeable) assets, a regular token will work. Fiat and cryptocurrencies, shares, bonds, precious metals, ETFs, CBDCs \u2013 these will all be freely available on the blockchain. For other assets, NFTs will proliferate. When you buy a car, house, painting or other unique item of value, whether digital or physical, there\u2019s a good chance that transaction will also include a blockchain token. These tokenised assets will place on the blockchain trillions of dollars of value that are currently \u2018stuck\u2019 offline, illiquid or impossible to buy or sell outside of certain limited circles and circumstances. This pool of tokenised value will represent the fuel of the Defi economy: assets that can be traded frictionlessly, borrowed against and leveraged using decentralised protocols that probably won\u2019t look so very different to the ones we use today. Digital identity will become non-negotiable Since these assets will be tradeable on centralised and decentralised exchanges, digital identity will also become an increasingly important theme. This will link blockchain addresses with offline identities, enabling individuals and corporations to operate in a way that is compliant with relevant regulation. It will also allow the automation of tax and accounting processes. To date, digital identity has been an overlooked element of the DeFi ecosystem \u2013 likely due to the use of centralised platforms that can conduct KYC as a condition of use. We\u2019re fast approaching a point where that is no longer a given, with the growth of new forms of decentralised exchange and the increase in volumes moving to these platforms. Stablecoins will become embedded elements of the blockchain One of the biggest use cases for DeFi \u2013 and again one that is often overlooked \u2013 is stablecoins. These exist in many forms, and rely on a range of approaches: centralised and decentralised, collateralised and algorithmic, fiat-backed, and so on. Whatever your preferred approach or view of stablecoins, they are here to stay. They have found use cases as a store of value, especially for traders, and as a popular form of collateral for yield farming. What they haven\u2019t been widely adopted for, yet, is as an integral part of blockchain infrastructure. Transaction fees are almost always paid for with the native blockchain token. Not only does this fluctuate in value, but so does the amount of it required per transaction, depending on both the complexity of the transaction itself and competition for space in the next block. Clearly, this complexity is not conducive to mainstream adoption. End users are best served by simplicity, with minimal burdens for managing multiple tokens. They will want to pay transaction fees in a stable unit of account, and not have to worry about handling the native blockchain token. The solution? An integrated stablecoin that, to most end users, is the most important token on the platform. Two-tier system As a result of this need, it seems likely that we may start to see a two-tier system evolve more clearly. A blockchain such as Ergo will have a native token, which will serve as the underlying currency of payment, just as occurs now. For the most part, though, these will only be handled by more experienced users. These expert users will maintain the technical and financial infrastructure of the DeFi space. For example, they will mine and use the native token as collateral to create a stablecoin, which can be sold into the market for general use, in return for tokenised assets of all kinds. Regular users will then use the \u2018native stablecoin\u2019 in all their business, as a kind of standard reserve currency. It will be used to buy other assets; it will be lent to users against other tokenised assets as collateral (houses, cars, real estate and much more); and it will be used to pay transaction fees. The miners who receive this native stablecoin can hold it as it is, to pay for electricity and hardware costs, or they can convert it back to the platform token or other assets \u2013 that is up to them. These are just some of the themes we are starting to see emerging in the DeFi world, and how they might develop over time. In the coming weeks, we\u2019ll explore various other ideas as the space continues to evolve and Ergo launches new technology.","title":"dApp dev"},{"location":"dev/start/resources/","text":"Resources Explorer Explorer Mainnet explorer Testnet Testnet explorer Using Ergo-Testnet Testnet Faucet API API Docs Node API Explorer API Misc. Resources Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo. Basic Tutorials ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Resources"},{"location":"dev/start/resources/#resources","text":"","title":"Resources"},{"location":"dev/start/resources/#explorer","text":"Explorer Mainnet explorer","title":"Explorer"},{"location":"dev/start/resources/#testnet","text":"Testnet explorer Using Ergo-Testnet Testnet Faucet","title":"Testnet"},{"location":"dev/start/resources/#api","text":"API Docs Node API Explorer API","title":"API"},{"location":"dev/start/resources/#misc-resources","text":"Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo.","title":"Misc. Resources"},{"location":"dev/start/resources/#basic-tutorials","text":"ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Basic Tutorials"},{"location":"dev/start/start/","text":"Where to start? Welcome To Smart Money For most developers, Appkit is the best entry point unless you're wanting to dive straight into ErgoScript smart-contract development. See the Backend section for an overview of the tools available to interact with the blockchain. This is also broken down on a per-language basis. Bounties & Grants See grow-ergo/issues for an updated list of live bounties and grants available on Ergo. Good Whale's Grant Fund Up to $20,000 SigUSD per grant - submit your own idea! DarkFund0 4,000 ERG still available, for anything that improves privacy on Ergo. Resources Explorer Mainnet explorer Testnet Testnet explorer Using Ergo-Testnet Testnet Faucet API Ergo API basic query API Docs Node API Explorer API Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo. Basic Tutorials ergotutorials.com Create mini web for your NFT. Basic System Architecture Below is a example system architecture diagram highlighting the main components of a decentralised application (dApp) Front-end | The user-interface built in your framework of choice. For payments, we have the Yoroi dApp connector, proxy contracts, or Ergo-Pay. REST | A REST ful API to interact with the backend Backend | Perform the off-chain logic Database (Optional) Contract | Where the magic happens, the on-chain validation of the off-chain logic.","title":"Where to start?"},{"location":"dev/start/start/#where-to-start","text":"Welcome To Smart Money For most developers, Appkit is the best entry point unless you're wanting to dive straight into ErgoScript smart-contract development. See the Backend section for an overview of the tools available to interact with the blockchain. This is also broken down on a per-language basis.","title":"Where to start?"},{"location":"dev/start/start/#bounties-grants","text":"See grow-ergo/issues for an updated list of live bounties and grants available on Ergo. Good Whale's Grant Fund Up to $20,000 SigUSD per grant - submit your own idea! DarkFund0 4,000 ERG still available, for anything that improves privacy on Ergo.","title":"Bounties &amp; Grants"},{"location":"dev/start/start/#resources","text":"","title":"Resources"},{"location":"dev/start/start/#explorer","text":"Mainnet explorer","title":"Explorer"},{"location":"dev/start/start/#testnet","text":"Testnet explorer Using Ergo-Testnet Testnet Faucet","title":"Testnet"},{"location":"dev/start/start/#api","text":"Ergo API basic query API Docs Node API Explorer API Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo.","title":"API"},{"location":"dev/start/start/#basic-tutorials","text":"ergotutorials.com Create mini web for your NFT.","title":"Basic Tutorials"},{"location":"dev/start/start/#basic-system-architecture","text":"Below is a example system architecture diagram highlighting the main components of a decentralised application (dApp) Front-end | The user-interface built in your framework of choice. For payments, we have the Yoroi dApp connector, proxy contracts, or Ergo-Pay. REST | A REST ful API to interact with the backend Backend | Perform the off-chain logic Database (Optional) Contract | Where the magic happens, the on-chain validation of the off-chain logic.","title":"Basic System Architecture"},{"location":"miners/mining/","text":"","title":"Mining"},{"location":"node/api/","text":"Improved distributed signatures Initial implementation of distributed signatures support in the node worked well in simple cases, and ZK Treasury built on top of it. However, in complex cases it has some problems: hints generated (such as commitments) were not tied to a position of a sub-expression in a sigma-expression. For example, for statement like \"atLeast(2, Coll(pkAlice, pkBob, pkCharlie)) && (pkBob || pkDiana)\", the same commitment would be generated for Bob. Which is improper and insecure at all - a signature would reveal Bob's secret key (as the same randomness used twice for different challenges in Schnorr protocols). similarly, hints generated were not tied to inputs. This is fixed with new API introduced in distributed-sigs branch. Now all the hints tied with input indexes and also with positions in sigma-tree after script reduction with current context. Also, API is now simpler-to-use I suppose. So let me provide a new tutorial on collective signing. Like in the previous tutorial, first we pay to 2-out-of-3 spending script (with keys stored in registers): { val pkA = SELF.R4[GroupElement].get val pkB = SELF.R5[GroupElement].get val pkC = SELF.R6[GroupElement].get atLeast(2, Coll(proveDlog(pkA), proveDlog(pkB), proveDlog(pkC))) } Then, when a transaction is confirmed (https://explorer.ergoplatform.com/en/transactions/71aa67f95e96827193bdf711f6ccf41b30ef8bbbdaef63ed672dfb7420a4c314) , we get output bytes via /utxo/byIdBinary/{boxId} . Then we generate an unsigned transaction by providing inputs directly, in our example, by providing the following input to /wallet/transaction/generateUnsigned : { \"requests\": [ { \"address\": \"4MQyML64GnzMxZgm\", \"value\": 999000000 } ], \"fee\": 1000000, \"inputsRaw\": [ \"8094ebdc0310010404987300830308cde4c6a70407cde4c6a70507cde4c6a706079a8f1300030702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d71aa67f95e96827193bdf711f6ccf41b30ef8bbbdaef63ed672dfb7420a4c31400\" ], \"dataInputsRaw\": [ ] } Then Alice generates commitments for the unsigned transaction by sending it to the NEW /wallet/generateCommitments (additional secrets to be used along with wallet's can be provided also), and in the output she's getting both secret and public hints: { \"secretHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"03c855c50d173f1b0e2797390b71d82023dcb8e12950e4fa0b9ae3be17bacca2a1\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"position\": \"0-0\", \"hint\": \"cmtWithSecret\", \"secret\": \"...\" } ] }, \"publicHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"03c855c50d173f1b0e2797390b71d82023dcb8e12950e4fa0b9ae3be17bacca2a1\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"position\": \"0-0\", \"hint\": \"cmtReal\" } ] } } (secret randomness is omitted to avoid private key extraction). Then Alice must store secret hints locally and provide public to Bob. Bob is signing using Alice's hints by sending a request to /wallet/transaction/sign like: { \"tx\": { \"id\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"inputs\": [ { \"boxId\": \"9bcbbce28b19132c28b2e088ddea03f792673e9c4509a239145c241c891ca4b9\", \"extension\": {} } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"5bb78563af3843e5bf816c9dd50bd7c0a0b09c7fd2da2da075a8e5d8f545cb7f\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 0 }, { \"boxId\": \"b5a1a069015f94bf7daaec46fc121044607603c844d1c6d6a8e9b2322379b375\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 1 } ] }, \"inputsRaw\": [ \"8094ebdc0310010404987300830308cde4c6a70407cde4c6a70507cde4c6a706079a8f1300030702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d71aa67f95e96827193bdf711f6ccf41b30ef8bbbdaef63ed672dfb7420a4c31400\" ], \"dataInputsRaw\": [ ], \"secrets\": { }, \"hints\": { \"secretHints\": { }, \"publicHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"03c855c50d173f1b0e2797390b71d82023dcb8e12950e4fa0b9ae3be17bacca2a1\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"position\": \"0-0\", \"hint\": \"cmtReal\" } ] } } } and sending signed (but invalid) transaction to Alice (he can send hints generated on the next step instead). Now Alice is extracting commitment from Bob and Carol from the transaction, by sending a request to /script/extractHints like: { \"transaction\": { \"id\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"inputs\": [ { \"boxId\": \"9bcbbce28b19132c28b2e088ddea03f792673e9c4509a239145c241c891ca4b9\", \"spendingProof\": { \"proofBytes\": \"7d64cd47d3dc8bc5c336297e494f48d601c586175b37da228a54a77f52eb1ce307c22c7541368b73307bf37be4051406b49e989b4aee9f27789de0c426a8231fead96178544cbb54b37286f2630dcd9d5794ae9905697e8eeb0d03540d4cb8352a0734187d5e84b6d0825f12e3fcf287ee24e48d3a2a6dfb56471c41767ef88a3279e8fdc70274d85baf16686b641eaa\", \"extension\": {} } } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"5bb78563af3843e5bf816c9dd50bd7c0a0b09c7fd2da2da075a8e5d8f545cb7f\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 0 }, { \"boxId\": \"b5a1a069015f94bf7daaec46fc121044607603c844d1c6d6a8e9b2322379b375\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 1 } ], \"size\": 313 }, \"real\": [ { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" } ], \"simulated\": [ { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" } ] } and then she adds her secret hint to generate valid signed transaction, a request to /wallet/transaction/sign would be like: { \"tx\": { \"id\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"inputs\": [ { \"boxId\": \"9bcbbce28b19132c28b2e088ddea03f792673e9c4509a239145c241c891ca4b9\", \"extension\": {} } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"5bb78563af3843e5bf816c9dd50bd7c0a0b09c7fd2da2da075a8e5d8f545cb7f\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 0 }, { \"boxId\": \"b5a1a069015f94bf7daaec46fc121044607603c844d1c6d6a8e9b2322379b375\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 1 } ] }, \"inputsRaw\": [ \"8094ebdc0310010404987300830308cde4c6a70407cde4c6a70507cde4c6a706079a8f1300030702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d71aa67f95e96827193bdf711f6ccf41b30ef8bbbdaef63ed672dfb7420a4c31400\" ], \"dataInputsRaw\": [ ], \"secrets\": { }, \"hints\": { \"secretHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"03c855c50d173f1b0e2797390b71d82023dcb8e12950e4fa0b9ae3be17bacca2a1\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"position\": \"0-0\", \"hint\": \"cmtWithSecret\", \"secret\": \"....\" } ] }, \"publicHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"02b6c2b73e59ad061211cebb37a7d9b238b9388cdb0c3b96ae2152ba174f67de90\", \"pubkey\": { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" }, \"position\": \"0-2\", \"hint\": \"cmtSimulated\" }, { \"hint\": \"proofSimulated\", \"challenge\": \"e39924c725e1aee0cb705ce18a15d5425148939b7739e628\", \"pubkey\": { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" }, \"proof\": \"e39924c725e1aee0cb705ce18a15d5425148939b7739e628ee24e48d3a2a6dfb56471c41767ef88a3279e8fdc70274d85baf16686b641eaa\", \"position\": \"0-2\" }, { \"type\": \"dlog\", \"a\": \"0323bd7f1b87280aa2b7cb2a374da1897ef7d5fae7ab3948440907d303427740ba\", \"pubkey\": { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" }, \"position\": \"0-1\", \"hint\": \"cmtReal\" }, { \"hint\": \"proofReal\", \"challenge\": \"69cd83b8770ab203ccb27094cb235e31613360e0933cf22e\", \"pubkey\": { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" }, \"proof\": \"69cd83b8770ab203ccb27094cb235e31613360e0933cf22e5794ae9905697e8eeb0d03540d4cb8352a0734187d5e84b6d0825f12e3fcf287\", \"position\": \"0-1\" } ] } } } (secret randomness omitted again) And now generated signed valid transaction can be broadcasted. Taken from the forum post Improved distributed signatures ~ Sept, 2020 Let\u2019s sign collectively! Distributed signatures API It is well-known (among hardcore Ergonauts) that Ergo Platform has support for variety of composeable and efficient zero-knowledge proofs of knowledge in its authentication language. In particular, it provides possibility for ring and threshold signatures preserving zero-knowledge, so, for example, by observing 2-out-of-3 threshold signature associated with public keys of (Alice, Bob, Carol) on the blockchain, it is not possible to figure out who were those two parties who signed. While Ergo Platform protocol supports threshold and ring signatures since day one, concrete applications doing signing were not available eventually. First, the ErgoMix implementations (by @anon92048 and then @anon2020s ) are using kind of ring signature hiding a spending path. And recently EIP-11 was introduced which is about adding support for distributed signing to the reference client (and not only). The implementation of EIP-11 is mostly done in this PR and in I'm going to explain how to use new API method First, let's make a script for a box protected with 2-out-of-3 threshold signature. One option is about to hardcode public keys in the script, I've chosen another way, namely, to put public keys of signers into registers: { val pkA = SELF.R4[GroupElement].get val pkB = SELF.R5[GroupElement].get val pkC = SELF.R6[GroupElement].get atLeast(2, Coll(proveDlog(pkA), proveDlog(pkB), proveDlog(pkC))) } . Then we need to lock money with concrete keys. It seems the node Swagger API is the most convenient way to do that, e.g. by posting the following payment request to /wallet/payment/send: [ { \"address\": \"umRXw8E7PmdHbswncxFe3jmE51oGFzL4CqfZYfiRr4aL\", \"value\": 1000000000, \"registers\": { \"R4\": \"0702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\", \"R5\": \"070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\", \"R6\": \"070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" } } ] (use /utils/addressToRaw/{address} method to get encoded points from P2PK addresses shown by the wallet and prepend group element type descriptor \"07\" then). Thus we're getting the following box, for example (output #0): https://explorer.ergoplatform.com/en/transactions/0ffc5ba326262f25016c59c58a34b2f7fed2ea1b69f8f007d270f6ef07bced49 . We can get binary representation of unspent box via /utxo/byIdBinary API method, e.g. utxo/byIdBinary/f1892011ed31b8e51f3f3ae44f6d9132070343a7bf6db61b3342696a7873a085 gives us: \"8094ebdc0310010404987300830308cde4c6a70407cde4c6a70507cde4c6a70607abdd0f00030702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d0ffc5ba326262f25016c59c58a34b2f7fed2ea1b69f8f007d270f6ef07bced4900\" We use first two keys for signing (as it is 2-out-of). Please note that members of the signing ring know (and choose) who's signing and who will be simulated. Let's assume that the first key belongs to Alice, and the second key belongs to Bob. The the signing procedure could be as follows: First, Alice generates secret randomness and public commitment to it by posting the following request to /script/generateCommitment : { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" } result is : { \"r\": \"...\", \"a\": \"02c103443ab26655a1ef36f44643700cc5f4730a2a1830085dda1072ccfb30940f\" } (\"r\" is omitted to avoid private key recovery) She sends then \"a\" value to Bob along with unsigned transaction generated via /wallet/transaction/generateUnsigned. Now Bob is generating invalid (partial) signature by sending the following signing request to /wallet/transaction/sign with Alice's commitment included as hint: { \"tx\": { \"id\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"inputs\": [ { \"boxId\": \"f1892011ed31b8e51f3f3ae44f6d9132070343a7bf6db61b3342696a7873a085\", \"extension\": {} } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"49974195f916dcc95e94c72bcf6e90200bbf2c06e5cc7a22a505bad1da77927d\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 0 }, { \"boxId\": \"096192e25b691697b5afdd4a5cf39c69b84fba8b483f475c2e2d3cf47758abb1\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 1 } ] }, \"secrets\": { \"dlog\": [ ], \"dht\": [ ] }, \"hints\": [ { \"hint\": \"cmtReal\", \"type\": \"dlog\", \"pubkey\":{ \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"a\": \"02c103443ab26655a1ef36f44643700cc5f4730a2a1830085dda1072ccfb30940f\" } ] } Bob is sending transaction with invalid signature to Alice. First, she extracts Bob's and Carol's (simulated by Bob actually) commitments and partial signatures by feeding Bob's invalid transaction and Bob's and Carol's pubkeys into /script/extractHints : { \"transaction\": { \"id\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"inputs\": [ { \"boxId\": \"f1892011ed31b8e51f3f3ae44f6d9132070343a7bf6db61b3342696a7873a085\", \"spendingProof\": { \"proofBytes\": \"2c429642fba49717349dbeafb5c4a0725d012e901352fdcc390d53103824fcadb82553ddef404d69794679327c976bc3195dc78926c8161437d595a0a04dac8d3fe08d999d3c70f18c92cddaa1260d3a564c7431c478825d52bd28673637d986f545e871bd07a99cf6c3e04c2342da40f4608fb322f213c2b1f9166ad526cb7d7a931b02b8966f6ba4cc98aa435156f4\", \"extension\": {} } } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"49974195f916dcc95e94c72bcf6e90200bbf2c06e5cc7a22a505bad1da77927d\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 0 }, { \"boxId\": \"096192e25b691697b5afdd4a5cf39c69b84fba8b483f475c2e2d3cf47758abb1\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 1 } ], \"size\": 313 }, \"real\": [ { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" } ], \"simulated\": [ { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" } ] } and then she adds a hint with her commitment and randomness and produces transaction. A request to /wallet/transaction/sign is as follows: { \"tx\": { \"id\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"inputs\": [ { \"boxId\": \"f1892011ed31b8e51f3f3ae44f6d9132070343a7bf6db61b3342696a7873a085\", \"extension\": {} } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"49974195f916dcc95e94c72bcf6e90200bbf2c06e5cc7a22a505bad1da77927d\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 0 }, { \"boxId\": \"096192e25b691697b5afdd4a5cf39c69b84fba8b483f475c2e2d3cf47758abb1\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 1 } ] }, \"hints\": [ { \"hint\": \"cmtWithSecret\", \"type\": \"dlog\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"a\": \"02c103443ab26655a1ef36f44643700cc5f4730a2a1830085dda1072ccfb30940f\" , \"secret\": \"...\" }, { \"type\": \"dlog\", \"a\": \"035e5bcc7edcf47454fc41bf4b824e7357cb1b6a95df89c79d10cf867713d2d5ac\", \"pubkey\": { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" }, \"hint\": \"cmtSimulated\" }, { \"hint\": \"proofSimulated\", \"challenge\": \"e0556372b3c893e1fdf34bc8850577c9d6cba5c697eb4189\", \"pubkey\": { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" }, \"proof\": \"e0556372b3c893e1fdf34bc8850577c9d6cba5c697eb4189f4608fb322f213c2b1f9166ad526cb7d7a931b02b8966f6ba4cc98aa435156f4\" }, { \"type\": \"dlog\", \"a\": \"0277755feea497330c74d6442dfe9895e8de037a6b4e0d96e555b13f0f17d8869c\", \"pubkey\": { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" }, \"hint\": \"cmtReal\" }, { \"hint\": \"proofReal\", \"challenge\": \"d95830628bec6f4c45d618156a453aa0af8ddcf4eb7c2a4a\", \"pubkey\": { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" }, \"proof\": \"d95830628bec6f4c45d618156a453aa0af8ddcf4eb7c2a4a564c7431c478825d52bd28673637d986f545e871bd07a99cf6c3e04c2342da40\" } ] } (\"secret\" aka \"r\" skipped again) As result, we're getting JSON-encoded transaction which can be broadcasted via POST request to /transactions to get the transaction on the blockchain. Still, the code is not finalized (\"op\": -51 looks ugly, however, it was done previously) and not user-friendly, so as a next step, some applications working with the API are needed. - Let\u2019s sign collectively! Distributed signatures API ~ June, 2020","title":"API"},{"location":"node/api/#improved-distributed-signatures","text":"Initial implementation of distributed signatures support in the node worked well in simple cases, and ZK Treasury built on top of it. However, in complex cases it has some problems: hints generated (such as commitments) were not tied to a position of a sub-expression in a sigma-expression. For example, for statement like \"atLeast(2, Coll(pkAlice, pkBob, pkCharlie)) && (pkBob || pkDiana)\", the same commitment would be generated for Bob. Which is improper and insecure at all - a signature would reveal Bob's secret key (as the same randomness used twice for different challenges in Schnorr protocols). similarly, hints generated were not tied to inputs. This is fixed with new API introduced in distributed-sigs branch. Now all the hints tied with input indexes and also with positions in sigma-tree after script reduction with current context. Also, API is now simpler-to-use I suppose. So let me provide a new tutorial on collective signing. Like in the previous tutorial, first we pay to 2-out-of-3 spending script (with keys stored in registers): { val pkA = SELF.R4[GroupElement].get val pkB = SELF.R5[GroupElement].get val pkC = SELF.R6[GroupElement].get atLeast(2, Coll(proveDlog(pkA), proveDlog(pkB), proveDlog(pkC))) } Then, when a transaction is confirmed (https://explorer.ergoplatform.com/en/transactions/71aa67f95e96827193bdf711f6ccf41b30ef8bbbdaef63ed672dfb7420a4c314) , we get output bytes via /utxo/byIdBinary/{boxId} . Then we generate an unsigned transaction by providing inputs directly, in our example, by providing the following input to /wallet/transaction/generateUnsigned : { \"requests\": [ { \"address\": \"4MQyML64GnzMxZgm\", \"value\": 999000000 } ], \"fee\": 1000000, \"inputsRaw\": [ \"8094ebdc0310010404987300830308cde4c6a70407cde4c6a70507cde4c6a706079a8f1300030702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d71aa67f95e96827193bdf711f6ccf41b30ef8bbbdaef63ed672dfb7420a4c31400\" ], \"dataInputsRaw\": [ ] } Then Alice generates commitments for the unsigned transaction by sending it to the NEW /wallet/generateCommitments (additional secrets to be used along with wallet's can be provided also), and in the output she's getting both secret and public hints: { \"secretHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"03c855c50d173f1b0e2797390b71d82023dcb8e12950e4fa0b9ae3be17bacca2a1\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"position\": \"0-0\", \"hint\": \"cmtWithSecret\", \"secret\": \"...\" } ] }, \"publicHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"03c855c50d173f1b0e2797390b71d82023dcb8e12950e4fa0b9ae3be17bacca2a1\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"position\": \"0-0\", \"hint\": \"cmtReal\" } ] } } (secret randomness is omitted to avoid private key extraction). Then Alice must store secret hints locally and provide public to Bob. Bob is signing using Alice's hints by sending a request to /wallet/transaction/sign like: { \"tx\": { \"id\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"inputs\": [ { \"boxId\": \"9bcbbce28b19132c28b2e088ddea03f792673e9c4509a239145c241c891ca4b9\", \"extension\": {} } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"5bb78563af3843e5bf816c9dd50bd7c0a0b09c7fd2da2da075a8e5d8f545cb7f\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 0 }, { \"boxId\": \"b5a1a069015f94bf7daaec46fc121044607603c844d1c6d6a8e9b2322379b375\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 1 } ] }, \"inputsRaw\": [ \"8094ebdc0310010404987300830308cde4c6a70407cde4c6a70507cde4c6a706079a8f1300030702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d71aa67f95e96827193bdf711f6ccf41b30ef8bbbdaef63ed672dfb7420a4c31400\" ], \"dataInputsRaw\": [ ], \"secrets\": { }, \"hints\": { \"secretHints\": { }, \"publicHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"03c855c50d173f1b0e2797390b71d82023dcb8e12950e4fa0b9ae3be17bacca2a1\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"position\": \"0-0\", \"hint\": \"cmtReal\" } ] } } } and sending signed (but invalid) transaction to Alice (he can send hints generated on the next step instead). Now Alice is extracting commitment from Bob and Carol from the transaction, by sending a request to /script/extractHints like: { \"transaction\": { \"id\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"inputs\": [ { \"boxId\": \"9bcbbce28b19132c28b2e088ddea03f792673e9c4509a239145c241c891ca4b9\", \"spendingProof\": { \"proofBytes\": \"7d64cd47d3dc8bc5c336297e494f48d601c586175b37da228a54a77f52eb1ce307c22c7541368b73307bf37be4051406b49e989b4aee9f27789de0c426a8231fead96178544cbb54b37286f2630dcd9d5794ae9905697e8eeb0d03540d4cb8352a0734187d5e84b6d0825f12e3fcf287ee24e48d3a2a6dfb56471c41767ef88a3279e8fdc70274d85baf16686b641eaa\", \"extension\": {} } } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"5bb78563af3843e5bf816c9dd50bd7c0a0b09c7fd2da2da075a8e5d8f545cb7f\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 0 }, { \"boxId\": \"b5a1a069015f94bf7daaec46fc121044607603c844d1c6d6a8e9b2322379b375\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 1 } ], \"size\": 313 }, \"real\": [ { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" } ], \"simulated\": [ { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" } ] } and then she adds her secret hint to generate valid signed transaction, a request to /wallet/transaction/sign would be like: { \"tx\": { \"id\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"inputs\": [ { \"boxId\": \"9bcbbce28b19132c28b2e088ddea03f792673e9c4509a239145c241c891ca4b9\", \"extension\": {} } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"5bb78563af3843e5bf816c9dd50bd7c0a0b09c7fd2da2da075a8e5d8f545cb7f\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 0 }, { \"boxId\": \"b5a1a069015f94bf7daaec46fc121044607603c844d1c6d6a8e9b2322379b375\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 313682, \"additionalRegisters\": {}, \"transactionId\": \"6c7bf7a9720d26bec5c3b5bf1bc6199e9a5b876ba5994ab5e4214b0d8eed1492\", \"index\": 1 } ] }, \"inputsRaw\": [ \"8094ebdc0310010404987300830308cde4c6a70407cde4c6a70507cde4c6a706079a8f1300030702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d71aa67f95e96827193bdf711f6ccf41b30ef8bbbdaef63ed672dfb7420a4c31400\" ], \"dataInputsRaw\": [ ], \"secrets\": { }, \"hints\": { \"secretHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"03c855c50d173f1b0e2797390b71d82023dcb8e12950e4fa0b9ae3be17bacca2a1\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"position\": \"0-0\", \"hint\": \"cmtWithSecret\", \"secret\": \"....\" } ] }, \"publicHints\": { \"0\": [ { \"type\": \"dlog\", \"a\": \"02b6c2b73e59ad061211cebb37a7d9b238b9388cdb0c3b96ae2152ba174f67de90\", \"pubkey\": { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" }, \"position\": \"0-2\", \"hint\": \"cmtSimulated\" }, { \"hint\": \"proofSimulated\", \"challenge\": \"e39924c725e1aee0cb705ce18a15d5425148939b7739e628\", \"pubkey\": { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" }, \"proof\": \"e39924c725e1aee0cb705ce18a15d5425148939b7739e628ee24e48d3a2a6dfb56471c41767ef88a3279e8fdc70274d85baf16686b641eaa\", \"position\": \"0-2\" }, { \"type\": \"dlog\", \"a\": \"0323bd7f1b87280aa2b7cb2a374da1897ef7d5fae7ab3948440907d303427740ba\", \"pubkey\": { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" }, \"position\": \"0-1\", \"hint\": \"cmtReal\" }, { \"hint\": \"proofReal\", \"challenge\": \"69cd83b8770ab203ccb27094cb235e31613360e0933cf22e\", \"pubkey\": { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" }, \"proof\": \"69cd83b8770ab203ccb27094cb235e31613360e0933cf22e5794ae9905697e8eeb0d03540d4cb8352a0734187d5e84b6d0825f12e3fcf287\", \"position\": \"0-1\" } ] } } } (secret randomness omitted again) And now generated signed valid transaction can be broadcasted. Taken from the forum post Improved distributed signatures ~ Sept, 2020","title":"Improved distributed signatures"},{"location":"node/api/#lets-sign-collectively-distributed-signatures-api","text":"It is well-known (among hardcore Ergonauts) that Ergo Platform has support for variety of composeable and efficient zero-knowledge proofs of knowledge in its authentication language. In particular, it provides possibility for ring and threshold signatures preserving zero-knowledge, so, for example, by observing 2-out-of-3 threshold signature associated with public keys of (Alice, Bob, Carol) on the blockchain, it is not possible to figure out who were those two parties who signed. While Ergo Platform protocol supports threshold and ring signatures since day one, concrete applications doing signing were not available eventually. First, the ErgoMix implementations (by @anon92048 and then @anon2020s ) are using kind of ring signature hiding a spending path. And recently EIP-11 was introduced which is about adding support for distributed signing to the reference client (and not only). The implementation of EIP-11 is mostly done in this PR and in I'm going to explain how to use new API method First, let's make a script for a box protected with 2-out-of-3 threshold signature. One option is about to hardcode public keys in the script, I've chosen another way, namely, to put public keys of signers into registers: { val pkA = SELF.R4[GroupElement].get val pkB = SELF.R5[GroupElement].get val pkC = SELF.R6[GroupElement].get atLeast(2, Coll(proveDlog(pkA), proveDlog(pkB), proveDlog(pkC))) } . Then we need to lock money with concrete keys. It seems the node Swagger API is the most convenient way to do that, e.g. by posting the following payment request to /wallet/payment/send: [ { \"address\": \"umRXw8E7PmdHbswncxFe3jmE51oGFzL4CqfZYfiRr4aL\", \"value\": 1000000000, \"registers\": { \"R4\": \"0702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\", \"R5\": \"070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\", \"R6\": \"070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" } } ] (use /utils/addressToRaw/{address} method to get encoded points from P2PK addresses shown by the wallet and prepend group element type descriptor \"07\" then). Thus we're getting the following box, for example (output #0): https://explorer.ergoplatform.com/en/transactions/0ffc5ba326262f25016c59c58a34b2f7fed2ea1b69f8f007d270f6ef07bced49 . We can get binary representation of unspent box via /utxo/byIdBinary API method, e.g. utxo/byIdBinary/f1892011ed31b8e51f3f3ae44f6d9132070343a7bf6db61b3342696a7873a085 gives us: \"8094ebdc0310010404987300830308cde4c6a70407cde4c6a70507cde4c6a70607abdd0f00030702b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f070354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380070235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d0ffc5ba326262f25016c59c58a34b2f7fed2ea1b69f8f007d270f6ef07bced4900\" We use first two keys for signing (as it is 2-out-of). Please note that members of the signing ring know (and choose) who's signing and who will be simulated. Let's assume that the first key belongs to Alice, and the second key belongs to Bob. The the signing procedure could be as follows: First, Alice generates secret randomness and public commitment to it by posting the following request to /script/generateCommitment : { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" } result is : { \"r\": \"...\", \"a\": \"02c103443ab26655a1ef36f44643700cc5f4730a2a1830085dda1072ccfb30940f\" } (\"r\" is omitted to avoid private key recovery) She sends then \"a\" value to Bob along with unsigned transaction generated via /wallet/transaction/generateUnsigned. Now Bob is generating invalid (partial) signature by sending the following signing request to /wallet/transaction/sign with Alice's commitment included as hint: { \"tx\": { \"id\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"inputs\": [ { \"boxId\": \"f1892011ed31b8e51f3f3ae44f6d9132070343a7bf6db61b3342696a7873a085\", \"extension\": {} } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"49974195f916dcc95e94c72bcf6e90200bbf2c06e5cc7a22a505bad1da77927d\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 0 }, { \"boxId\": \"096192e25b691697b5afdd4a5cf39c69b84fba8b483f475c2e2d3cf47758abb1\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 1 } ] }, \"secrets\": { \"dlog\": [ ], \"dht\": [ ] }, \"hints\": [ { \"hint\": \"cmtReal\", \"type\": \"dlog\", \"pubkey\":{ \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"a\": \"02c103443ab26655a1ef36f44643700cc5f4730a2a1830085dda1072ccfb30940f\" } ] } Bob is sending transaction with invalid signature to Alice. First, she extracts Bob's and Carol's (simulated by Bob actually) commitments and partial signatures by feeding Bob's invalid transaction and Bob's and Carol's pubkeys into /script/extractHints : { \"transaction\": { \"id\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"inputs\": [ { \"boxId\": \"f1892011ed31b8e51f3f3ae44f6d9132070343a7bf6db61b3342696a7873a085\", \"spendingProof\": { \"proofBytes\": \"2c429642fba49717349dbeafb5c4a0725d012e901352fdcc390d53103824fcadb82553ddef404d69794679327c976bc3195dc78926c8161437d595a0a04dac8d3fe08d999d3c70f18c92cddaa1260d3a564c7431c478825d52bd28673637d986f545e871bd07a99cf6c3e04c2342da40f4608fb322f213c2b1f9166ad526cb7d7a931b02b8966f6ba4cc98aa435156f4\", \"extension\": {} } } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"49974195f916dcc95e94c72bcf6e90200bbf2c06e5cc7a22a505bad1da77927d\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 0 }, { \"boxId\": \"096192e25b691697b5afdd4a5cf39c69b84fba8b483f475c2e2d3cf47758abb1\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 1 } ], \"size\": 313 }, \"real\": [ { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" } ], \"simulated\": [ { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" } ] } and then she adds a hint with her commitment and randomness and produces transaction. A request to /wallet/transaction/sign is as follows: { \"tx\": { \"id\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"inputs\": [ { \"boxId\": \"f1892011ed31b8e51f3f3ae44f6d9132070343a7bf6db61b3342696a7873a085\", \"extension\": {} } ], \"dataInputs\": [], \"outputs\": [ { \"boxId\": \"49974195f916dcc95e94c72bcf6e90200bbf2c06e5cc7a22a505bad1da77927d\", \"value\": 999000000, \"ergoTree\": \"10010101d17300\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 0 }, { \"boxId\": \"096192e25b691697b5afdd4a5cf39c69b84fba8b483f475c2e2d3cf47758abb1\", \"value\": 1000000, \"ergoTree\": \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\", \"assets\": [], \"creationHeight\": 257748, \"additionalRegisters\": {}, \"transactionId\": \"ebafdd3a00bd3d9aa26be4056c4f742e9cb0702cce9864567aa4e34cda185d54\", \"index\": 1 } ] }, \"hints\": [ { \"hint\": \"cmtWithSecret\", \"type\": \"dlog\", \"pubkey\": { \"op\": -51, \"h\": \"02b353df14cd94849c36194bba03000dafaeb91b3a425a863f5660565189ddfe8f\" }, \"a\": \"02c103443ab26655a1ef36f44643700cc5f4730a2a1830085dda1072ccfb30940f\" , \"secret\": \"...\" }, { \"type\": \"dlog\", \"a\": \"035e5bcc7edcf47454fc41bf4b824e7357cb1b6a95df89c79d10cf867713d2d5ac\", \"pubkey\": { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" }, \"hint\": \"cmtSimulated\" }, { \"hint\": \"proofSimulated\", \"challenge\": \"e0556372b3c893e1fdf34bc8850577c9d6cba5c697eb4189\", \"pubkey\": { \"op\": -51, \"h\": \"0235647199b150d8fab315d74e44b78866787d0330241fd471f98bf6c2bffe1e8d\" }, \"proof\": \"e0556372b3c893e1fdf34bc8850577c9d6cba5c697eb4189f4608fb322f213c2b1f9166ad526cb7d7a931b02b8966f6ba4cc98aa435156f4\" }, { \"type\": \"dlog\", \"a\": \"0277755feea497330c74d6442dfe9895e8de037a6b4e0d96e555b13f0f17d8869c\", \"pubkey\": { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" }, \"hint\": \"cmtReal\" }, { \"hint\": \"proofReal\", \"challenge\": \"d95830628bec6f4c45d618156a453aa0af8ddcf4eb7c2a4a\", \"pubkey\": { \"op\": -51, \"h\": \"0354efc32652cad6cf1231be987afa29a686af30b5735995e3ce51339c4d0ca380\" }, \"proof\": \"d95830628bec6f4c45d618156a453aa0af8ddcf4eb7c2a4a564c7431c478825d52bd28673637d986f545e871bd07a99cf6c3e04c2342da40\" } ] } (\"secret\" aka \"r\" skipped again) As result, we're getting JSON-encoded transaction which can be broadcasted via POST request to /transactions to get the transaction on the blockchain. Still, the code is not finalized (\"op\": -51 looks ugly, however, it was done previously) and not user-friendly, so as a next step, some applications working with the API are needed. - Let\u2019s sign collectively! Distributed signatures API ~ June, 2020","title":"Let\u2019s sign collectively! Distributed signatures API"},{"location":"node/architecture/","text":"","title":"Architecture"},{"location":"node/digest-state/","text":"","title":"Digest State"},{"location":"node/docs/","text":"An Ergo node provides a built-in wallet for storing private keys and signing transactions. The following describes how to set up and protect your Ergo wallet. The wallet uses the BIP39 standard to generate a seed from a mnemonic sentence, which is then used to generate the private keys according to the BIP32 standard (Hierarchical Deterministic Wallets). You can use your own mnemonic sentence composed of the words from one of these wordists if you want to. The allowed sentence lengths are 12, 15, 18, 21, 24 representing respectively, 128, 160, 192, 224, 256 bits of security. In order to initialize a wallet with such a mnemonic, you should use the wallet/restore API endpoint. However, it is far more secure to use the mneomnic generated by the wallet. At this stage, all interactions with the wallet can only be done through the node's REST API. Please ensure that you have set an API key in your node before performing the next steps. Configuring the wallet The wallet is configured through the node configuration file. Below are the configuration parameters worth paying attention to when configuring wallet for the first time: ergo.wallet.seedStrengthBits - Bit-length of a seed in case it will be generated by the node. Note: the stronger the seed the longer the mnemonic sentence length is. Options: 128, 160, 192, 224, 256 ergo.wallet.secretStorage.secretDir - Directory where secret will be stored in encrypted form ergo.wallet.mnemonicPhraseLanguage - Language to be used in mnemonic sentence. Options: \"chinese_simplified\", \"chinese_traditional\", \"english\", \"french\", \"italian\", \"japanese\", \"korean\", \"spanish\" Using the wallet for the first time The wallet needs to be initialized via the REST API when running the node for the first time. Two options are available here: Initialize it from scratch (seed will be generated by the node) by making a POST request to /wallet/init with data body: {\"pass\": \"123\", \"mnemonicPass\": \"abc\"} . Don't forget to save the mnemonic phrase that the node responds with . (Note: The parameter mnemonicPass in request body is optional and is used for protecting the mnemonic phrase). Restore the wallet from an existing seed. You will have to provide your mnemonic phrase When using this option. This is done by making a POST request to /wallet/restore with data body: {\"pass\": \"123\", \"mnemonic\": \"abandon abandon ...\", \"mnemonicPass\": \"abc\"} (Note: the mnemonicPass field is required only in case your mnemonic phrase was protected by an additional password at creation). Unlocking the wallet After initialization and before every use the wallet needs to be unlocked by making a POST request to /wallet/unlock with data body: {\"pass\": \"123\"} . (Note: use the password you had chosen at initialization stage) You must perform this step every time the node is restarted or the wallet is locked. In particular, the wallet must be unlocked for the following operations: Using internal miner Signing transactions Tracking boxes Locking the wallet A wallet is automatically locked after some time, which means that all currently loaded secrets are flushed from the memory. You can also use the REST API to lock the wallet by making a GET request to /wallet/lock . It is recommended to lock the wallet when it is not in use. After locking, you will need to unlock the wallet to use it again. Managing keys A wallet implements BIP32 (\"Hierarchical deterministic wallets\"). When the wallet is initialized the only root key is created. In order to derive additional key pair corresponding to a specific derivation path (method: POST, request body: {\"derivationPath\": \"m/1/2\"} ) the /wallet/deriveKey API route can be used. In order to simply create additional key pair use a /wallet/deriveNextKey API route (method: GET).","title":"Docs"},{"location":"node/docs/#configuring-the-wallet","text":"The wallet is configured through the node configuration file. Below are the configuration parameters worth paying attention to when configuring wallet for the first time: ergo.wallet.seedStrengthBits - Bit-length of a seed in case it will be generated by the node. Note: the stronger the seed the longer the mnemonic sentence length is. Options: 128, 160, 192, 224, 256 ergo.wallet.secretStorage.secretDir - Directory where secret will be stored in encrypted form ergo.wallet.mnemonicPhraseLanguage - Language to be used in mnemonic sentence. Options: \"chinese_simplified\", \"chinese_traditional\", \"english\", \"french\", \"italian\", \"japanese\", \"korean\", \"spanish\"","title":"Configuring the wallet"},{"location":"node/docs/#using-the-wallet-for-the-first-time","text":"The wallet needs to be initialized via the REST API when running the node for the first time. Two options are available here: Initialize it from scratch (seed will be generated by the node) by making a POST request to /wallet/init with data body: {\"pass\": \"123\", \"mnemonicPass\": \"abc\"} . Don't forget to save the mnemonic phrase that the node responds with . (Note: The parameter mnemonicPass in request body is optional and is used for protecting the mnemonic phrase). Restore the wallet from an existing seed. You will have to provide your mnemonic phrase When using this option. This is done by making a POST request to /wallet/restore with data body: {\"pass\": \"123\", \"mnemonic\": \"abandon abandon ...\", \"mnemonicPass\": \"abc\"} (Note: the mnemonicPass field is required only in case your mnemonic phrase was protected by an additional password at creation).","title":"Using the wallet for the first time"},{"location":"node/docs/#unlocking-the-wallet","text":"After initialization and before every use the wallet needs to be unlocked by making a POST request to /wallet/unlock with data body: {\"pass\": \"123\"} . (Note: use the password you had chosen at initialization stage) You must perform this step every time the node is restarted or the wallet is locked. In particular, the wallet must be unlocked for the following operations: Using internal miner Signing transactions Tracking boxes","title":"Unlocking the wallet"},{"location":"node/docs/#locking-the-wallet","text":"A wallet is automatically locked after some time, which means that all currently loaded secrets are flushed from the memory. You can also use the REST API to lock the wallet by making a GET request to /wallet/lock . It is recommended to lock the wallet when it is not in use. After locking, you will need to unlock the wallet to use it again.","title":"Locking the wallet"},{"location":"node/docs/#managing-keys","text":"A wallet implements BIP32 (\"Hierarchical deterministic wallets\"). When the wallet is initialized the only root key is created. In order to derive additional key pair corresponding to a specific derivation path (method: POST, request body: {\"derivationPath\": \"m/1/2\"} ) the /wallet/deriveKey API route can be used. In order to simply create additional key pair use a /wallet/deriveNextKey API route (method: GET).","title":"Managing keys"},{"location":"node/history-pruning/","text":"","title":"History Pruning"},{"location":"node/light/","text":"","title":"Light"},{"location":"node/nipopow/","text":"","title":"NiPoPoWS"},{"location":"node/nipopows/","text":"","title":"Nipopows"},{"location":"node/node-config/","text":"Wallets Linux Mac Windows HOME environment variable is not often set in Windows. Please replace ${HOME} with ${HOMEPATH} or ${APPDATA} in your configuration file. You should also remember that environment variables names are case sensitive in Windows. Pi How to setup an Ergo node on a Raspberry Pi Node Config File !!!Note!!! This guide is outdated and should be actualized to current config format Actual for version 1.6.1 Below you can find a complete Ergo Node configuration file. This is the default configuration shipped with the application. It is possible to overwrite any parameters by providing an additional configuration file. You can pass an additional configuration file by providing the path to it as the first command line parameter when starting Ergo Node application. ergo { # Directory to keep data directory = ${user.dir}\"/ergo/data\" # Settings for node view holder regime. See papers.yellow.ModifiersProcessing.md node { # State type. Possible options are: # \"utxo\" - keep full utxo set, that allows to validate arbitrary block and generate ADProofs # \"digest\" - keep state root hash only and validate transactions via ADProofs stateType = \"utxo\" # Download block transactions and verify them (requires BlocksToKeep == 0 if disabled) verifyTransactions = true # Number of last blocks to keep with transactions and ADproofs, for all other blocks only header will be stored. # Keep all blocks from genesis if negative blocksToKeep = -1 # Download PoPoW proof on node bootstrap PoPoWBootstrap = false # Minimal suffix size for PoPoW proof (may be pre-defined constant or settings parameter) minimalSuffix = 10 # Is the node is doing mining mining = false # If true, a node generates blocks being offline. The only really useful case for it probably is to start a new # blockchain offlineGeneration = false # Delay for miner after succesful block creation miningDelay = 5s # Number of state snapshot diffs to keep. Defines maximum rollback depth keepVersions = 200 } testing { # Whether to turn on transaction generator transactionGeneration = false # Max number of transactions generated per a new block received maxTransactionsPerBlock = 100 } cache { # Number of recently used modifiers that will be kept in memory modifiersCacheSize = 1000 # Number of recently used indexes that will be kept in memory indexesCacheSize = 10000 } # Chain-specific settings. Change only if you are going to launch a new chain! chain { # Network address prefix, currently reserved values are 0x00 (money chain mainnet) and 0x20 (32 in decimal, # money chain testnet) addressPrefix = 16 # Monetary config for chain monetary { # number of blocks reward won't change (525600 (2 years) for mainnet, 10080 (14 days) for testnet) fixedRatePeriod = 10080 # number of coins issued every block during fixedRatePeriod (75 Ergo) fixedRate = 7500000000 # number of blocks between reward reduction (64800 (90 days) for mainnet, 2160 (3 days) for testnet) epochLength = 2160 # number of coins reward decrease every epochs (3 Ergo) oneEpochReduction = 300000000 # Base16 representation of state roothash after genesis afterGenesisStateDigestHex = \"a8f724cef6f8a247a63fba1b713def858d97258f7cd5d7ed71489a474790db5501\" } # Desired time interval between blocks blockInterval = 2m # length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block epochLength = 256 # Number of last epochs that will be used for difficulty recalculation useLastEpochs = 8 # Proof-of-Work algorithm and its parameters. Possible options are \"fake\" and \"equihash\". powScheme { powType = \"equihash\" n = 96 # used by Equihash k = 5 # used by Equihash } # Defines an id of the genesis block. Other genesis blocks will be considered invalid. # genesisId = \"ab19bb59871e86507defb9a7769841b1130aad4d8c1ea8b0e01e0dee9e97a27e\" } wallet { # Seed the wallet private keys are derived from seed = \"C3FAFMC27697FAF29E9887F977BB5994\" # How many Schorr secret keys (w for the g^w public key) to generate dlogSecretsNumber = 4 # Interval to re-scan uncertain boxes. When a block arrives, its transaction outputs are to be scanned, and if # certain bytes are found in the output script (e.g. public key bytes), the box is to be put to a queue of a boxes # which are potentially wallet's. But to be sure, script execution is needed, which could be costly to do in a bulk. # So we check from a queue only one box per \"scanningInterval\". scanningInterval = 1s } } scorex { network { bindAddress = \"0.0.0.0:9006\" maxInvObjects = 400 nodeName = \"ergo-testnet1\" knownPeers = [\"178.128.162.150:9006\", \"78.46.93.239:9006\", \"209.97.136.204:9006\", \"209.97.138.187:9006\", \"209.97.134.210:9006\", \"88.198.13.202:9006\"] syncInterval = 15s syncStatusRefresh = 30s syncIntervalStable = 20s syncTimeout = 5s syncStatusRefreshStable = 1m deliveryTimeout = 8s maxDeliveryChecks = 2 appVersion = 0.2.1 agentName = \"ergoref\" maxModifiersCacheSize = 512 maxPacketSize = 2048576 } restApi { bindAddress = \"0.0.0.0:9052\" } } Ergo configuration section Root configuration section ergo holds essential application parameters and other configuration subsections. There is also another one root section scorex that holds the parameters inherited from the Scorex project . Using parameter directory it is possible to set a path to the base application directory. It is also possible to use environment variables to override configuration parameters. For example, by default the base directory is being constructed relatively to the user's HOME environment variable. Please do not enclose references to environment variables into quotation marks, otherwise they will be handled as strings and won't be resolved. Network settings In scorex.network section P2P network related settings could be set. Using declaredAddress parameter you can set the external IP address and port number of the node. It's necessary to work behind NAT in most cloud hosting, where the machine does not interface directly with the external address. If you do not specify it, then your node connects to the P2P network, but it won't listen to incoming connections so other nodes will not be able to connect. Other nodes are connected to your node using these data. The format of this parameter is \"[ip-address]:[port]\". Using parameter bindAddress you can set the IP address of local network interface on which Ergo Node will accept incoming connections. By default, node binds to \"0.0.0.0\" that means that it will listen on all available network adapters. Note about Internet Address settings Internet Address settings have <ip-adderss>:<port> format. Note the <port> part at the very end of the address after the colon. For the bindAddress setting port part is used to set the network port number to which other Ergo nodes will connect. Please ensure that the port is reachable from outside, otherwise your node will have only outgoing connections to P2P network. If the given port is taken by other application, your node won't start. Parameter nodeName could be used to set the name of your node visible to other participants of the P2P network. The name transmitted during initial handshake. In the default configuration, this parameter is commented out, which leads to random name generation. The knownPeers parameter stores the list of bootstrap nodes to which your node will establish outgoing connections while initializing. Note about time settings All time span parameters are set in milliseconds. You can also use duration units to shorten their values. Supported units are: * s, second, seconds * m, minute, minutes * h, hour, hours * d, day, days For usage examples see the default configuration file above. Use maxConnections parameter to set the maximum number of simultaneous connections handled by the node. Parameter connectionTimeout could be used to change the network communication timeout. Using handshakeTimeout parameter it is possible to set time period to wait for reply during handshake. In case of no reply the peer will be blacklisted. Using parameters that starts with upnp you can configure the UPnP settings. Actually, those settings are useful only if you ran your Ergo node on the home network where the node could ask your router to establish a tunnel. By default, this functionality is disabled. Use upnpEnabled parameter to enable this functionality. Wallet settings In wallet section you can configure the wallet built in Ergo node. Use dlogSecretsNumber parameter to specify how many Schorr secret keys (w for the g^w public key) to generate. Use scanningInterval parameter to set an interval of re-scaning uncertain boxes. Using seed parameter you could recreate an existing walled on a new node. If you don't have any existing wallet comment out this parameter and start the node. During the first run, the application will create a new wallet with a random seed for you. In this case, the seed will be displayed in the application log. Attention! The wallet is a critical part of your node. You should better store wallet's file in a safe and protected location. Don't forget to backup your wallet's file. It's recommended to remove the seed from the configuration file immediately after the start of the node. If an attacker gains access to this seed string, he has access to all your funds on all your addresses! Blockchain settings At ergo.chain you can select or custom the blockchain parameters. Use blockInterval parameter to set desired time interval between blocks. Parameter epochLength used to set the length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block useLastEpochs parameter stores a number of last epochs that will be used for difficulty recalculation. You can change the PoW algo or related parameters using powScheme section. Node settings In section ergo.node it is possible to configure parameters of the node regime. Use enable parameter to enable or disable block generation on the node. By default, it's disabled. Node with disabled offlineGeneration parameter will start mining as soon as it connects to the first peer in the P2P network. Setting this parameter to true will enable off-line generation. Using miningDelay parameter you can tune your node's mining delay after finding a new block. REST API settings In section scorex.rest-api you can set the node's REST API parameters. Parameter bindAddress could be used to select network interface on which REST API will accept incoming connections. The :<port> part could be used to change the port number, which REST API will listen for connections. Attention! For the better security, do not change bindAddress from \"127.0.0.1\" if you do not know what you're doing! For the external access you should use Nginx's proxy_pass module or SSH port-forwarding instead. Use api-key-hash parameter to set the hash of your API key. The API key is used to protect calls of critical API methods. Remember, that in this parameter you should provide the hash of API key, but during REST calls you should provide API key itself. You can use blake2b to produce the hash of your API key. Attention! API key is transmitted in the HTTP header as unprotected plain text! An attacker could intercept it in network transit and use it to transfer your money to any address! So you have to protect the transmission using HTTPS or use SSH port forwarding. Parameter corsAllowedOrigin could be used to enable or disable CORS support in REST API. CORS allows to safely resolve queries to other domains outside the one running the node. It's necessary for Swagger and Lite client. You can read about it here .","title":"Config"},{"location":"node/node-config/#wallets","text":"","title":"Wallets"},{"location":"node/node-config/#linux","text":"","title":"Linux"},{"location":"node/node-config/#mac","text":"","title":"Mac"},{"location":"node/node-config/#windows","text":"HOME environment variable is not often set in Windows. Please replace ${HOME} with ${HOMEPATH} or ${APPDATA} in your configuration file. You should also remember that environment variables names are case sensitive in Windows.","title":"Windows"},{"location":"node/node-config/#pi","text":"How to setup an Ergo node on a Raspberry Pi","title":"Pi"},{"location":"node/node-config/#node-config-file","text":"!!!Note!!! This guide is outdated and should be actualized to current config format","title":"Node Config File"},{"location":"node/node-config/#actual-for-version-161","text":"Below you can find a complete Ergo Node configuration file. This is the default configuration shipped with the application. It is possible to overwrite any parameters by providing an additional configuration file. You can pass an additional configuration file by providing the path to it as the first command line parameter when starting Ergo Node application. ergo { # Directory to keep data directory = ${user.dir}\"/ergo/data\" # Settings for node view holder regime. See papers.yellow.ModifiersProcessing.md node { # State type. Possible options are: # \"utxo\" - keep full utxo set, that allows to validate arbitrary block and generate ADProofs # \"digest\" - keep state root hash only and validate transactions via ADProofs stateType = \"utxo\" # Download block transactions and verify them (requires BlocksToKeep == 0 if disabled) verifyTransactions = true # Number of last blocks to keep with transactions and ADproofs, for all other blocks only header will be stored. # Keep all blocks from genesis if negative blocksToKeep = -1 # Download PoPoW proof on node bootstrap PoPoWBootstrap = false # Minimal suffix size for PoPoW proof (may be pre-defined constant or settings parameter) minimalSuffix = 10 # Is the node is doing mining mining = false # If true, a node generates blocks being offline. The only really useful case for it probably is to start a new # blockchain offlineGeneration = false # Delay for miner after succesful block creation miningDelay = 5s # Number of state snapshot diffs to keep. Defines maximum rollback depth keepVersions = 200 } testing { # Whether to turn on transaction generator transactionGeneration = false # Max number of transactions generated per a new block received maxTransactionsPerBlock = 100 } cache { # Number of recently used modifiers that will be kept in memory modifiersCacheSize = 1000 # Number of recently used indexes that will be kept in memory indexesCacheSize = 10000 } # Chain-specific settings. Change only if you are going to launch a new chain! chain { # Network address prefix, currently reserved values are 0x00 (money chain mainnet) and 0x20 (32 in decimal, # money chain testnet) addressPrefix = 16 # Monetary config for chain monetary { # number of blocks reward won't change (525600 (2 years) for mainnet, 10080 (14 days) for testnet) fixedRatePeriod = 10080 # number of coins issued every block during fixedRatePeriod (75 Ergo) fixedRate = 7500000000 # number of blocks between reward reduction (64800 (90 days) for mainnet, 2160 (3 days) for testnet) epochLength = 2160 # number of coins reward decrease every epochs (3 Ergo) oneEpochReduction = 300000000 # Base16 representation of state roothash after genesis afterGenesisStateDigestHex = \"a8f724cef6f8a247a63fba1b713def858d97258f7cd5d7ed71489a474790db5501\" } # Desired time interval between blocks blockInterval = 2m # length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block epochLength = 256 # Number of last epochs that will be used for difficulty recalculation useLastEpochs = 8 # Proof-of-Work algorithm and its parameters. Possible options are \"fake\" and \"equihash\". powScheme { powType = \"equihash\" n = 96 # used by Equihash k = 5 # used by Equihash } # Defines an id of the genesis block. Other genesis blocks will be considered invalid. # genesisId = \"ab19bb59871e86507defb9a7769841b1130aad4d8c1ea8b0e01e0dee9e97a27e\" } wallet { # Seed the wallet private keys are derived from seed = \"C3FAFMC27697FAF29E9887F977BB5994\" # How many Schorr secret keys (w for the g^w public key) to generate dlogSecretsNumber = 4 # Interval to re-scan uncertain boxes. When a block arrives, its transaction outputs are to be scanned, and if # certain bytes are found in the output script (e.g. public key bytes), the box is to be put to a queue of a boxes # which are potentially wallet's. But to be sure, script execution is needed, which could be costly to do in a bulk. # So we check from a queue only one box per \"scanningInterval\". scanningInterval = 1s } } scorex { network { bindAddress = \"0.0.0.0:9006\" maxInvObjects = 400 nodeName = \"ergo-testnet1\" knownPeers = [\"178.128.162.150:9006\", \"78.46.93.239:9006\", \"209.97.136.204:9006\", \"209.97.138.187:9006\", \"209.97.134.210:9006\", \"88.198.13.202:9006\"] syncInterval = 15s syncStatusRefresh = 30s syncIntervalStable = 20s syncTimeout = 5s syncStatusRefreshStable = 1m deliveryTimeout = 8s maxDeliveryChecks = 2 appVersion = 0.2.1 agentName = \"ergoref\" maxModifiersCacheSize = 512 maxPacketSize = 2048576 } restApi { bindAddress = \"0.0.0.0:9052\" } }","title":"Actual for version 1.6.1"},{"location":"node/node-config/#ergo-configuration-section","text":"Root configuration section ergo holds essential application parameters and other configuration subsections. There is also another one root section scorex that holds the parameters inherited from the Scorex project . Using parameter directory it is possible to set a path to the base application directory. It is also possible to use environment variables to override configuration parameters. For example, by default the base directory is being constructed relatively to the user's HOME environment variable. Please do not enclose references to environment variables into quotation marks, otherwise they will be handled as strings and won't be resolved.","title":"Ergo configuration section"},{"location":"node/node-config/#network-settings","text":"In scorex.network section P2P network related settings could be set. Using declaredAddress parameter you can set the external IP address and port number of the node. It's necessary to work behind NAT in most cloud hosting, where the machine does not interface directly with the external address. If you do not specify it, then your node connects to the P2P network, but it won't listen to incoming connections so other nodes will not be able to connect. Other nodes are connected to your node using these data. The format of this parameter is \"[ip-address]:[port]\". Using parameter bindAddress you can set the IP address of local network interface on which Ergo Node will accept incoming connections. By default, node binds to \"0.0.0.0\" that means that it will listen on all available network adapters. Note about Internet Address settings Internet Address settings have <ip-adderss>:<port> format. Note the <port> part at the very end of the address after the colon. For the bindAddress setting port part is used to set the network port number to which other Ergo nodes will connect. Please ensure that the port is reachable from outside, otherwise your node will have only outgoing connections to P2P network. If the given port is taken by other application, your node won't start. Parameter nodeName could be used to set the name of your node visible to other participants of the P2P network. The name transmitted during initial handshake. In the default configuration, this parameter is commented out, which leads to random name generation. The knownPeers parameter stores the list of bootstrap nodes to which your node will establish outgoing connections while initializing. Note about time settings All time span parameters are set in milliseconds. You can also use duration units to shorten their values. Supported units are: * s, second, seconds * m, minute, minutes * h, hour, hours * d, day, days For usage examples see the default configuration file above. Use maxConnections parameter to set the maximum number of simultaneous connections handled by the node. Parameter connectionTimeout could be used to change the network communication timeout. Using handshakeTimeout parameter it is possible to set time period to wait for reply during handshake. In case of no reply the peer will be blacklisted. Using parameters that starts with upnp you can configure the UPnP settings. Actually, those settings are useful only if you ran your Ergo node on the home network where the node could ask your router to establish a tunnel. By default, this functionality is disabled. Use upnpEnabled parameter to enable this functionality. Wallet settings In wallet section you can configure the wallet built in Ergo node. Use dlogSecretsNumber parameter to specify how many Schorr secret keys (w for the g^w public key) to generate. Use scanningInterval parameter to set an interval of re-scaning uncertain boxes. Using seed parameter you could recreate an existing walled on a new node. If you don't have any existing wallet comment out this parameter and start the node. During the first run, the application will create a new wallet with a random seed for you. In this case, the seed will be displayed in the application log. Attention! The wallet is a critical part of your node. You should better store wallet's file in a safe and protected location. Don't forget to backup your wallet's file. It's recommended to remove the seed from the configuration file immediately after the start of the node. If an attacker gains access to this seed string, he has access to all your funds on all your addresses! Blockchain settings At ergo.chain you can select or custom the blockchain parameters. Use blockInterval parameter to set desired time interval between blocks. Parameter epochLength used to set the length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block useLastEpochs parameter stores a number of last epochs that will be used for difficulty recalculation. You can change the PoW algo or related parameters using powScheme section. Node settings In section ergo.node it is possible to configure parameters of the node regime. Use enable parameter to enable or disable block generation on the node. By default, it's disabled. Node with disabled offlineGeneration parameter will start mining as soon as it connects to the first peer in the P2P network. Setting this parameter to true will enable off-line generation. Using miningDelay parameter you can tune your node's mining delay after finding a new block. REST API settings In section scorex.rest-api you can set the node's REST API parameters. Parameter bindAddress could be used to select network interface on which REST API will accept incoming connections. The :<port> part could be used to change the port number, which REST API will listen for connections. Attention! For the better security, do not change bindAddress from \"127.0.0.1\" if you do not know what you're doing! For the external access you should use Nginx's proxy_pass module or SSH port-forwarding instead. Use api-key-hash parameter to set the hash of your API key. The API key is used to protect calls of critical API methods. Remember, that in this parameter you should provide the hash of API key, but during REST calls you should provide API key itself. You can use blake2b to produce the hash of your API key. Attention! API key is transmitted in the HTTP header as unprotected plain text! An attacker could intercept it in network transit and use it to transfer your money to any address! So you have to protect the transmission using HTTPS or use SSH port forwarding. Parameter corsAllowedOrigin could be used to enable or disable CORS support in REST API. CORS allows to safely resolve queries to other domains outside the one running the node. It's necessary for Swagger and Lite client. You can read about it here .","title":"Network settings"},{"location":"node/run/","text":"How to set up and configure a full Ergo node This tutorial explains how to install and run a full Ergo node. It does not cover mining. Windows users can also watch the video tutorial. Node security There are a few important aspects of node usage that your wallet and money's safety depends on: * An Ergo node requires storing security-critical parameters in the configuration file. You should never make this file public. * An Ergo node provides a REST API for interacting with the built-in wallet. Sensitive API methods require a security token, which should never be sent over untrusted channels. * Access to the Ergo REST API must be restricted to known hosts. In particular, the API must not be accessible from the Internet. Prerequisites To run an Ergo node you need a JDK/JRE version >= 9 installed on your system. We recommend either version 9 or 11. One way to do this is to install Oracle Java SE . Note that Oracle JDK/JRE <= 8 is no longer supported . The next step is to download the latest Ergo client release jar file and create a node configuration file. Note that instead of downloading the precompiled Ergo jar, you can clone the repository and compile the jar from the source using SBT by issuing the sbt assembly command. Create a dedicated folder (such as ~/ergo ) for running the node. Denote by ergo_folder the folder where the jar is kept. Running the node for the first time Create a configuration file ergo.conf with the following text in ergo_folder . ergo { node { mining = false } } Open a command prompt and cd to ergo_folder . Then issue the following command to run the node for the first time: java -jar ergo-<release>.jar --mainnet -c ergo.conf The node will start syncing immediately after this. Wait for a few minutes for the API to start and go to the next step. Note: You can use any name for the file instead of ergo.conf . All configuration parameters are to be passed through this file and you only need to rewrite parameters that you want to change from the default values. The above config file actually has the default values. Compute the hash of your secret First, select a secret to protect your API. Then go to http://127.0.0.1:9053/swagger#/utils/hashBlake2b and call the API to compute the hash of your secret. Refer to the image below. Copy the response containing the hash for use in the next step (see below image). In our example, the secret is hello whose hash corresponds to 324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf . IMPORTANT You must use a different and strong secret. Update config file with API key hash Edit the config file ergo.conf and paste the hash copied in the previous step. The file should look as follows: ergo { node { mining = false } } scorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string 'hello' # replace with your actual hash apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } } Initialize wallet Restart the node and go to http://127.0.0.1:9053/panel to access the panel. Then set the API key secret from the previous step. Note that you need to set the secret and not the hash from the config file. In our example, this is the string hello . Click on Initialize wallet . After the pop-up opens, there are two ways to proceed depending on your scenario. If this is the first time you are running the node then you need to initialize it with a new mnemonic sentence. If you had created a wallet earlier and would like to obtain the same address (possibly because there are funds stored in it), then you have to restore the wallet using the mnemonic sentence you had saved earlier. Follow one of the below steps depending on your situation. Initialize wallet from scratch In the pop-up that opens, you must enter a wallet password. The mnemonic password is optional. After you click send, the wallet will return a mnemonic sentence as shown below. You must copy this sentence and save it in a safe place. This sentence will be needed to restore the wallet on a different computer. Restore wallet from earlier Copy the mnemonic sentence from earlier paste it into the \"Mnemonic\" field in the Restore-wallet form. Enter a secure wallet password. Leave the Mnemonic password empty (it is only for advanced users). Refer to the figure below. After the wallet has been successfully restored from the mnemonic sentence, you will see a confirmation as shown in the figure below. Get wallet addresses This is a test to ensure you have set up the node properly. It will return the current addresses in the wallet. In the panel at http://127.0.0.1:9053/panel click on the Wallet tab on the left and then on Get all wallet addresses to view the addresses currently maintained by the wallet. It should return at least one address if the node is set correctly. Check if the node is synced While the node is syncing, the panel will show \"Active synchronization\" (see the image below). After the node is fully synced, the text will change to \"Node is synced\", as shown below. Check wallet balance Once the node is synced, use the wallet API in the panel to see your balance, as shown below. Sending funds If there is a non-zero balance, you can send Ergs to any other address using the panel as shown below: View the Swagger UI A Swagger UI is available at http://127.0.0.1:9053/swagger . You had already used it earlier to compute the hash of your secret. You can also use this UI to make API calls for advanced operations that are not (yet) available in the panel. Some examples of this are: Creating non-standard transactions with registers and context variables. Creating transactions that issue tokens. Creating transactions that use certain boxes as inputs. A future article will discuss each of these operations in detail. Note that most methods in the API are protected and you would need to use your secret (from earlier) to access these methods. The following images show the process of setting this secret in the Swagger UI. Navigate to the top of the page and click the \"Authorize\" button. Enter your secret in the form that pops-up as shown in the figure below. After the password is entered and you have clicked \"Authorize\", you will be shown the popup below: Now navigate to http://127.0.0.1:9053/swagger#/wallet/walletAddresses in the same tab where you entered the password and click on \"Try it out\". You should see the same list of addresses as you saw earlier from the panel.","title":"First Run"},{"location":"node/run/#how-to-set-up-and-configure-a-full-ergo-node","text":"This tutorial explains how to install and run a full Ergo node. It does not cover mining. Windows users can also watch the video tutorial.","title":"How to set up and configure a full Ergo node"},{"location":"node/run/#node-security","text":"There are a few important aspects of node usage that your wallet and money's safety depends on: * An Ergo node requires storing security-critical parameters in the configuration file. You should never make this file public. * An Ergo node provides a REST API for interacting with the built-in wallet. Sensitive API methods require a security token, which should never be sent over untrusted channels. * Access to the Ergo REST API must be restricted to known hosts. In particular, the API must not be accessible from the Internet.","title":"Node security"},{"location":"node/run/#prerequisites","text":"To run an Ergo node you need a JDK/JRE version >= 9 installed on your system. We recommend either version 9 or 11. One way to do this is to install Oracle Java SE . Note that Oracle JDK/JRE <= 8 is no longer supported . The next step is to download the latest Ergo client release jar file and create a node configuration file. Note that instead of downloading the precompiled Ergo jar, you can clone the repository and compile the jar from the source using SBT by issuing the sbt assembly command. Create a dedicated folder (such as ~/ergo ) for running the node. Denote by ergo_folder the folder where the jar is kept.","title":"Prerequisites"},{"location":"node/run/#running-the-node-for-the-first-time","text":"Create a configuration file ergo.conf with the following text in ergo_folder . ergo { node { mining = false } } Open a command prompt and cd to ergo_folder . Then issue the following command to run the node for the first time: java -jar ergo-<release>.jar --mainnet -c ergo.conf The node will start syncing immediately after this. Wait for a few minutes for the API to start and go to the next step. Note: You can use any name for the file instead of ergo.conf . All configuration parameters are to be passed through this file and you only need to rewrite parameters that you want to change from the default values. The above config file actually has the default values.","title":"Running the node for the first time"},{"location":"node/run/#compute-the-hash-of-your-secret","text":"First, select a secret to protect your API. Then go to http://127.0.0.1:9053/swagger#/utils/hashBlake2b and call the API to compute the hash of your secret. Refer to the image below. Copy the response containing the hash for use in the next step (see below image). In our example, the secret is hello whose hash corresponds to 324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf . IMPORTANT You must use a different and strong secret.","title":"Compute the hash of your secret"},{"location":"node/run/#update-config-file-with-api-key-hash","text":"Edit the config file ergo.conf and paste the hash copied in the previous step. The file should look as follows: ergo { node { mining = false } } scorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string 'hello' # replace with your actual hash apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } }","title":"Update config file with API key hash"},{"location":"node/run/#initialize-wallet","text":"Restart the node and go to http://127.0.0.1:9053/panel to access the panel. Then set the API key secret from the previous step. Note that you need to set the secret and not the hash from the config file. In our example, this is the string hello . Click on Initialize wallet . After the pop-up opens, there are two ways to proceed depending on your scenario. If this is the first time you are running the node then you need to initialize it with a new mnemonic sentence. If you had created a wallet earlier and would like to obtain the same address (possibly because there are funds stored in it), then you have to restore the wallet using the mnemonic sentence you had saved earlier. Follow one of the below steps depending on your situation.","title":"Initialize wallet"},{"location":"node/run/#initialize-wallet-from-scratch","text":"In the pop-up that opens, you must enter a wallet password. The mnemonic password is optional. After you click send, the wallet will return a mnemonic sentence as shown below. You must copy this sentence and save it in a safe place. This sentence will be needed to restore the wallet on a different computer.","title":"Initialize wallet from scratch"},{"location":"node/run/#restore-wallet-from-earlier","text":"Copy the mnemonic sentence from earlier paste it into the \"Mnemonic\" field in the Restore-wallet form. Enter a secure wallet password. Leave the Mnemonic password empty (it is only for advanced users). Refer to the figure below. After the wallet has been successfully restored from the mnemonic sentence, you will see a confirmation as shown in the figure below.","title":"Restore wallet from earlier"},{"location":"node/run/#get-wallet-addresses","text":"This is a test to ensure you have set up the node properly. It will return the current addresses in the wallet. In the panel at http://127.0.0.1:9053/panel click on the Wallet tab on the left and then on Get all wallet addresses to view the addresses currently maintained by the wallet. It should return at least one address if the node is set correctly.","title":"Get wallet addresses"},{"location":"node/run/#check-if-the-node-is-synced","text":"While the node is syncing, the panel will show \"Active synchronization\" (see the image below). After the node is fully synced, the text will change to \"Node is synced\", as shown below.","title":"Check if the node is synced"},{"location":"node/run/#check-wallet-balance","text":"Once the node is synced, use the wallet API in the panel to see your balance, as shown below.","title":"Check wallet balance"},{"location":"node/run/#sending-funds","text":"If there is a non-zero balance, you can send Ergs to any other address using the panel as shown below:","title":"Sending funds"},{"location":"node/run/#view-the-swagger-ui","text":"A Swagger UI is available at http://127.0.0.1:9053/swagger . You had already used it earlier to compute the hash of your secret. You can also use this UI to make API calls for advanced operations that are not (yet) available in the panel. Some examples of this are: Creating non-standard transactions with registers and context variables. Creating transactions that issue tokens. Creating transactions that use certain boxes as inputs. A future article will discuss each of these operations in detail. Note that most methods in the API are protected and you would need to use your secret (from earlier) to access these methods. The following images show the process of setting this secret in the Swagger UI. Navigate to the top of the page and click the \"Authorize\" button. Enter your secret in the form that pops-up as shown in the figure below. After the password is entered and you have clicked \"Authorize\", you will be shown the popup below: Now navigate to http://127.0.0.1:9053/swagger#/wallet/walletAddresses in the same tab where you entered the password and click on \"Try it out\". You should see the same list of addresses as you saw earlier from the panel.","title":"View the Swagger UI"},{"location":"node/snapshots/","text":"","title":"Snapshots"},{"location":"node/withdraw/","text":"Spending mining reward This text is to help miners to withdraw funds mined. A lot of folks launched a node and also a miner, with pubkeyHex from the miner embedded in the node config. Now information on how to recognize the coins mined and withdraw them to another address. On keys. A miner can see a lot of keys in different formats. First, mining software and also mining support in the node (namely, ergo.node.miningPubKeyHex setting in the config) are using a Base16-encoded \"raw\" public key, which is just an encoded serialized point on elliptic curve. This key is enough for a miner (which can avoid then supporting Base58, address forming etc). Second, a node wallet shows Pay-To-Public-Key (P2PK) addresses, which are starting with \"9\". P2PK adress contains not just elliptic curve point, but also network prefix and checksum , similarly to Bitcoin P2PK and P2PKH addresses. Third, there is minig/rewardAddress API method, which is intended for external tools generating block candidates. This API method shows something like 88dhgzEuTXaSfKEbxfa6vghvEGdBH39sn9h7As2Y2Z6SGd8bKXCXmRLY5JtU4g4RYBP4WcZWb3JwjXDK , which is a special script to pay a miner in encoded form. Anyway, if you put pubkeyHex from you miner into your node, everything is okay, just don't worry about different keys seen. Getting you balance shown & withdrawals Probably you don't see mined coins after wallet initialization, if its done on height after blocks mined. Please note, the node is not scanning blocks backwards, it is only scanning new blocks after the initialization. Thus in order to find mined coins, full blockchain rescan is needed atm (or, if you mine, launch another node on another machine, or on the same machine with different ports set in the config, namely, set new values to scorex.restApi.bindAddress and scorex.network.bindAddress fields; also please use version 3.0.1 as it is easier to configurate). In order to spend rewards you need to follow the steps below: 1. Clear node state, if you're going to stop working node. In order to clear the state of your node you need to stop the node and then remove all contents of .ergo directory (it could be hidden from you on Mac and Linux, try ls -a command in the directory you ran the node from). 2. Restoring a local wallet from the seed-phrase used in the Autolykos miner Remember that mnemonic sentence you set in the config.json when configuring your Autolykos miner - now you need to restore build-in wallet from it. In order to restore your wallet start the node again and send a POST request to http://[your_node_ip]:9053/wallet/restore containing the application/json content-type body like: { \"pass\": \"your_wallet_pass\", \"mnemonic\": \"mnemonic_sentense_from_your_miner\", \"mnemonicPass\": \"mnemonic_pass_if_set\" } , where pass is a new unique pass to be used to encrypt wallet data on your local disk, and mnemonic is a mnemonic phrase you copied from your Autolykos miner config ( config.json ). Please especially pay your attention to mnemonicPass field - this is a password of your mnemonic phrase, it's optional and you could have configured it when generating your mnemonic. So add this field to the request only in case your mnemonic is really protected with a pass, remove this field otherwise. Don't forget to authorize your request setting correct api_key HTTP header corresponding to the apiKeyHash your configured in the node config file. ATTENTION: In order to let the wallet scan all the blocks from the genesis you need to restore the wallet before your node would have started downloading full blocks (Check fullHeight in /info API method response - while it is null your node haven't start downloading full blocks) 3. Check your balance When your node got synced with the network check /wallet/balances API method. The response should look like: { \"height\": 3560, \"balance\": 67500000000, \"assets\": {} } Pay attention to the height field first - it should equal fullHeight displaying by /info API route. balance is a confirmed balance found by your wallet. 4. Make a transaction spending your reward In order to withdraw a reward from your wallet, create a new payment transaction using /wallet/payment/send API route. In order to perform this operation send a POST request containing an application/json content-type body like: { \"address\": \"your_address\", \"value\": 10000000 } , where address is the address you want to move your funds to and value is how many nanoERGs you wish to move. When the request is sent the node would return transation id in response. You can use explorer to check when your transaction gets to the block.","title":"Withdraw"},{"location":"node/withdraw/#spending-mining-reward","text":"This text is to help miners to withdraw funds mined. A lot of folks launched a node and also a miner, with pubkeyHex from the miner embedded in the node config. Now information on how to recognize the coins mined and withdraw them to another address.","title":"Spending mining reward"},{"location":"node/withdraw/#on-keys","text":"A miner can see a lot of keys in different formats. First, mining software and also mining support in the node (namely, ergo.node.miningPubKeyHex setting in the config) are using a Base16-encoded \"raw\" public key, which is just an encoded serialized point on elliptic curve. This key is enough for a miner (which can avoid then supporting Base58, address forming etc). Second, a node wallet shows Pay-To-Public-Key (P2PK) addresses, which are starting with \"9\". P2PK adress contains not just elliptic curve point, but also network prefix and checksum , similarly to Bitcoin P2PK and P2PKH addresses. Third, there is minig/rewardAddress API method, which is intended for external tools generating block candidates. This API method shows something like 88dhgzEuTXaSfKEbxfa6vghvEGdBH39sn9h7As2Y2Z6SGd8bKXCXmRLY5JtU4g4RYBP4WcZWb3JwjXDK , which is a special script to pay a miner in encoded form. Anyway, if you put pubkeyHex from you miner into your node, everything is okay, just don't worry about different keys seen.","title":"On keys."},{"location":"node/withdraw/#getting-you-balance-shown-withdrawals","text":"Probably you don't see mined coins after wallet initialization, if its done on height after blocks mined. Please note, the node is not scanning blocks backwards, it is only scanning new blocks after the initialization. Thus in order to find mined coins, full blockchain rescan is needed atm (or, if you mine, launch another node on another machine, or on the same machine with different ports set in the config, namely, set new values to scorex.restApi.bindAddress and scorex.network.bindAddress fields; also please use version 3.0.1 as it is easier to configurate).","title":"Getting you balance shown &amp; withdrawals"},{"location":"node/withdraw/#in-order-to-spend-rewards-you-need-to-follow-the-steps-below","text":"","title":"In order to spend rewards you need to follow the steps below:"},{"location":"node/withdraw/#1-clear-node-state-if-youre-going-to-stop-working-node","text":"In order to clear the state of your node you need to stop the node and then remove all contents of .ergo directory (it could be hidden from you on Mac and Linux, try ls -a command in the directory you ran the node from).","title":"1. Clear node state, if you're going to stop working node."},{"location":"node/withdraw/#2-restoring-a-local-wallet-from-the-seed-phrase-used-in-the-autolykos-miner","text":"Remember that mnemonic sentence you set in the config.json when configuring your Autolykos miner - now you need to restore build-in wallet from it. In order to restore your wallet start the node again and send a POST request to http://[your_node_ip]:9053/wallet/restore containing the application/json content-type body like: { \"pass\": \"your_wallet_pass\", \"mnemonic\": \"mnemonic_sentense_from_your_miner\", \"mnemonicPass\": \"mnemonic_pass_if_set\" } , where pass is a new unique pass to be used to encrypt wallet data on your local disk, and mnemonic is a mnemonic phrase you copied from your Autolykos miner config ( config.json ). Please especially pay your attention to mnemonicPass field - this is a password of your mnemonic phrase, it's optional and you could have configured it when generating your mnemonic. So add this field to the request only in case your mnemonic is really protected with a pass, remove this field otherwise. Don't forget to authorize your request setting correct api_key HTTP header corresponding to the apiKeyHash your configured in the node config file. ATTENTION: In order to let the wallet scan all the blocks from the genesis you need to restore the wallet before your node would have started downloading full blocks (Check fullHeight in /info API method response - while it is null your node haven't start downloading full blocks)","title":"2. Restoring a local wallet from the seed-phrase used in the Autolykos miner"},{"location":"node/withdraw/#3-check-your-balance","text":"When your node got synced with the network check /wallet/balances API method. The response should look like: { \"height\": 3560, \"balance\": 67500000000, \"assets\": {} } Pay attention to the height field first - it should equal fullHeight displaying by /info API route. balance is a confirmed balance found by your wallet.","title":"3. Check your balance"},{"location":"node/withdraw/#4-make-a-transaction-spending-your-reward","text":"In order to withdraw a reward from your wallet, create a new payment transaction using /wallet/payment/send API route. In order to perform this operation send a POST request containing an application/json content-type body like: { \"address\": \"your_address\", \"value\": 10000000 } , where address is the address you want to move your funds to and value is how many nanoERGs you wish to move. When the request is sent the node would return transation id in response. You can use explorer to check when your transaction gets to the block.","title":"4. Make a transaction spending your reward"},{"location":"uses/PoW_tokens/","text":"Proof-of-Work Backed Tokens In Ergo, one token per transaction can be issued, and the token id must be the same as id of the box of the first input. Thus if you have generated a box you know id of the future token. And this id is calculated via hashing. Thus via iterating over a register (e.g. R4) used as a nonce, you can create a token with specific id properties, e.g. starting with certain number of zeroes. So some work could be required in order to make such a token. Something like VanityGen-adress in Bitcoin, but now VanityGen token ) Then some contracts may accept such PoW-backed NFTs only. I haven't thought about use-cases though. Maybe some related to filtering out spam. Full discussions here","title":"PoW Tokens"},{"location":"uses/PoW_tokens/#proof-of-work-backed-tokens","text":"In Ergo, one token per transaction can be issued, and the token id must be the same as id of the box of the first input. Thus if you have generated a box you know id of the future token. And this id is calculated via hashing. Thus via iterating over a register (e.g. R4) used as a nonce, you can create a token with specific id properties, e.g. starting with certain number of zeroes. So some work could be required in order to make such a token. Something like VanityGen-adress in Bitcoin, but now VanityGen token ) Then some contracts may accept such PoW-backed NFTs only. I haven't thought about use-cases though. Maybe some related to filtering out spam. Full discussions here","title":"Proof-of-Work Backed Tokens"},{"location":"uses/apps/","text":"Applications Check out sigmaverse.io - your portal to the Ergo Universe Live dApps ErgoDex Beta live on Ergo ErgoLabs EIP-0014: Decentalized Exchange Contracts Single-Chain Swap Contracts (DEX basis) by Alex Chepurnoy SigmaUSD sigmausd.io , The first UTxO-based stable coin - an instantiation of the AgeUSD protocol . Its economic model designed in partnership between IOHK, Ergo, and Emurgo maintains the conservative settings for collateral reserves and avoids the need for liquidations. Along with that, it supports a fully decentralised stablecoin emission setup. The UI for the front-end is available at anon-real/sigma-usd Ergo Summit 2021 - The IOHK Perspective - Designing the AgeUSD StableCoin Overview Video (with diagrams) Building Ergo: How the AgeUSD stablecoin works Dexy Dexy: USD Simplest Stablecoin A Simplest Stablecoin? ErgoMixer Due to secret generation under the hood, it must be run as a local application. ErgoMixer is the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space. Technical Slides: ZeroJoin: Combining Zerocoin and Coinjoin Video tutorial ErgoAuctions Ergo Auction House lets you buy and sell collectible tokens, art, and much more. Source code v2 contracts Profit-Sharing for Ergo Auctions House Raffle ErgoRaffle GitHub In Development ErgoFund In development Ergo Crowdfunding CLI | Command-line tool which enables participating and interacting with crowdfunding campaigns on Ergo Scanner ZK Treasury | a tool for joint spendings with on-chain privacy Server Client 'A Collective Spending Appproach' ErgoProfitSharingDapp This service will provide a way for dapps to distribute gains among dapps' token holders. The first user of this service will be the ErgoMixer. Ergomixer's income (in ERG and other tokens) is currently received by its creator, aka 'anon2020s', since it has only one stakeholder at the moment. He has announced that he is willing to create and sell some tokens shortly to obtain more stakeholders; let's call this token MIX. Later, anyone with the MIX tokens can stake them in the Profit Sharing contract and obtain the mixer's incomes proportional to their staked tokens. So, it is NOT a way to stake ERG at first. But, it CAN BE USED in the future in some creative services to provide ERG-staking. Ergo Profit Sharing dApp Use-cases - A solution for staking - Paying fee in ErgoMix in primary tokens - Profit-Sharing for Ergo Auctions House LETS Development starting soon. Tooling Zero-Knowledge In development Oracles v2 contracts in review. When external oracle data is posted on-chain, it needs to be encoded exactly within a transaction. Furthermore, oracle pools have many different moving parts that require transactions to be issued to move between the different stages of the pool protocol. Oracle Core creates all of the complex transactions which post the data on-chain & run the oracle pool protocol on-chain (such as averaging data points). This comes bundled with Oracle Pool Bootstrap and a Connector Library . The ada-usd-oracle source can be seen here. Currently, only the erg-USD-oracle is live as seen in the Oracle Pool List See this overview by Robert Kornacki. Resources eth/usd connector Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. Learn about data inputs and the truly novel innovations they bring to UTXO-based Blockchains Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. See also a forum topic with example v2 Oracle pool 2.0 contracts finalized (for initial draft). Tests for oracle pool 2.0 Articles Chainlink Oracles vs. Ergo Oracle Pools Oracle Pools - A New Oracle Model First steps towards interoperability with Cardano oracles Ergo Blockchain: Oracle Pool Governance Update The role of Ergo Oracles Misc ErgoFaucet.org Various utilities are listed on ergosites.github.io ergo.watch | Git ERGOHACK ERGOHACK I ErgoRaffle Ergo Index Fund Smart Pools Sigma Stamp Ergo Charts Simpler Joint Spending Tool ERGOHACK II ErgoLend Minotaur Wallet Ergopad Ergo Subpooling HYPO10USE: QUIDGAMES Ergo Audio Many more possible! Bonds based on Ergo (or the \u201cYield protocol\u201d) An ICO Example On Top Of Ergo A Local Exchange Trading System On Top Of Ergo A Trustless Local Exchange Trading System (E)mail Client for Limited or Blocked Internet LETS start the discussion ErgoFans | Decentralised content producer platform | Patreon/Onlyfans ErgoGigs | Decentralised gigs! (Fiverr) ErgoEarn | earn for learning (Coinbase Earn) ErgoStats | on-chain analysis (glassnode)","title":"dApps"},{"location":"uses/apps/#applications","text":"Check out sigmaverse.io - your portal to the Ergo Universe","title":"Applications"},{"location":"uses/apps/#live-dapps","text":"","title":"Live dApps"},{"location":"uses/apps/#ergodex","text":"Beta live on Ergo ErgoLabs EIP-0014: Decentalized Exchange Contracts Single-Chain Swap Contracts (DEX basis) by Alex Chepurnoy","title":"ErgoDex"},{"location":"uses/apps/#sigmausd","text":"sigmausd.io , The first UTxO-based stable coin - an instantiation of the AgeUSD protocol . Its economic model designed in partnership between IOHK, Ergo, and Emurgo maintains the conservative settings for collateral reserves and avoids the need for liquidations. Along with that, it supports a fully decentralised stablecoin emission setup. The UI for the front-end is available at anon-real/sigma-usd Ergo Summit 2021 - The IOHK Perspective - Designing the AgeUSD StableCoin Overview Video (with diagrams) Building Ergo: How the AgeUSD stablecoin works Dexy Dexy: USD Simplest Stablecoin A Simplest Stablecoin?","title":"SigmaUSD"},{"location":"uses/apps/#ergomixer","text":"Due to secret generation under the hood, it must be run as a local application. ErgoMixer is the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space. Technical Slides: ZeroJoin: Combining Zerocoin and Coinjoin Video tutorial","title":"ErgoMixer"},{"location":"uses/apps/#ergoauctions","text":"Ergo Auction House lets you buy and sell collectible tokens, art, and much more. Source code v2 contracts Profit-Sharing for Ergo Auctions House","title":"ErgoAuctions"},{"location":"uses/apps/#raffle","text":"ErgoRaffle GitHub","title":"Raffle"},{"location":"uses/apps/#in-development","text":"","title":"In Development"},{"location":"uses/apps/#ergofund","text":"In development Ergo Crowdfunding CLI | Command-line tool which enables participating and interacting with crowdfunding campaigns on Ergo Scanner ZK Treasury | a tool for joint spendings with on-chain privacy Server Client 'A Collective Spending Appproach'","title":"ErgoFund"},{"location":"uses/apps/#ergoprofitsharingdapp","text":"This service will provide a way for dapps to distribute gains among dapps' token holders. The first user of this service will be the ErgoMixer. Ergomixer's income (in ERG and other tokens) is currently received by its creator, aka 'anon2020s', since it has only one stakeholder at the moment. He has announced that he is willing to create and sell some tokens shortly to obtain more stakeholders; let's call this token MIX. Later, anyone with the MIX tokens can stake them in the Profit Sharing contract and obtain the mixer's incomes proportional to their staked tokens. So, it is NOT a way to stake ERG at first. But, it CAN BE USED in the future in some creative services to provide ERG-staking. Ergo Profit Sharing dApp Use-cases - A solution for staking - Paying fee in ErgoMix in primary tokens - Profit-Sharing for Ergo Auctions House","title":"ErgoProfitSharingDapp"},{"location":"uses/apps/#lets","text":"Development starting soon.","title":"LETS"},{"location":"uses/apps/#tooling","text":"","title":"Tooling"},{"location":"uses/apps/#zero-knowledge","text":"In development","title":"Zero-Knowledge"},{"location":"uses/apps/#oracles","text":"v2 contracts in review. When external oracle data is posted on-chain, it needs to be encoded exactly within a transaction. Furthermore, oracle pools have many different moving parts that require transactions to be issued to move between the different stages of the pool protocol. Oracle Core creates all of the complex transactions which post the data on-chain & run the oracle pool protocol on-chain (such as averaging data points). This comes bundled with Oracle Pool Bootstrap and a Connector Library . The ada-usd-oracle source can be seen here. Currently, only the erg-USD-oracle is live as seen in the Oracle Pool List See this overview by Robert Kornacki. Resources eth/usd connector Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. Learn about data inputs and the truly novel innovations they bring to UTXO-based Blockchains Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. See also a forum topic with example v2 Oracle pool 2.0 contracts finalized (for initial draft). Tests for oracle pool 2.0 Articles Chainlink Oracles vs. Ergo Oracle Pools Oracle Pools - A New Oracle Model First steps towards interoperability with Cardano oracles Ergo Blockchain: Oracle Pool Governance Update The role of Ergo Oracles","title":"Oracles"},{"location":"uses/apps/#misc","text":"ErgoFaucet.org Various utilities are listed on ergosites.github.io ergo.watch | Git","title":"Misc"},{"location":"uses/apps/#ergohack","text":"ERGOHACK I ErgoRaffle Ergo Index Fund Smart Pools Sigma Stamp Ergo Charts Simpler Joint Spending Tool ERGOHACK II ErgoLend Minotaur Wallet Ergopad Ergo Subpooling HYPO10USE: QUIDGAMES Ergo Audio Many more possible! Bonds based on Ergo (or the \u201cYield protocol\u201d) An ICO Example On Top Of Ergo A Local Exchange Trading System On Top Of Ergo A Trustless Local Exchange Trading System (E)mail Client for Limited or Blocked Internet LETS start the discussion ErgoFans | Decentralised content producer platform | Patreon/Onlyfans ErgoGigs | Decentralised gigs! (Fiverr) ErgoEarn | earn for learning (Coinbase Earn) ErgoStats | on-chain analysis (glassnode)","title":"ERGOHACK"},{"location":"uses/blocked_web/","text":"(E)mail Client for Limited or Blocked Internet There are two motivations for this post Some countries, such as China and Belarus are already blocking Tor. We can expect that in future some countries will try to block cryptocurrency protocols in a similar way. Internet just being restored in Iran after week-long shutdown caused by unrest. Previously there were partial or complete shutdowns in Egypt, Ethiopia, Sudan, Turkey. However, people have right to store value available, whether the value is under threat from monetary policies, political instability, or war. Happily, with digital communications and digital gold this problem could be solved. As possible solution for Bitcoin, Blockstream satellite network could be used, however, satellite signal could be jammed. Another workaround which I am going to propose is to use e-mail (which is last to be blocked usually) or other low-bandwidth and not very interactive means of communication (fax, modem call over a landline to a bulletin board system, mail). So assume Alice is willing to buy X ergs from Bob (paying with cash), but internet is very limited or does not working in their area. Bob owns a box protected by a public key (stored locally). Then the protocol could be as follows. Bob is creating transaction from his box which is creating a new box where X ergs are locked by the condition \"Before deadline: Bob's signature and spending transaction has an output of X ergs which belongs to Alice's public key; After deadline: Bob's signature\". I will refer to the new box as to the \"deal box\" further. Please note that for a signed transaction outputs with respective identifiers are known. Bob sends the transaction over (e)mail to a gateway. Gateway sends efficient NiPoPoW proof for a header having enough confirmations + proof of box membership against state digest from the header. This proof is small, tens of kilobytes. for better security, Bob may ask another gateway for header proof as well. Bob shows proofs to Alice. Alice checks proofs and also that deadline will not likely met when a new transaction with their deal will reach the Ergo blockchain. Bob signs the new transaction which is spending the deal box created on step 1 and creating the output box for Alice. Now Alice sends the transaction signed by Bob to the gateway and gets the proof of inclusion from it. With proofs of such size (tens of kilobytes), email / fax / ADSL modem or even paper work fine as means of communication between the users and the gateways.","title":"Email Client for Blocked Internet"},{"location":"uses/blocked_web/#email-client-for-limited-or-blocked-internet","text":"There are two motivations for this post Some countries, such as China and Belarus are already blocking Tor. We can expect that in future some countries will try to block cryptocurrency protocols in a similar way. Internet just being restored in Iran after week-long shutdown caused by unrest. Previously there were partial or complete shutdowns in Egypt, Ethiopia, Sudan, Turkey. However, people have right to store value available, whether the value is under threat from monetary policies, political instability, or war. Happily, with digital communications and digital gold this problem could be solved. As possible solution for Bitcoin, Blockstream satellite network could be used, however, satellite signal could be jammed. Another workaround which I am going to propose is to use e-mail (which is last to be blocked usually) or other low-bandwidth and not very interactive means of communication (fax, modem call over a landline to a bulletin board system, mail). So assume Alice is willing to buy X ergs from Bob (paying with cash), but internet is very limited or does not working in their area. Bob owns a box protected by a public key (stored locally). Then the protocol could be as follows. Bob is creating transaction from his box which is creating a new box where X ergs are locked by the condition \"Before deadline: Bob's signature and spending transaction has an output of X ergs which belongs to Alice's public key; After deadline: Bob's signature\". I will refer to the new box as to the \"deal box\" further. Please note that for a signed transaction outputs with respective identifiers are known. Bob sends the transaction over (e)mail to a gateway. Gateway sends efficient NiPoPoW proof for a header having enough confirmations + proof of box membership against state digest from the header. This proof is small, tens of kilobytes. for better security, Bob may ask another gateway for header proof as well. Bob shows proofs to Alice. Alice checks proofs and also that deadline will not likely met when a new transaction with their deal will reach the Ergo blockchain. Bob signs the new transaction which is spending the deal box created on step 1 and creating the output box for Alice. Now Alice sends the transaction signed by Bob to the gateway and gets the proof of inclusion from it. With proofs of such size (tens of kilobytes), email / fax / ADSL modem or even paper work fine as means of communication between the users and the gateways.","title":"(E)mail Client for Limited or Blocked Internet"},{"location":"uses/collateral-mining/","text":"As some of you know, I've been working on my own collateral-based mining pool. This will just be another option along with @mhs_sam's pool. I thought I would post my collateral box script here for public review, in case I've missed any obvious issues: { val poolReward = 67500000000L { // Case 1: block was mined by alice. // Either: (a) we have 1 output of value poolReward, // or: (b) we have 2 outputs, 1st is poolReward, 2nd goes to self. decodePoint(CONTEXT.minerPubKey) == alice && HEIGHT > SELF.creationInfo._1 && OUTPUTS(0).value == poolReward && { OUTPUTS.size == 1 || { OUTPUTS.size == 2 && OUTPUTS(1).propositionBytes == SELF.propositionBytes && OUTPUTS(1).creationInfo._1 == HEIGHT } } } || { // Case 2: anyone can top-up with more collateral funds. OUTPUTS(0).propositionBytes == SELF.propositionBytes && OUTPUTS(0).creationInfo._1 >= SELF.creationInfo._1 && OUTPUTS(0).value > SELF.value } || { // Case 3: alice can withdraw collateral at any time. proveDlog(alice) } } Edit: fixed a bug that would have allowed chained spends in a single block. The main limitation of this approach is that only one unspent collateral box should exist at any time for a given miner public key, otherwise a pool can spend more than one box in the same block and claim a multiple of the reward. However, I think this is reasonable and it becomes too complex if miners have to create special signatures to avoid this. The top-up mechanism (case 2) allows anyone to top-up a given collateral box. Another small point is that the pool reward could be adjusted to be a bit under 67.5 ERG to provide additional incentives, though I would note that the miner already gets to keep all the fees if they mine a block. This collateral mechanism was proposed here by @scalahub back in July 2019! https://www.ergoforum.org/t/creating-an-ergo-mining-pool/42 The paper by @kushti and @scalahub is here . Full discussion here","title":"Collateral Mining"},{"location":"uses/context-claims/","text":"Recently I have been working through designing various DeFi protocols in the Ergo contract model, and the thought came to mind that to make things more efficient it would be of great benefit if we could make claims about the global state of the blockchain/UTXO-set. This lead me to come up with the concept of global context data accumulation (which I will explain in a moment) however I didn't realize that the concept is even further extendable to any claim about the blockchain state until a conversation with @jasondavies and @scalahub where they pointed out negative proofs are possible. So, what are these \"Efficient Global Context Claims\" then? In essence, smart contract enabled blockchains to date have various levels of context available to developers in the smart contracts themselves. Some may allow little to no outside data from other accounts/utxos/contracts, while others like Ethereum only allow smart contracts to specifically call one anothers' functions to return a value and obtain that tiny slice of context that way. What all of these systems/models lack is the ability to make claims about the state of every single account/UTXO/smart contract on the entire system. There are clear reasons for this, it is horribly inefficient. With blockchains like Ethereum where it's almost impossible for a user to bootstrap a full node, expecting a validator to go through the entire state of the blockchain to validate a logical check in a single contract is impossible to even consider implementing when they're already constantly hitting limits. Ergo on the other hand is the only blockchain out there which has smart contracts on a UTXO-based system and has the concept of data-inputs. For those who are not familiar, data-inputs allow you to reference a UTXO/box in a transaction without spending it. Thus you have access to all of the data/value of tokens within a UTXO without needing to have the right to spend it. Following that line of reasoning, this means we can check data from any dApp/contract on the blockchain without needing permission or having to encode anything at all in the contract to support doing so. This has major implications which we will now get into. Because data-inputs allow anyone to reference the registers and tokens of any box, this means that we can make generic claims about the whole system and have any user on the system prove/disprove said claims. For example we can arbitrarily create a smart contract that specifies This UTXO can only be spent if another UTXO exists with the number 5 in Register R4 and it holds 5 Erg . If such a box exists with 5 Erg and the number 5 in register R4, then anyone can create a transaction using said box as a data-input, thereby proving that such a box exists and giving them the right to spend the UTXO. Now, what if we were to include a reward (say 100 Ergs) together with our smart contract which is making a claim about the global context? This would provide a monetary incentive for actors (who are not the validators) to scan the entire UTXO-set to find a box that proves the claim at hand, thereby earning the actor money. Thus we could create a box which holds 100 Ergs and specifies the following claim in it's smart contract: This UTXO can only be spent if a box exists which holds at least 1000 Ergs at the smart contract address \"2iHkR7CWvD1R4j1yZg5bke...\" . If such a box exists, then anyone can cite the box as a data-input and earn the 100 Ergs. This is a trivial task, and would earn someone about $20.00 USD (in today's Erg/USD conversion rate). Thus, if our smart contract box does not get spent over the course of the proceeding blocks, we come to the conclusion that such a box does not exist on the network. Thus we have outsourced the scanning and verifying of the global state of the blockchain to users who have a monetary incentive, while making it seamless and trustless due to using data-inputs. Now, if we implement software to streamline this task automatically and make it trivial for Ergo users to run at a profit, we can gain a high level of assurance about the claims we make on-chain (the greater the reward the greater the incentive for \"verifiers\" to make sure that the claim does/does not hold thereby increasing the assurance). One can view this as an efficient and trustless (due to data-inputs providing proof of validity) variation of oracles where each oracle only processes data from the blockchain and folds it down into a boolean result. This should be possible to run on commodity hardware by anyone anywhere in the world with an internet connection and computer, allowing for a truly decentralized system of \"verifiers\" who make it possible to make efficient global context claims about the entire blockchain. This also acts as a superb way for users to come into the ecosystem and earn Erg while providing a truly pivotal service with a low barrier of entry. Once the utxo-set grows very large and the claims become more complex, we could even imagine \"verification pools\" coming about, where users are given a segment of the UTXO-set to keep track of/process and receive a small portion of any rewards that their \"verification pool\" wins. This opens up a lot of doors of opportunity. With what I've outlined above, we have the ability to make any claim at all, about any token or piece of data in any register that is part of any dApp on the entire blockchain. Very powerful. However, we can do even more which I alluded to in the beginning. Global Context Data Accumulators Since data-inputs provide us with full context of a given UTXO, it means that we can also apply arbitrary functions to said data instead of just boolean checks. Thus, we can have our simple \"verifiers\" actually become \"accumulators\" who scan the entire blockchain to find all relevant boxes, and then fold the data down into a single/set of values which get posted into a new single box. For example, let's say we want to know the total number of Erg which are held in a smart contract at the address of 2iHkR7CWvD1R4j1yZg5bke . We can post a box with a 100 Erg reward on-chain with a contract that specifies anyone can spend the box if: 1. The user provides at least 1 data-input of a box owned by 2iHkR7CWvD1R4j1yZg5bke . 2. The user creates a single new box with: - The number of data-inputs he provided in register R4 - The accumulated data in R5 (total number of Ergs held in all data-inputs) - His public key in register R6 - This box locked under the \"Finalizing Accumulation\" script This new box under the \"Finalizing Accumulation\" script finalizes/ends the accumulation if no one spends it in the next 5 blocks. However it allows anyone to spend the box if they: 1. Provide at least 1 more data-input than the value in register R4. 2. Create a single new box with: - The number of data-inputs he provided in register R4 - The accumulated data in R5 (total number of Ergs held in all data-inputs) - His public key in register R6 - This box locked under the \"Finalizing Accumulation\" script again Thus, the user has proven that he/she has found more data-inputs than the previous user which match the stated restrictions. Once the accumulation has finalized because no one has spent it after 5 blocks, the user who has their address in R6 can withdraw his reward and move the value in R5 (the accumulated datapoint) into a new box of it's own in a register allowing anyone on the entire network to easily reference it as a data-input. Admittedly this is a slightly naive way to implement an accumulator scheme (as it could take arbitrarily long for the datapoint to finalize, and probably could use an NFT to make it easy to find the finalized datapoint for example), but it was chosen to be as clear as possible for how accumulators could be implemented/work. We can likely build out \"data accumulation pools\" where there are hard-capped time limits for protocols that require consistent data accumulation. Context data accumulators allow us to sum up the state of the blockchain into one or more registers of a new box. This can be very useful in many use cases such as in DeFi where you may need to know the total funds held in a liquidity pool contract in order to calculate interest rates accurately. Using context data accumulators to checkpoint/accumulate the state of the blockchain allows users to parallelize actions within dApps inside of their own UTXOs completely separate from others, while still contributing to a global shared core state of the dApp that is put together by the accumulators. It may even be possible to one day merge such schemes with sharding and/or side-chains to allow for scaling of smart contracts thanks to the nature of the UTXO model and this snapshot/accumulation approach to contract design. Conclusion With all of that said, thanks to Ergo's UTXO model with data-inputs, we have the ability to trustlessly fold the whole UTXO-set state down into a single value and post the result on-chain. By leveraging monetary incentives, we can thus use this to create efficient claims on global blockchain context and/or accumulate data into a single box that is readable by anyone and everyone. There is likely a lot more to be said/thought about with all of this, but I believe this should be good enough of a starting point to get the idea out there in an understandable form. Update Here are some further of my thoughts from Discord on improving security for claims using pools (Which is also possible for data accumulation which further allows for accumulating/check pointing in predefined time intervals.): For claims, we can probably separate time into epochs/intervals as well, and anyone who joins a \"Claim Pool\" for a specific claim has to put up some collateral on entry which shows that they are actively checking said claim. Whoever first posts the counter-proof to the claim gets the reward (or maybe we can use a 1st (65%) 2nd (25%) 3rd (10%) payout scheme). However all other participants must also post the counter-claim as well within a given time duration to prove their active participation. If one participant fails to do so then it shows that they have failed to perform their task, and therefore their collateral is given to all of the other active participants in equal portions. We could even incorporate residual-payout schemes with such Claim pools, where there is a large reward for proving the counterclaim, however verifiers still receive a reward in every epoch if no counter-proof is produced by any participant. This way you incentivize active checking for a long duration of time while still providing enough funds for verifiers to continue. (Though we'd need the per-epoch fee to be several orders of magnitude smaller than the reward so that game theoretically it is always in everyone's best interest to claim the reward rather than all participants colluding and just getting passive rewards for doing nothing). To make this even more robust, we could theoretically also add the ability for outsiders to provide counter-proofs to the claim after an epoch has finished in the proceeding epoch. Thus if the pool participants colluded to not provide the counter-proof data-input and someone else can prove that the claim has been disproved via a data-input, then said outsider can redeem the reward and all of the collateral of all pool participants. As such pool participants receive a small residual-income for actively checking, and if they fail to do their job then outsiders have an incentive to double-check in order to receive the reward and \"liquidate\" all of the pool participants' collateral. Going further, we could also encode arbitrary entry conditions for joining a Claim Pool. It could just be submitting collateral and redeeming a \"pool entry token\" allowing for seamless entry/exit, could be semi-permissioned, and/or there could be hard-caps to the total number of verifiers (could be useful if residual payout scheme is in place). There's a lot of flexibility with all of this, and I think it should be possible to create some sort of a go-to default scheme which provides solid security together with good incentives for active claim checking. After some more thinking I've realized that with global context claims we can also easily create trustless prediction markets for the state of any dApp/contract/data on-chain. Essentially you could just mint 2 different tokens and lock them in a contract that has a claim in it. People can buy a \"True\" token or a \"False\" token, and if the claim gets proven before an expiration block height then say \"True\" token holders get paid out, else if the block height arrives then the \"False\" holders get paid out. The claim can be proven by anyone via a data-input, and so we could just have a basic prize, or a full fledged claim pool to make it secure.","title":"Context claims"},{"location":"uses/context-claims/#global-context-data-accumulators","text":"Since data-inputs provide us with full context of a given UTXO, it means that we can also apply arbitrary functions to said data instead of just boolean checks. Thus, we can have our simple \"verifiers\" actually become \"accumulators\" who scan the entire blockchain to find all relevant boxes, and then fold the data down into a single/set of values which get posted into a new single box. For example, let's say we want to know the total number of Erg which are held in a smart contract at the address of 2iHkR7CWvD1R4j1yZg5bke . We can post a box with a 100 Erg reward on-chain with a contract that specifies anyone can spend the box if: 1. The user provides at least 1 data-input of a box owned by 2iHkR7CWvD1R4j1yZg5bke . 2. The user creates a single new box with: - The number of data-inputs he provided in register R4 - The accumulated data in R5 (total number of Ergs held in all data-inputs) - His public key in register R6 - This box locked under the \"Finalizing Accumulation\" script This new box under the \"Finalizing Accumulation\" script finalizes/ends the accumulation if no one spends it in the next 5 blocks. However it allows anyone to spend the box if they: 1. Provide at least 1 more data-input than the value in register R4. 2. Create a single new box with: - The number of data-inputs he provided in register R4 - The accumulated data in R5 (total number of Ergs held in all data-inputs) - His public key in register R6 - This box locked under the \"Finalizing Accumulation\" script again Thus, the user has proven that he/she has found more data-inputs than the previous user which match the stated restrictions. Once the accumulation has finalized because no one has spent it after 5 blocks, the user who has their address in R6 can withdraw his reward and move the value in R5 (the accumulated datapoint) into a new box of it's own in a register allowing anyone on the entire network to easily reference it as a data-input. Admittedly this is a slightly naive way to implement an accumulator scheme (as it could take arbitrarily long for the datapoint to finalize, and probably could use an NFT to make it easy to find the finalized datapoint for example), but it was chosen to be as clear as possible for how accumulators could be implemented/work. We can likely build out \"data accumulation pools\" where there are hard-capped time limits for protocols that require consistent data accumulation. Context data accumulators allow us to sum up the state of the blockchain into one or more registers of a new box. This can be very useful in many use cases such as in DeFi where you may need to know the total funds held in a liquidity pool contract in order to calculate interest rates accurately. Using context data accumulators to checkpoint/accumulate the state of the blockchain allows users to parallelize actions within dApps inside of their own UTXOs completely separate from others, while still contributing to a global shared core state of the dApp that is put together by the accumulators. It may even be possible to one day merge such schemes with sharding and/or side-chains to allow for scaling of smart contracts thanks to the nature of the UTXO model and this snapshot/accumulation approach to contract design.","title":"Global Context Data Accumulators"},{"location":"uses/context-claims/#conclusion","text":"With all of that said, thanks to Ergo's UTXO model with data-inputs, we have the ability to trustlessly fold the whole UTXO-set state down into a single value and post the result on-chain. By leveraging monetary incentives, we can thus use this to create efficient claims on global blockchain context and/or accumulate data into a single box that is readable by anyone and everyone. There is likely a lot more to be said/thought about with all of this, but I believe this should be good enough of a starting point to get the idea out there in an understandable form.","title":"Conclusion"},{"location":"uses/context-claims/#update","text":"Here are some further of my thoughts from Discord on improving security for claims using pools (Which is also possible for data accumulation which further allows for accumulating/check pointing in predefined time intervals.): For claims, we can probably separate time into epochs/intervals as well, and anyone who joins a \"Claim Pool\" for a specific claim has to put up some collateral on entry which shows that they are actively checking said claim. Whoever first posts the counter-proof to the claim gets the reward (or maybe we can use a 1st (65%) 2nd (25%) 3rd (10%) payout scheme). However all other participants must also post the counter-claim as well within a given time duration to prove their active participation. If one participant fails to do so then it shows that they have failed to perform their task, and therefore their collateral is given to all of the other active participants in equal portions. We could even incorporate residual-payout schemes with such Claim pools, where there is a large reward for proving the counterclaim, however verifiers still receive a reward in every epoch if no counter-proof is produced by any participant. This way you incentivize active checking for a long duration of time while still providing enough funds for verifiers to continue. (Though we'd need the per-epoch fee to be several orders of magnitude smaller than the reward so that game theoretically it is always in everyone's best interest to claim the reward rather than all participants colluding and just getting passive rewards for doing nothing). To make this even more robust, we could theoretically also add the ability for outsiders to provide counter-proofs to the claim after an epoch has finished in the proceeding epoch. Thus if the pool participants colluded to not provide the counter-proof data-input and someone else can prove that the claim has been disproved via a data-input, then said outsider can redeem the reward and all of the collateral of all pool participants. As such pool participants receive a small residual-income for actively checking, and if they fail to do their job then outsiders have an incentive to double-check in order to receive the reward and \"liquidate\" all of the pool participants' collateral. Going further, we could also encode arbitrary entry conditions for joining a Claim Pool. It could just be submitting collateral and redeeming a \"pool entry token\" allowing for seamless entry/exit, could be semi-permissioned, and/or there could be hard-caps to the total number of verifiers (could be useful if residual payout scheme is in place). There's a lot of flexibility with all of this, and I think it should be possible to create some sort of a go-to default scheme which provides solid security together with good incentives for active claim checking. After some more thinking I've realized that with global context claims we can also easily create trustless prediction markets for the state of any dApp/contract/data on-chain. Essentially you could just mint 2 different tokens and lock them in a contract that has a claim in it. People can buy a \"True\" token or a \"False\" token, and if the claim gets proven before an expiration block height then say \"True\" token holders get paid out, else if the block height arrives then the \"False\" holders get paid out. The claim can be proven by anyone via a data-input, and so we could just have a basic prize, or a full fledged claim pool to make it secure.","title":"Update"},{"location":"uses/dex-buyback/","text":"In this example we will consider a decentralized token-sale, where seller is providing buyback guarantees. This guarantee is done in following way: a seller is requiring a buyer to create a buy order at some price and of some token amount also. Rest is going to the seller. Every order can have unique buyback properties (to e.g. form a bonding curve). We start with buyback contract. It has expiration ( buyerPk && sigmaProp(HEIGHT > 100) condition), otherwise, the box has been spent if asked amount of tokens sent back to the original seller. { val defined = OUTPUTS(0).R2[Coll[(Coll[Byte], Long)]].isDefined && OUTPUTS(0).R4[Coll[Byte]].isDefined (buyerPk && sigmaProp(HEIGHT > 100)) || sigmaProp (if (defined) { allOf(Coll( OUTPUTS(0).tokens(0)._1 == tokenId, OUTPUTS(0).tokens(0)._2 >= tokenAmount, OUTPUTS(0).propositionBytes == sellerPk.propBytes, OUTPUTS(0).R4[Coll[Byte]].get == SELF.id) ) } else { false } ) } Sell contract is then as follows: { sigmaProp(allOf(Coll( blake2b256(OUTPUTS(0).propositionBytes) == bbh, OUTPUTS(0).value == buyBackAmount, OUTPUTS(1).value >= toWithdraw, OUTPUTS(1).propositionBytes == sellerPk.propBytes, OUTPUTS(1).R4[Coll[Byte]].get == SELF.id )) ) } where bbh is buyback script hash. Playground version you can experiment with is available: https://scastie.scala-lang.org/oVlOW1GpTkWGLPLzDmJTxA . Similarly to buy-back, we can enhance orders with different conditions, getting DEX functionality (and simple DEX orders) composable with complex logic (token-sale, liquidity providing etc). I'm calling this smart orders . The big question, however, how to do front-end apps and UIs for smart order based DEXes.","title":"Buy Back"},{"location":"uses/lottery/","text":"First some background The idea in this post is motivated from the post about Proof-of-Activity as a Smart Contract . The goal of \"proof of activity\" is to reward members for their \"activity\" (i.e., for running a full node). Without going into details, the approach essentially is based on \"proof-of-stake\" such that people who are active receive larger rewards than inactive people holding similar stake. The purpose is to discourage people having stake but not actively participating in the network. The key method behind all proof of stake and proof of activity is follow-the-satoshi , which picks a random satoshi from all the generated ones and then the holder of that satoshi is eligible for the reward. If the satoshi is selected unformly then this is similar to a lottery system. The Lottery The goal of this post is not to have a proof of stake or proof of activity. Rather it is about emulating the follow-the-satoshi protocol to have a provably fair lottery system. The lottery that we will create emulates the following physical lottery: 1. Company generates lottery tickets in sequential serial numbers 2. There is only one place to buy the tickets 3. Tickets can only be purchased in sequential serial numbers using the \"next available serial number\" rule, (starting from serial number 0). 4. After the lottery is closed (so that no more tickets can be sold), the first unsold serial number n is noted. 5. A random number r is generated between 0 and n -1 (both inclusive). 6. The holder of ticket with serial number r is the winner. We can emulate this with Ergo as follows. The lottery owner creates a \"lottery box\" containing tokens and the current available serial number in R4 . This is protected by a script that sells tokens and the balance tokens are kept in an identical box with the serial number appropriately incremented. Furthermore the purchased tokens are to be kept in a \"purchase box\" box containing in R4 and R5 respectively, the start and end serial numbers of purchased tokens. We additionally require the script in the purchase box to \"lock\" these values, so they cannot be altered by the buyer. After the lottery ends, the last serial number n is stored in R4 of the lottery box. Using this, winner is decided using, say taking randomness from the previous block header to generate a number uniformly between 0 and n to decide the winner. The winner can use his purchase box to take the rewards. The rewards can be stored in the lottery box itself and each ticket purchased contributes to the reward. While this works in a fair way, it is not deterministic as it depends on the last block header. Since each \"previous block\" decides a different winner for the same n , this also can be used as a proof of activity because the current winner must be onlline. See this thread for full discussion","title":"Lottery"},{"location":"uses/math_fun/","text":"Mathematical Fun with ErgoScript Just for fun, I decided to see how hard it would be to create a \"bounty\" protected by some mathematical problem. I was inspired by today's announcement that 42 can be written as the sum of three cubes: 42 = (\u221280538738812075974)^3 + 80435758145817515^3 + 12602123297335631^3 I created the following trivial contract: { val a = getVar[BigInt](1).get val b = getVar[BigInt](2).get val c = getVar[BigInt](3).get a * a * a + b * b * b + c * c * c == 42 } I converted this to a P2S address using a simple P2S web tool that I'm working on, which gave me this P2S address: YUgUAFeNudkkLfjWcnXfg6HphUDaWdaR88yTQHeP6oozcvvwbM74SRZPW1R3WrqYmyp5vM4PhC2SuTfMA I sent 42 ERG to this address ready for testing. Now, in order to claim the \"bounty\", I created an unsigned transaction with the three values above included in the extension field under spendingProof . No signature was necessary, of course, just the correct values that solve the puzzle. I successfully claimed the bounty and sent it on to the crowdfunding CLI project ! Notes: It would be good to have better documentation for ErgoScript; in particular, I was confused about BigInt and whether it represented 256-bit integers as noted here , or arbitrary-precision integers due to the use of java.math.BigInteger internally -- it has now been confirmed to represent 256-bit integers. It would have been nice to test the script properly somehow in a standalone manner e.g. write test cases for it. I know that this is possible in Scala but maybe a tutorial on this would be good (or even better for non-Scala developers - some way to more easily work with ErgoScript outside of Scala?) The explorer doesn't currently show extension data, so I was a bit disappointed you couldn't really see the solution to the puzzle in the explorer very well. Any feedback is welcome!","title":"Math Fun"},{"location":"uses/math_fun/#mathematical-fun-with-ergoscript","text":"Just for fun, I decided to see how hard it would be to create a \"bounty\" protected by some mathematical problem. I was inspired by today's announcement that 42 can be written as the sum of three cubes: 42 = (\u221280538738812075974)^3 + 80435758145817515^3 + 12602123297335631^3 I created the following trivial contract: { val a = getVar[BigInt](1).get val b = getVar[BigInt](2).get val c = getVar[BigInt](3).get a * a * a + b * b * b + c * c * c == 42 } I converted this to a P2S address using a simple P2S web tool that I'm working on, which gave me this P2S address: YUgUAFeNudkkLfjWcnXfg6HphUDaWdaR88yTQHeP6oozcvvwbM74SRZPW1R3WrqYmyp5vM4PhC2SuTfMA I sent 42 ERG to this address ready for testing. Now, in order to claim the \"bounty\", I created an unsigned transaction with the three values above included in the extension field under spendingProof . No signature was necessary, of course, just the correct values that solve the puzzle. I successfully claimed the bounty and sent it on to the crowdfunding CLI project ! Notes: It would be good to have better documentation for ErgoScript; in particular, I was confused about BigInt and whether it represented 256-bit integers as noted here , or arbitrary-precision integers due to the use of java.math.BigInteger internally -- it has now been confirmed to represent 256-bit integers. It would have been nice to test the script properly somehow in a standalone manner e.g. write test cases for it. I know that this is possible in Scala but maybe a tutorial on this would be good (or even better for non-Scala developers - some way to more easily work with ErgoScript outside of Scala?) The explorer doesn't currently show extension data, so I was a bit disappointed you couldn't really see the solution to the puzzle in the explorer very well. Any feedback is welcome!","title":"Mathematical Fun with ErgoScript"},{"location":"uses/perpetual/","text":"In other words, a token which is guaranteed to exist forever, unless it gets garbage-collected! { val isPerpetual = {(b: Box) => b.propositionBytes == SELF.propositionBytes && b.tokens == SELF.tokens } sigmaProp(OUTPUTS.exists(isPerpetual)) } (Actually, this is a perpetual collection of tokens (possibly of size zero). But if you protect a singleton token with this script, then it guarantees the token will never be destroyed other than by garbage collection.) See this thread for full discussion. Multi-stage In multi-stage protocols, one script refers to the script of the next stage (example in script1 , we have the statement hash(OUTPUTS(0).propositionBytes) == script2Hash ). But suppose we also want the script2 to refer back to script1 , (example we want hash(OUTPUTS(0).propositionBytes) == script1Hash ), then its a cyclic reference. One solution is to store script1Hash in register of the box containing script2 . Additionally script1 is modified to ensure that the corresponding register of any box containing script2 equals hash(SELF.propositionBytes) . EDIT: While the \"vanilla\" perpetual token is interesting, the more powerful one is the \"max-once-per-block-use\" perpetual token, which should be a separate design pattern.","title":"Perpetual Tokens"},{"location":"uses/perpetual/#multi-stage","text":"In multi-stage protocols, one script refers to the script of the next stage (example in script1 , we have the statement hash(OUTPUTS(0).propositionBytes) == script2Hash ). But suppose we also want the script2 to refer back to script1 , (example we want hash(OUTPUTS(0).propositionBytes) == script1Hash ), then its a cyclic reference. One solution is to store script1Hash in register of the box containing script2 . Additionally script1 is modified to ensure that the corresponding register of any box containing script2 equals hash(SELF.propositionBytes) . EDIT: While the \"vanilla\" perpetual token is interesting, the more powerful one is the \"max-once-per-block-use\" perpetual token, which should be a separate design pattern.","title":"Multi-stage"},{"location":"uses/use/","text":"Everyone is talking about DeFi. Few people are asking what DeFi should look like. Ergo has a vision for what the sector can become. 2020 is shaping up to be the year in which Decentralised Finance rose to mainstream attention, in the same way that Bitcoin and blockchain did in 2016 and 2017. In July alone, Total Value Locked \u2013 the amount of funds committed to DeFi dApps\u2019 smart contracts \u2013 doubled from $2 billion to $4 billion, largely driven by Compound\u2019s distribution of its COMP governance tokens. DeFi is all the rage, with several well-known projects pioneering the space before our eyes. But while the crypto world is gripped with the short-term opportunities of DeFi, fewer are talking about what it actually is \u2013 and fewer still about what it should be. In building a DeFi platform like Ergo, though, that\u2019s exactly the kind of question we have to ask. DeFi dislikes limits In talking about what DeFi \u2018should\u2019 be, it\u2019s easy to fall into a trap of being prescriptive, of introducing arbitrary conditions and limits. But that\u2019s not what blockchain is about. As we\u2019ve seen with Bitcoin and blockchain more generally, there\u2019s a free market of ideas and nothing is off the table. It\u2019s reasonable (though not particularly helpful) to say that DeFi should be \u2018anything and everything\u2019. Just like blockchain, DeFi brings advantages of transparency, immutability and efficiency (often including speed and/or cost) to financial processes. But in terms of what we believe this new set of technologies should offer, and what decentralised finance can bring to the conventional financial system, it\u2019s worth focusing the conversation on a few other key areas that have been overlooked or under-represented to date: Privacy, Scalability, Interoperability , and Decentralisation . Privacy As Eric Hughes wrote in A Cypherpunk\u2019s Manifesto back in 1993, \u2018Privacy is necessary for an open society in the electronic age.\u2019 That is never more true than for financial privacy. Privacy must be a built-in feature of DeFi \u2013 not a bolt on extra or a desirable feature. It must be integral. But, as Hughes continues, \u2018Privacy is the power to selectively reveal oneself to the world.\u2019 There is always a balance to be struck between privacy and compliance, between transparency and anonymity. Large scale adoption of DeFi requires auditability, and the regulatory approval that enables. Thanks to the latest advances in zero-knowledge proofs, Ergo can offer both privacy and transparency, where required. The platform\u2019s Sigma Protocols offer robust, customisable cryptography \u2013 and, at the same time, the ability to selectively reveal information where necessary. Scalability The ability to process thousands of transactions per second is also a non-negotiable feature for a thriving DeFi sector. How this is achieved is less important than that it is achieved; in practice, there will be many different approaches, with different users and protocols selecting the ones they prefer. For example, while we have seen the rise of sidechains and child chains, the reality is that exchanges remain a gateway to the blockchain world for a large proportion of users. Popular exchanges are increasingly integrating DeFi functionality, allowing their vast user bases to access it from their individual accounts, without interacting directly with the protocol. While this may be less than ideal from a security perspective, it\u2019s a simple reality that centralised services are not going out of fashion, but are integrating decentralised technologies thanks to the advantages they offer. Ergo has its own approach to scalability , but we can\u2019t and won\u2019t ignore the importance of businesses in driving forward user adoption. Interoperability One of DeFi\u2019s key strengths is composability: the ability to build new applications from existing components, leveraging the network effect of established dApps and tokens. This is one of the main factors that has enabled TVL to explode over the past month. But composability currently has its limits. Cross-platform composability currently isn\u2019t possible. Even atomic swaps \u2013 the first stage of interoperability \u2013 are in their infancy, though Ergo is working on an atomic swap-powered DEX . Full interoperability means the ability for a user to execute a smart contract on one platform and have it seamlessly interact with another blockchain. This would allow truly frictionless cross-protocol interaction, and is what is needed to enable the flow of liquidity fully throughout the DeFi world. At that point, applications become blockchain agnostic, and the platforms are really more like the programming languages for accessing dApps\u2019 functionality. Decentralisation Lastly, and specifically in the context of scalability and interoperability, we cannot forget the importance of decentralisation \u2013 something Ergo has always taken seriously . Of course DeFi is decentralised \u2013 but there are different types of decentralisation. Ethereum, the home of almost every major DeFi dApp, is just one platform. Ethereum\u2019s developers are working on a plan for scaling, but even if this is successful, it is still one blockchain. Should we entrust all our funds to one network? What if a critical bug or exploit is found? Interoperability does more than enable cross-chain liquidity. It decentralises the decentralised infrastructure for DeFi, adding layers of redundancy and security. In the process, it strengthens every blockchain that is a part of that ecosystem, creating a whole that is more than the sum of its parts. At a time when relatively large blockchains still suffer double spend attacks and serious reorgs , and catastrophic vulnerabilities are found in smart contracts holding tens of millions of dollars of value, we cannot assume that one single blockchain will or should rule them all. CDBCs As blockchain technology gains traction, central bank digital currencies are among the most significant applications being developed. But these will inevitably fall far short of the ideal, for one simple reason: control. In particular, that has implications for composability and privacy, and much else besides. Central bank digital currencies are no longer a theoretical application of blockchain technology. The list of countries developing CBDCs is growing rapidly, with several now trialing state-backed digital cash. CDBCs are not built on classic, open blockchain technology. While there are various approaches, they are all based on permissioned ledgers that restrict the role of securing the network and processing transactions to a group of approved entities. They also include a control layer that gives administrators the ability to intervene in transactions, blocking or reversing those they deem invalid. It\u2019s a far cry from the ideals of Bitcoin, and the Ergo platform that aims to build on these. But it\u2019s only to be expected. The state has a role and a remit, and it\u2019s unlikely to give up the control it exercises. Unfortunately, though, there are two ways that holding onto control will mean that CBDCs fall far short of what they could be, meaning they may ultimately cede ground to open platforms like Ergo. Composability As we wrote in a recent blog, composability is a core feature of DeFi. It\u2019s what gives applications network effect, instantly adding value by plugging into existing dapps\u2019 user bases and functionality. Programmable money is a huge development. The current system is clunky and complicated to use, at best. It\u2019s not possible to attach detailed conditions to transactions, and have them interact seamlessly with software, as can be done with blockchain and smart contracts. Imagine the value that could be unlocked if CBDCs were programmable, and smart cash could be integrated frictionlessly into new applications \u2013 banking interfaces, investment services, stores, social networks, games. The list is endless. But this is hardly likely. The freedom to program money will exist, for many years at least, in the open blockchain space alone. Privacy Secondly, we consider privacy to be a core requirement of DeFi. Money is too important to be used as a tool of surveillance, but there is no question that this is what it will become as soon as the first CBDCs are rolled out to a large user base. China is one of the furthest ahead in its creation of state-backed digital cash. This is a state that is notorious for its internet censorship and online surveillance of its population. Its human rights record is dire, and in recent days we have learned more about its oppression of the Uighur minority. Moreover, China already uses a social credit system, which grants or denies citizens access to certain services and amenities depending on their social score, with model citizens enjoying greater privileges. There is, again, no question that a state-backed, traceable CBDC will be used as a tool of surveillance on a scale that is unprecedented in human history. And it will be the same across any nation that implements money within the same framework. That giant eye on the dollar bill? You ain\u2019t seen nothing yet. Private, programmable financial services Ergo has a very different vision for blockchain-based cash and financial services. In the new paradigm of blockchain, value is not retained by constraining it. It is only maximised through open systems that make it as accessible as people want it to be. Money without borders, in both senses: cash that can be programmed, sent and received freely but privately, between any two individuals or organisations \u2013 and even blockchains \u2013 anywhere in the world. This is what money needs to be, and what Ergo is building. This is the first in a series of articles speculating on how the fast-emerging DeFi sector might evolve in the coming years. The DeFi movement as it currently exists is only a few months old, and blockchain itself has barely existed a decade. Already, though, we are beginning to see themes crystallising and the first popular use cases becoming established. As a DeFi platform that takes positioning for the future seriously, it\u2019s important that Ergo has a vision \u2013 not only a sense of where things might be heading, but the role that it should itself be playing as these new decentralised financial services consolidate and grow in popularity. While no one can know the future, least of all in this space, a number of trends, technologies, products and use cases are emerging, and it seems that these are starting to plot a certain trajectory. Allowing for necessary course correction as time goes on, where might we see DeFi end up in ten years? Tokens will be the fuel for DeFi, and everything will be tokenised One of the major themes that was becoming apparent, long before the yield farming craze brought DeFi to global attention, is tokenisation. We already have blockchain tokens representing cryptocurrencies and digital assets, and the first shares and other securities have been issued on the blockchain. The benefits are such that the direction of travel is clear. Sooner or later, everything will end up as tokens. For regular, fungible (interchangeable) assets, a regular token will work. Fiat and cryptocurrencies, shares, bonds, precious metals, ETFs, CBDCs \u2013 these will all be freely available on the blockchain. For other assets, NFTs will proliferate. When you buy a car, house, painting or other unique item of value, whether digital or physical, there\u2019s a good chance that transaction will also include a blockchain token. These tokenised assets will place on the blockchain trillions of dollars of value that are currently \u2018stuck\u2019 offline, illiquid or impossible to buy or sell outside of certain limited circles and circumstances. This pool of tokenised value will represent the fuel of the Defi economy: assets that can be traded frictionlessly, borrowed against and leveraged using decentralised protocols that probably won\u2019t look so very different to the ones we use today. Digital identity will become non-negotiable Since these assets will be tradeable on centralised and decentralised exchanges, digital identity will also become an increasingly important theme. This will link blockchain addresses with offline identities, enabling individuals and corporations to operate in a way that is compliant with relevant regulation. It will also allow the automation of tax and accounting processes. To date, digital identity has been an overlooked element of the DeFi ecosystem \u2013 likely due to the use of centralised platforms that can conduct KYC as a condition of use. We\u2019re fast approaching a point where that is no longer a given, with the growth of new forms of decentralised exchange and the increase in volumes moving to these platforms. Stablecoins will become embedded elements of the blockchain One of the biggest use cases for DeFi \u2013 and again one that is often overlooked \u2013 is stablecoins. These exist in many forms, and rely on a range of approaches: centralised and decentralised, collateralised and algorithmic, fiat-backed, and so on. Whatever your preferred approach or view of stablecoins, they are here to stay. They have found use cases as a store of value, especially for traders, and as a popular form of collateral for yield farming. What they haven\u2019t been widely adopted for, yet, is as an integral part of blockchain infrastructure. Transaction fees are almost always paid for with the native blockchain token. Not only does this fluctuate in value, but so does the amount of it required per transaction, depending on both the complexity of the transaction itself and competition for space in the next block. Clearly, this complexity is not conducive to mainstream adoption. End users are best served by simplicity, with minimal burdens for managing multiple tokens. They will want to pay transaction fees in a stable unit of account, and not have to worry about handling the native blockchain token. The solution? An integrated stablecoin that, to most end users, is the most important token on the platform. Two-tier system As a result of this need, it seems likely that we may start to see a two-tier system evolve more clearly. A blockchain such as Ergo will have a native token, which will serve as the underlying currency of payment, just as occurs now. For the most part, though, these will only be handled by more experienced users. These expert users will maintain the technical and financial infrastructure of the DeFi space. For example, they will mine and use the native token as collateral to create a stablecoin, which can be sold into the market for general use, in return for tokenised assets of all kinds. Regular users will then use the \u2018native stablecoin\u2019 in all their business, as a kind of standard reserve currency. It will be used to buy other assets; it will be lent to users against other tokenised assets as collateral (houses, cars, real estate and much more); and it will be used to pay transaction fees. The miners who receive this native stablecoin can hold it as it is, to pay for electricity and hardware costs, or they can convert it back to the platform token or other assets \u2013 that is up to them. These are just some of the themes we are starting to see emerging in the DeFi world, and how they might develop over time. In the coming weeks, we\u2019ll explore various other ideas as the space continues to evolve and Ergo launches new technology. Ergo enables new models of financial interaction, underpinned by smart contracts built on flexible and powerful Sigma protocols but easily accessible to developers. One of the most exciting things about blockchain is the possibility of making digital agreements without any trusted intermediaries. In the simplest use case, pioneered by Bitcoin, Alice can send a payment directly to Bob, wherever the two of them are located around the world, with no bank or any trusted third party needed. However, with the functionality of a modern blockchain like Ergo, it is possible to make far more complex and sophisticated financial agreements than simple payments. Take the following example. Gold-backed tokens Alice uses ERGs to purchase gold-backed tokens from Bob. Bob stores the gold in a secure vault, and uses the blockchain to issue one token for every Troy ounce of gold he has. Alice can then use these tokens freely in different contracts, transferring and trading them under whatever conditions she specifies in the smart contract code. When Alice wants to sell the tokens for physical gold, she can conduct another transaction with Bob, receiving ERG in return, at market price. The point of blockchain contracts is to eliminate the need for trust. While the purchase transaction is now trustless, in this instance Alice still needs to trust Bob about two things. Firstly, Bob may refuse to swap the gold tokens back to ERG at the correct price when Alice wants to sell. Secondly, Bob may default on his obligations \u2013 running away with the gold, or misusing the funds he receives and running a fractional reserve. Extending the contracts To address these issues, we can create an Oracle, or decentralised price feed. This uses multiple sources of external data to record the price of gold to the blockchain at regular intervals. This price feed will be the reference point for the redemption contract that manages the sale of Alice\u2019s gold with Bob (or any other participant). Thus the system automatically enforces the right price when a swap takes place. The second situation requires a third-party insurer, Charlie, whose service is also hosted on the blockchain with a smart contract. When Alice purchases gold from Bob, she additionally buys an insurance contract from Charlie. The payment can be dependent on factors including the amount of insurance required, and Bob\u2019s reputation \u2013 again, managed by a decentralized feedback mechanism. Now, if Bob defaults, Alice will automatically receive the value of her gold tokens, with Charlie effectively acting as a buyer of last resort. Programmable contracts There are, of course, many other example use cases like this one. We can also extend this use case, adding further economic actors. For example, Charlie may sell shares in his insurance business to Dave and other participants, providing them with a proportion of revenues in return for ensuring he has the capital he needs to cover any liabilities from the outset. However, even the most complex use case is simpler than general-purpose software that can be used to program any contract. After all, generalised logic must be both far-reaching and secure. Moreover, even a specialised contract is made up of many steps, each of which is fairly simple. Thus another requirement for a general-purpose platform is that it should simplify the process of writing contracts, making them as accessible (and safe) as possible. This can be achieved with the use of template agreements, with customisable parameters. The insurance contract above could be based on a module with flexible parameters, for example. This could be used and reused in many different circumstances. Ergo\u2019s approach This is essentially the approach that Ergo takes, providing superior support for real-world financial agreements. It does this through: Support for multi-stage contracts ( watch details for developers ) A simple high-level language, ErgoScript, enabling clear descriptions of contractual logic Support for formal verification of contracts for improved security guarantees (Ergo Platform deployed its first formally verified p2p crowdfunding contract just three months after the network launched) Easy Oracle creation Native support for complex signature schemes In short, creating financial contracts on the blockchain isn\u2019t just about the functionality you provide. It\u2019s about making that functionality safe and accessible, as well as powerful. Ergo achieves this and more. As the next financial crisis takes hold, it\u2019s clear that conventional monetary policy is at its limit. Smart contract platforms like Ergo enable more innovative, targeted implementations of economic stimulation that the conventional banking sector cannot achieve. Conventional monetary policy is a hammer. It works as far as it goes, but if all you have is a hammer then every problem starts to look like a nail. When the Global Financial Crisis hit over a decade ago, central banks did what they were used to doing. Cutting interest rates means it\u2019s cheaper to borrow money, so there\u2019s more cash in the system that can be spent and will circulate in the economy \u2013 paying for goods and services, funding employment and allowing life to continue something like as normal. That, at any rate, is the theory. It\u2019s what central banks do in recessions to stimulate economic activity. When times are better, they raise interest rates to make it more expensive to borrow money and prevent the economy from overheating (including asset bubbles). The outer limits This is a blunt tool, but it works, up to a point. In the 2008 crisis, the problem was more severe \u2013 so severe, in fact, that interest rates were slashed to zero. Banks were still afraid to lend because they didn\u2019t know the quality of the collateral they were offered in return, those notorious mortgage-backed securities. So the central banks undertook a programme of Quantitative Easing (QE). This entailed creating huge amounts of cash that didn\u2019t exist before, then purchasing various assets from the banks. The idea was that the central bank would take on the risk and the assets, and commercial banks would then use this gift of liquidity to lend to small businesses and individuals, allowing them to continue operating as before. It didn\u2019t work. Little of that newly-created money went to small businesses. Instead, banks used it to shore up their own balance sheets and make their own finances safer, investing only in low-risk assets rather than risky SMEs. Ultimately that cash filtered through to assets like the stock market and property, making the wealthy even more wealthy while the poorer were priced out of the market. Helicopter money Today, as we experience the greatest financial challenge of our lifetimes \u2013 greater than even the Global Financial Crisis \u2013 central banks are considering even more unorthodox approaches. One of these is \u2018helicopter money\u2019. This involves cash being simply airdropped directly to citizens, either in the form of tax breaks or as money straight into their bank accounts. America has discussed giving \\$1,200 to every adult. Other nations are exploring the same idea. But there\u2019s a problem with this, too. Just like the banks, ordinary citizens are worried about their finances. So instead of going out and spending (where \u2018going out\u2019 is even possible), they pay down their debt. That newly-printed money goes nowhere. That\u2019s really as far as central banks can go. But a platform like Ergo can offer different types of money, with different conditions attached via smart contracts, incentivising different behaviour in different circumstances. And that enables a whole different range of monetary policy tools. \u2018Hot potato\u2019 money In normal times, banks seek to maintain an inflation rate of around 2%. This means money is worth less over time. So instead of saving it all, and seeing the value of their savings fall, citizens have the incentive to spend it and circulate it within the economy. Too much inflation, of course, is a bad thing. Get money printing wrong and you have hyperinflation like Venezuela or Zimbabwe, and your economy collapses. But what if we kept inflation low, but created a limited amount of a special class of money that had to be used quickly if it was to retain its value at all? We\u2019ll call this \u2018hot potato\u2019 money, because it has to be passed on fast. Using a blockchain and smart contracts, this would be a simple matter of creating a new token that could be freely transferred and traded, just like any other token. And it could be backed by reserves (held with the central bank, commercial banks or any other entity). But the difference would be that it has to be spent within a month of receiving it, or those tokens are locked, their value is lost to the holder and the funds that back them are freed up to return to the reserve holder. So this would be regular money that people had to spend: use it or lose it. If they hoard it, it becomes useless. And we can ensure that it is not used to pay down debt by including conditions that ensure it cannot be used by the banking sector. Of course, Ergo\u2019s Sigma protocols can be used to figure out what has been spent, where, without knowing individual spending habits \u2013 enabling even more targeted stimulus. This idea likely has far-reaching implications \u2013 and possibly unintended consequences. What would the result be, for example, of creating different \u2018classes\u2019 of money that were only semi-interchangeable? Would this introduce unwelcome, even dangerous friction? This and other questions would need to be explored further. What\u2019s clear is that central banks are already experimenting with unconventional monetary policy and are fast reaching the end of the road. We can continue that experiment with better, more powerful and targeted tools.","title":"Use Cases"},{"location":"uses/use/#privacy","text":"As Eric Hughes wrote in A Cypherpunk\u2019s Manifesto back in 1993, \u2018Privacy is necessary for an open society in the electronic age.\u2019 That is never more true than for financial privacy. Privacy must be a built-in feature of DeFi \u2013 not a bolt on extra or a desirable feature. It must be integral. But, as Hughes continues, \u2018Privacy is the power to selectively reveal oneself to the world.\u2019 There is always a balance to be struck between privacy and compliance, between transparency and anonymity. Large scale adoption of DeFi requires auditability, and the regulatory approval that enables. Thanks to the latest advances in zero-knowledge proofs, Ergo can offer both privacy and transparency, where required. The platform\u2019s Sigma Protocols offer robust, customisable cryptography \u2013 and, at the same time, the ability to selectively reveal information where necessary.","title":"Privacy"},{"location":"uses/use/#scalability","text":"The ability to process thousands of transactions per second is also a non-negotiable feature for a thriving DeFi sector. How this is achieved is less important than that it is achieved; in practice, there will be many different approaches, with different users and protocols selecting the ones they prefer. For example, while we have seen the rise of sidechains and child chains, the reality is that exchanges remain a gateway to the blockchain world for a large proportion of users. Popular exchanges are increasingly integrating DeFi functionality, allowing their vast user bases to access it from their individual accounts, without interacting directly with the protocol. While this may be less than ideal from a security perspective, it\u2019s a simple reality that centralised services are not going out of fashion, but are integrating decentralised technologies thanks to the advantages they offer. Ergo has its own approach to scalability , but we can\u2019t and won\u2019t ignore the importance of businesses in driving forward user adoption.","title":"Scalability"},{"location":"uses/use/#interoperability","text":"One of DeFi\u2019s key strengths is composability: the ability to build new applications from existing components, leveraging the network effect of established dApps and tokens. This is one of the main factors that has enabled TVL to explode over the past month. But composability currently has its limits. Cross-platform composability currently isn\u2019t possible. Even atomic swaps \u2013 the first stage of interoperability \u2013 are in their infancy, though Ergo is working on an atomic swap-powered DEX . Full interoperability means the ability for a user to execute a smart contract on one platform and have it seamlessly interact with another blockchain. This would allow truly frictionless cross-protocol interaction, and is what is needed to enable the flow of liquidity fully throughout the DeFi world. At that point, applications become blockchain agnostic, and the platforms are really more like the programming languages for accessing dApps\u2019 functionality.","title":"Interoperability"},{"location":"uses/use/#decentralisation","text":"Lastly, and specifically in the context of scalability and interoperability, we cannot forget the importance of decentralisation \u2013 something Ergo has always taken seriously . Of course DeFi is decentralised \u2013 but there are different types of decentralisation. Ethereum, the home of almost every major DeFi dApp, is just one platform. Ethereum\u2019s developers are working on a plan for scaling, but even if this is successful, it is still one blockchain. Should we entrust all our funds to one network? What if a critical bug or exploit is found? Interoperability does more than enable cross-chain liquidity. It decentralises the decentralised infrastructure for DeFi, adding layers of redundancy and security. In the process, it strengthens every blockchain that is a part of that ecosystem, creating a whole that is more than the sum of its parts. At a time when relatively large blockchains still suffer double spend attacks and serious reorgs , and catastrophic vulnerabilities are found in smart contracts holding tens of millions of dollars of value, we cannot assume that one single blockchain will or should rule them all.","title":"Decentralisation"},{"location":"uses/use/#cdbcs","text":"As blockchain technology gains traction, central bank digital currencies are among the most significant applications being developed. But these will inevitably fall far short of the ideal, for one simple reason: control. In particular, that has implications for composability and privacy, and much else besides. Central bank digital currencies are no longer a theoretical application of blockchain technology. The list of countries developing CBDCs is growing rapidly, with several now trialing state-backed digital cash. CDBCs are not built on classic, open blockchain technology. While there are various approaches, they are all based on permissioned ledgers that restrict the role of securing the network and processing transactions to a group of approved entities. They also include a control layer that gives administrators the ability to intervene in transactions, blocking or reversing those they deem invalid. It\u2019s a far cry from the ideals of Bitcoin, and the Ergo platform that aims to build on these. But it\u2019s only to be expected. The state has a role and a remit, and it\u2019s unlikely to give up the control it exercises. Unfortunately, though, there are two ways that holding onto control will mean that CBDCs fall far short of what they could be, meaning they may ultimately cede ground to open platforms like Ergo.","title":"CDBCs"},{"location":"uses/use/#composability","text":"As we wrote in a recent blog, composability is a core feature of DeFi. It\u2019s what gives applications network effect, instantly adding value by plugging into existing dapps\u2019 user bases and functionality. Programmable money is a huge development. The current system is clunky and complicated to use, at best. It\u2019s not possible to attach detailed conditions to transactions, and have them interact seamlessly with software, as can be done with blockchain and smart contracts. Imagine the value that could be unlocked if CBDCs were programmable, and smart cash could be integrated frictionlessly into new applications \u2013 banking interfaces, investment services, stores, social networks, games. The list is endless. But this is hardly likely. The freedom to program money will exist, for many years at least, in the open blockchain space alone.","title":"Composability"},{"location":"uses/use/#privacy_1","text":"Secondly, we consider privacy to be a core requirement of DeFi. Money is too important to be used as a tool of surveillance, but there is no question that this is what it will become as soon as the first CBDCs are rolled out to a large user base. China is one of the furthest ahead in its creation of state-backed digital cash. This is a state that is notorious for its internet censorship and online surveillance of its population. Its human rights record is dire, and in recent days we have learned more about its oppression of the Uighur minority. Moreover, China already uses a social credit system, which grants or denies citizens access to certain services and amenities depending on their social score, with model citizens enjoying greater privileges. There is, again, no question that a state-backed, traceable CBDC will be used as a tool of surveillance on a scale that is unprecedented in human history. And it will be the same across any nation that implements money within the same framework. That giant eye on the dollar bill? You ain\u2019t seen nothing yet.","title":"Privacy"},{"location":"uses/use/#private-programmable-financial-services","text":"Ergo has a very different vision for blockchain-based cash and financial services. In the new paradigm of blockchain, value is not retained by constraining it. It is only maximised through open systems that make it as accessible as people want it to be. Money without borders, in both senses: cash that can be programmed, sent and received freely but privately, between any two individuals or organisations \u2013 and even blockchains \u2013 anywhere in the world. This is what money needs to be, and what Ergo is building. This is the first in a series of articles speculating on how the fast-emerging DeFi sector might evolve in the coming years. The DeFi movement as it currently exists is only a few months old, and blockchain itself has barely existed a decade. Already, though, we are beginning to see themes crystallising and the first popular use cases becoming established. As a DeFi platform that takes positioning for the future seriously, it\u2019s important that Ergo has a vision \u2013 not only a sense of where things might be heading, but the role that it should itself be playing as these new decentralised financial services consolidate and grow in popularity. While no one can know the future, least of all in this space, a number of trends, technologies, products and use cases are emerging, and it seems that these are starting to plot a certain trajectory. Allowing for necessary course correction as time goes on, where might we see DeFi end up in ten years?","title":"Private, programmable financial services"},{"location":"uses/use/#tokens-will-be-the-fuel-for-defi-and-everything-will-be-tokenised","text":"One of the major themes that was becoming apparent, long before the yield farming craze brought DeFi to global attention, is tokenisation. We already have blockchain tokens representing cryptocurrencies and digital assets, and the first shares and other securities have been issued on the blockchain. The benefits are such that the direction of travel is clear. Sooner or later, everything will end up as tokens. For regular, fungible (interchangeable) assets, a regular token will work. Fiat and cryptocurrencies, shares, bonds, precious metals, ETFs, CBDCs \u2013 these will all be freely available on the blockchain. For other assets, NFTs will proliferate. When you buy a car, house, painting or other unique item of value, whether digital or physical, there\u2019s a good chance that transaction will also include a blockchain token. These tokenised assets will place on the blockchain trillions of dollars of value that are currently \u2018stuck\u2019 offline, illiquid or impossible to buy or sell outside of certain limited circles and circumstances. This pool of tokenised value will represent the fuel of the Defi economy: assets that can be traded frictionlessly, borrowed against and leveraged using decentralised protocols that probably won\u2019t look so very different to the ones we use today.","title":"Tokens will be the fuel for DeFi, and everything will be tokenised"},{"location":"uses/use/#digital-identity-will-become-non-negotiable","text":"Since these assets will be tradeable on centralised and decentralised exchanges, digital identity will also become an increasingly important theme. This will link blockchain addresses with offline identities, enabling individuals and corporations to operate in a way that is compliant with relevant regulation. It will also allow the automation of tax and accounting processes. To date, digital identity has been an overlooked element of the DeFi ecosystem \u2013 likely due to the use of centralised platforms that can conduct KYC as a condition of use. We\u2019re fast approaching a point where that is no longer a given, with the growth of new forms of decentralised exchange and the increase in volumes moving to these platforms.","title":"Digital identity will become non-negotiable"},{"location":"uses/use/#stablecoins-will-become-embedded-elements-of-the-blockchain","text":"One of the biggest use cases for DeFi \u2013 and again one that is often overlooked \u2013 is stablecoins. These exist in many forms, and rely on a range of approaches: centralised and decentralised, collateralised and algorithmic, fiat-backed, and so on. Whatever your preferred approach or view of stablecoins, they are here to stay. They have found use cases as a store of value, especially for traders, and as a popular form of collateral for yield farming. What they haven\u2019t been widely adopted for, yet, is as an integral part of blockchain infrastructure. Transaction fees are almost always paid for with the native blockchain token. Not only does this fluctuate in value, but so does the amount of it required per transaction, depending on both the complexity of the transaction itself and competition for space in the next block. Clearly, this complexity is not conducive to mainstream adoption. End users are best served by simplicity, with minimal burdens for managing multiple tokens. They will want to pay transaction fees in a stable unit of account, and not have to worry about handling the native blockchain token. The solution? An integrated stablecoin that, to most end users, is the most important token on the platform.","title":"Stablecoins will become embedded elements of the blockchain"},{"location":"uses/use/#two-tier-system","text":"As a result of this need, it seems likely that we may start to see a two-tier system evolve more clearly. A blockchain such as Ergo will have a native token, which will serve as the underlying currency of payment, just as occurs now. For the most part, though, these will only be handled by more experienced users. These expert users will maintain the technical and financial infrastructure of the DeFi space. For example, they will mine and use the native token as collateral to create a stablecoin, which can be sold into the market for general use, in return for tokenised assets of all kinds. Regular users will then use the \u2018native stablecoin\u2019 in all their business, as a kind of standard reserve currency. It will be used to buy other assets; it will be lent to users against other tokenised assets as collateral (houses, cars, real estate and much more); and it will be used to pay transaction fees. The miners who receive this native stablecoin can hold it as it is, to pay for electricity and hardware costs, or they can convert it back to the platform token or other assets \u2013 that is up to them. These are just some of the themes we are starting to see emerging in the DeFi world, and how they might develop over time. In the coming weeks, we\u2019ll explore various other ideas as the space continues to evolve and Ergo launches new technology. Ergo enables new models of financial interaction, underpinned by smart contracts built on flexible and powerful Sigma protocols but easily accessible to developers. One of the most exciting things about blockchain is the possibility of making digital agreements without any trusted intermediaries. In the simplest use case, pioneered by Bitcoin, Alice can send a payment directly to Bob, wherever the two of them are located around the world, with no bank or any trusted third party needed. However, with the functionality of a modern blockchain like Ergo, it is possible to make far more complex and sophisticated financial agreements than simple payments. Take the following example.","title":"Two-tier system"},{"location":"uses/use/#gold-backed-tokens","text":"Alice uses ERGs to purchase gold-backed tokens from Bob. Bob stores the gold in a secure vault, and uses the blockchain to issue one token for every Troy ounce of gold he has. Alice can then use these tokens freely in different contracts, transferring and trading them under whatever conditions she specifies in the smart contract code. When Alice wants to sell the tokens for physical gold, she can conduct another transaction with Bob, receiving ERG in return, at market price. The point of blockchain contracts is to eliminate the need for trust. While the purchase transaction is now trustless, in this instance Alice still needs to trust Bob about two things. Firstly, Bob may refuse to swap the gold tokens back to ERG at the correct price when Alice wants to sell. Secondly, Bob may default on his obligations \u2013 running away with the gold, or misusing the funds he receives and running a fractional reserve.","title":"Gold-backed tokens"},{"location":"uses/use/#extending-the-contracts","text":"To address these issues, we can create an Oracle, or decentralised price feed. This uses multiple sources of external data to record the price of gold to the blockchain at regular intervals. This price feed will be the reference point for the redemption contract that manages the sale of Alice\u2019s gold with Bob (or any other participant). Thus the system automatically enforces the right price when a swap takes place. The second situation requires a third-party insurer, Charlie, whose service is also hosted on the blockchain with a smart contract. When Alice purchases gold from Bob, she additionally buys an insurance contract from Charlie. The payment can be dependent on factors including the amount of insurance required, and Bob\u2019s reputation \u2013 again, managed by a decentralized feedback mechanism. Now, if Bob defaults, Alice will automatically receive the value of her gold tokens, with Charlie effectively acting as a buyer of last resort.","title":"Extending the contracts"},{"location":"uses/use/#programmable-contracts","text":"There are, of course, many other example use cases like this one. We can also extend this use case, adding further economic actors. For example, Charlie may sell shares in his insurance business to Dave and other participants, providing them with a proportion of revenues in return for ensuring he has the capital he needs to cover any liabilities from the outset. However, even the most complex use case is simpler than general-purpose software that can be used to program any contract. After all, generalised logic must be both far-reaching and secure. Moreover, even a specialised contract is made up of many steps, each of which is fairly simple. Thus another requirement for a general-purpose platform is that it should simplify the process of writing contracts, making them as accessible (and safe) as possible. This can be achieved with the use of template agreements, with customisable parameters. The insurance contract above could be based on a module with flexible parameters, for example. This could be used and reused in many different circumstances.","title":"Programmable contracts"},{"location":"uses/use/#ergos-approach","text":"This is essentially the approach that Ergo takes, providing superior support for real-world financial agreements. It does this through: Support for multi-stage contracts ( watch details for developers ) A simple high-level language, ErgoScript, enabling clear descriptions of contractual logic Support for formal verification of contracts for improved security guarantees (Ergo Platform deployed its first formally verified p2p crowdfunding contract just three months after the network launched) Easy Oracle creation Native support for complex signature schemes In short, creating financial contracts on the blockchain isn\u2019t just about the functionality you provide. It\u2019s about making that functionality safe and accessible, as well as powerful. Ergo achieves this and more. As the next financial crisis takes hold, it\u2019s clear that conventional monetary policy is at its limit. Smart contract platforms like Ergo enable more innovative, targeted implementations of economic stimulation that the conventional banking sector cannot achieve. Conventional monetary policy is a hammer. It works as far as it goes, but if all you have is a hammer then every problem starts to look like a nail. When the Global Financial Crisis hit over a decade ago, central banks did what they were used to doing. Cutting interest rates means it\u2019s cheaper to borrow money, so there\u2019s more cash in the system that can be spent and will circulate in the economy \u2013 paying for goods and services, funding employment and allowing life to continue something like as normal. That, at any rate, is the theory. It\u2019s what central banks do in recessions to stimulate economic activity. When times are better, they raise interest rates to make it more expensive to borrow money and prevent the economy from overheating (including asset bubbles).","title":"Ergo\u2019s approach"},{"location":"uses/use/#the-outer-limits","text":"This is a blunt tool, but it works, up to a point. In the 2008 crisis, the problem was more severe \u2013 so severe, in fact, that interest rates were slashed to zero. Banks were still afraid to lend because they didn\u2019t know the quality of the collateral they were offered in return, those notorious mortgage-backed securities. So the central banks undertook a programme of Quantitative Easing (QE). This entailed creating huge amounts of cash that didn\u2019t exist before, then purchasing various assets from the banks. The idea was that the central bank would take on the risk and the assets, and commercial banks would then use this gift of liquidity to lend to small businesses and individuals, allowing them to continue operating as before. It didn\u2019t work. Little of that newly-created money went to small businesses. Instead, banks used it to shore up their own balance sheets and make their own finances safer, investing only in low-risk assets rather than risky SMEs. Ultimately that cash filtered through to assets like the stock market and property, making the wealthy even more wealthy while the poorer were priced out of the market.","title":"The outer limits"},{"location":"uses/use/#helicopter-money","text":"Today, as we experience the greatest financial challenge of our lifetimes \u2013 greater than even the Global Financial Crisis \u2013 central banks are considering even more unorthodox approaches. One of these is \u2018helicopter money\u2019. This involves cash being simply airdropped directly to citizens, either in the form of tax breaks or as money straight into their bank accounts. America has discussed giving \\$1,200 to every adult. Other nations are exploring the same idea. But there\u2019s a problem with this, too. Just like the banks, ordinary citizens are worried about their finances. So instead of going out and spending (where \u2018going out\u2019 is even possible), they pay down their debt. That newly-printed money goes nowhere. That\u2019s really as far as central banks can go. But a platform like Ergo can offer different types of money, with different conditions attached via smart contracts, incentivising different behaviour in different circumstances. And that enables a whole different range of monetary policy tools.","title":"Helicopter money"},{"location":"uses/use/#hot-potato-money","text":"In normal times, banks seek to maintain an inflation rate of around 2%. This means money is worth less over time. So instead of saving it all, and seeing the value of their savings fall, citizens have the incentive to spend it and circulate it within the economy. Too much inflation, of course, is a bad thing. Get money printing wrong and you have hyperinflation like Venezuela or Zimbabwe, and your economy collapses. But what if we kept inflation low, but created a limited amount of a special class of money that had to be used quickly if it was to retain its value at all? We\u2019ll call this \u2018hot potato\u2019 money, because it has to be passed on fast. Using a blockchain and smart contracts, this would be a simple matter of creating a new token that could be freely transferred and traded, just like any other token. And it could be backed by reserves (held with the central bank, commercial banks or any other entity). But the difference would be that it has to be spent within a month of receiving it, or those tokens are locked, their value is lost to the holder and the funds that back them are freed up to return to the reserve holder. So this would be regular money that people had to spend: use it or lose it. If they hoard it, it becomes useless. And we can ensure that it is not used to pay down debt by including conditions that ensure it cannot be used by the banking sector. Of course, Ergo\u2019s Sigma protocols can be used to figure out what has been spent, where, without knowing individual spending habits \u2013 enabling even more targeted stimulus. This idea likely has far-reaching implications \u2013 and possibly unintended consequences. What would the result be, for example, of creating different \u2018classes\u2019 of money that were only semi-interchangeable? Would this introduce unwelcome, even dangerous friction? This and other questions would need to be explored further. What\u2019s clear is that central banks are already experimenting with unconventional monetary policy and are fast reaching the end of the road. We can continue that experiment with better, more powerful and targeted tools.","title":"\u2018Hot potato\u2019 money"},{"location":"uses/zk/","text":"Ergo\u2019s Zero-Knowledge Treasury enables users to easily create joint digital signatures, with bespoke conditions for spending funds while ensuring the signatories to the created address remain hidden. Zero-Knowledge (ZK) cryptography offers lots of powerful use cases. The benefit of ZK operations is that not only are they secure, but they\u2019re private. Imagine you find a smartphone on the ground in the park. A woman close by claims it\u2019s hers, but you don\u2019t trust her. Perhaps she just wants the phone. She could give you the unlock code, but then you\u2019d gain information that, as the owner, she wouldn\u2019t want you to have. So, you close your eyes and hold out the phone, and when you open them, the screen is unlocked. She has proved ownership without giving away sensitive information. That\u2019s a simple example of a zero-knowledge proof. The applications in the blockchain world are compelling. Consider a conventional two-of-three multi-sig address on the Bitcoin blockchain. This requires that any two out of three private key holders for that address have to sign a transaction for funds to be moved. It\u2019s a lot more secure than a single-signature address, but it lacks privacy. Anyone can look at the blockchain and know exactly who signed the transaction. With a zero-knowledge signature, no one knows who is responsible for a transaction \u2013 only that the required number of private keys have signed it. Ergo\u2019s Sigma Protocols are excellent for creating composable ZK signatures. In other words, a group of users can get together and create an address with the conditions they specify. For example, five users could create an address that any three of them need to sign to make a transaction. Or the conditions could be more complicated. A startup consisting of seven people could create an address whereby the CEO and CFO both have to sign to release funds, or else any five key holders can sign a transaction (offering an insurance policy if either CEO or CFO is out of action). Ergo has always been a community-driven project, and we\u2019ve always had solid and enthusiastic support from our developers, many of whom prefer to remain anonymous. One of our anons has pioneered a user-friendly interface that makes it easy to form joint spending groups that require a quorum of signatories to make a transaction (since the process for doing this was previously complex, even for more technical users). User \u2018anon_real\u2019 writes : This project contains two separate apps, server and client. The server is accessible by everyone who can propose ideas and ask for funds from a team. On the other hand, every team member has to set up the client app, which will interact with their secret, node, explorer, and server to create the necessary proofs for approved proposals. If a proposal is marked as fully approved (enough approvals have been collected based on the team\u2019s signature), then client apps will generate necessary proofs and transactions in the background without needing any intervention by members. You can find further discussion of the Zero-Knowledge Treasury on the Ergo forum . There are lots of use cases for this application beyond securely spending funds on Ergo. For example, a similar interface could be the foundation of decentralised public key infrastructure (dPKI): a means of generating and managing public/private keypairs to authenticate users and devices, but without the centralised points of failure that exist in trusted PKI setups. A big thanks to anon_real, and we look forward to seeing the ZK Treasury used in the Ergo community!","title":"Zero-Knowledge"}]}