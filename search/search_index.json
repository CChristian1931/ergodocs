{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Ergo Platform Documentation! Ergo uses continous integration, meaning best practices dictate that the majority of the documentation should be kept on the assosciated repositories themselves. this site aims to serve as a directory that guides the user on their development journey. Documentation within the naviation tabs above is split into four distinct categories. Tutorials How-To Guides Explanations References Read more about the format used on this website. Other resources awesome-ergo ergonaut.space ergosites.github","title":"Home"},{"location":"#welcome-to-the-ergo-platform-documentation","text":"Ergo uses continous integration, meaning best practices dictate that the majority of the documentation should be kept on the assosciated repositories themselves. this site aims to serve as a directory that guides the user on their development journey. Documentation within the naviation tabs above is split into four distinct categories. Tutorials How-To Guides Explanations References Read more about the format used on this website.","title":"Welcome to the Ergo Platform Documentation!"},{"location":"#other-resources","text":"awesome-ergo ergonaut.space ergosites.github","title":"Other resources"},{"location":"About/events/","text":"ERGOHACK ERGOHACK I Hackerthon Jun 12th! ERGOHACK II ERGOHACK III ErgoSummit ErgoSummit I ErgoSummit Timestamps 00:00:00 - The Summit 00:01:00 - Ergo 101: The Basics 00:40:00 - Cardano & Ergo\u2019s UTXO Model 01:11:30 - DeFi Services: How Yoroi Wallet will be the gateway to Ergo dApps and what\u2019s to come 01:32:30 - Auction House 01:49:30 - Announcing The Release Of The AgeUSD Stablecoin Protocol 02:18:00 - An IOHK Perspective: Designing The AgeUSD Stablecoin Protocol - An Economic Analysis (with Special Guest IOHK\u2019s Bruno) 03:02:00 - AgeUSD Smart Contracts: A Technical Perspective 03:41:00 - Enter Into The Sigmaverse - Uncovering What Lays Within Ergo\u2019s dApp Ecosystem 03:47:30 - Ergo-Bootstrap - Streamlining Ergo dApp Infrastructure With One Simple Tool 03:59:30 - Headless dApps: A Novel Technical & Business Model for the dApp Industry 04:28:00 - Ergo - Cardano Collaboration 04:38:00 - Understanding dApp Developer Tooling: An Introduction To Kiosk [05:13:00] (https://www.youtube.com/watch?v=zG-rxMCDIa0&t=18780s) - The Upcoming Ergo Hardening Upgrade - How It Will Change The Ecosystem From Top To Bottom 05:26:30 - Oracle Pools Update - How Deviation Checking Consensus Improves Assurance 05:57:00 - Updatable dApps In The EUTXO Model 06:10:00 - Blockchain 2020: A DeFi Odyssey 06:51:00 - The Ergo Vision 07:03:00 - ZK Treasury 07:07:00 - Understanding dApp Developer Tooling: An Introduction To Json dApp Environment 07:45:30 - The Ergo Foundation\u2019s Grant-Based Approach To Developing The UTXO-Based dApp Ecosystem 08:05:30 - 2021 Ergo Roadmap reveal ErgoSummit II Q4 2021","title":"Events"},{"location":"About/events/#ergohack","text":"","title":"ERGOHACK"},{"location":"About/events/#ergohack-i","text":"Hackerthon Jun 12th!","title":"ERGOHACK I"},{"location":"About/events/#ergohack-ii","text":"","title":"ERGOHACK II"},{"location":"About/events/#ergohack-iii","text":"","title":"ERGOHACK III"},{"location":"About/events/#ergosummit","text":"","title":"ErgoSummit"},{"location":"About/events/#ergosummit-i","text":"","title":"ErgoSummit I"},{"location":"About/events/#ergosummit-timestamps","text":"00:00:00 - The Summit 00:01:00 - Ergo 101: The Basics 00:40:00 - Cardano & Ergo\u2019s UTXO Model 01:11:30 - DeFi Services: How Yoroi Wallet will be the gateway to Ergo dApps and what\u2019s to come 01:32:30 - Auction House 01:49:30 - Announcing The Release Of The AgeUSD Stablecoin Protocol 02:18:00 - An IOHK Perspective: Designing The AgeUSD Stablecoin Protocol - An Economic Analysis (with Special Guest IOHK\u2019s Bruno) 03:02:00 - AgeUSD Smart Contracts: A Technical Perspective 03:41:00 - Enter Into The Sigmaverse - Uncovering What Lays Within Ergo\u2019s dApp Ecosystem 03:47:30 - Ergo-Bootstrap - Streamlining Ergo dApp Infrastructure With One Simple Tool 03:59:30 - Headless dApps: A Novel Technical & Business Model for the dApp Industry 04:28:00 - Ergo - Cardano Collaboration 04:38:00 - Understanding dApp Developer Tooling: An Introduction To Kiosk [05:13:00] (https://www.youtube.com/watch?v=zG-rxMCDIa0&t=18780s) - The Upcoming Ergo Hardening Upgrade - How It Will Change The Ecosystem From Top To Bottom 05:26:30 - Oracle Pools Update - How Deviation Checking Consensus Improves Assurance 05:57:00 - Updatable dApps In The EUTXO Model 06:10:00 - Blockchain 2020: A DeFi Odyssey 06:51:00 - The Ergo Vision 07:03:00 - ZK Treasury 07:07:00 - Understanding dApp Developer Tooling: An Introduction To Json dApp Environment 07:45:30 - The Ergo Foundation\u2019s Grant-Based Approach To Developing The UTXO-Based dApp Ecosystem 08:05:30 - 2021 Ergo Roadmap reveal","title":"ErgoSummit Timestamps"},{"location":"About/events/#ergosummit-ii","text":"Q4 2021","title":"ErgoSummit II"},{"location":"About/faq/","text":"Basics What is the teams background? | Ergo is designed and implemented by a team of experienced developers and researchers, who hold publications and PhDs in cryptography, compiler theory, blockchain technology, and cryptographic e-cash. The team also has a solid background in core development with such cryptocurrencies and blockchain frameworks as Nxt, Scorex and Waves. Alexander 'kushti' Chepurnoy, was a co-founder of smartcontract.com (now Chainlink), a core developer at NXT (first PoS), and one of the first employees at IOHK, where he was a Research Fellow and Team Scorex Manager. The full team can be seen on Ergo's Hall of Fame . Why 'Ergo'? | \u201cErgo means \u201ctherefore\u201d in Latin, but \u201cwork\u201d in Greek. Initially, the name was chosen to point to the fact that the design of the cryptocurrency is ERGOnomical. What is the emission schedule? | Emission Schedule with a maximum supply of 97,739,925 Ergs, to be completed in 8 years after launch. When was Ergo launched? | July, 2019. The previous price spike was a different token (Ergo-First-Year-Token), if you view the chart by market-cap it is accurate. Where can I buy Erg? | KuCoin, CoinEx, TradeOgre, gate.io. Where can I store Erg? | Yoroi or the Android Wallet. Is there mobile support? | Android only currently, iOS in development Can we use a hardware wallet? | Ledger support underway. Workaround: You can move your Erg to waves.exchange and stake your erg through that. Can I stake ERG? | No, Ergo is a Proof of Work coin - you can however provide liquidity on either the CoinEx AMM pool (watch out for impermanent loss!), or SigmaUSD. However, dApp tokenisation is coming - A Solution for staking Ergo Foundation What is the Ergo Foundation? | The Ergo Foundation is a community-driven entity focused on: Promoting non-breaking development of Ergo Platform protocol; Promoting the widespread adoption and use of Ergo Platform and its native token (ERG); Developing the ecosystem around the Ergo Platform; Promoting the use of Ergo Platform and blockchain technology for social good; Supporting truly decentralized infrastructure, and; Supporting privacy as a basic human right. Deep Dives Ergo: Road to Top 10 ergonaut.space Infographics \u201cIt's one of the most revolutionary cryptocurrencies ever built. Got so many crazy ideas like sigma protocols and pruning the blockchain and roller chains. All this crazy stuff. Even has a proof of no premine. So really a technological marvel in many respects, and it reflects about 8 years of knowledge that Alex has amassed as both a researcher and a developer. Super concise code and it blows my mind that the market cap is where it's at. It should be a top 10 coin or top 15 coin\" \u2014 Charles Hoskinson Get some perspective Proof of Work Ergo was created for regular people, PoW allows for a fair start and true decentralistion. It's also widely studied, and has very high-security guarantees - which are essential for having useful contractual, programmable money that's ready today. Here's CH talking a bit about consensus Why Proof-of-Work? | It's tried and tested (the Lindy effect), and has some advantages over PoS. What about 51% attacks? | Not a significant problem, more pools are being added. Ergo's Efficiency and interplay with PoS - Discussion Can I mine ERG? | To mine, you will need a dedicated GPU (AMD/Intel), see this page on mining What will Erg bring to ADA? Features Storage Rent | After four years, miners can charge fees for unmoved erg. Stabilising miner income and preventing lost coins as we see in BTC. Sigma Protocols | Ergo\u2019s smart contracts and DeFi functionality are built on Sigma protocols \u2013 a powerful, flexible class of zero-knowledge proofs. Find out more about why they\u2019re so important, and how they put Ergo head and shoulders above the competition. eUTxO | Based on the UTXO model of Bitcoin, similar extended-UTXO model as Cardano, allowing interoperability. NiPoPoWs | Verify proof of work without downloading the headers. Enables light-clients during in places with poor internet - and light mining (not having to download the entire chain) dApps Ergo already has several functional decentralised applications | sigmaverse.io ErgoMixer | the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space . SigmaUSD | DAI-like Stablecoin - without liquidations. AuctionHouse | Working NFT marketplace. Oracle-Pools | More efficient and programmable than using multiple single oracle data points such as in Chainlink\u2019s oracle design. We build hierarchies of confidence using oracle pools and pools of oracle pools in Ergo. It\u2019s faster, cheaper, and more beneficial to the end-user. In-Development ErgoDex | Decentralised exchange that runs ontop ADA & ERG. ErgoFund | Crowdfunding on Ergo Use cases Ergo is one of the most sophisticated protocols in the space with stateless clients, NiPoPoWS for light clients, and easy miner-voting on parameter changes (e.g, block size) Ergo aims to provide an efficient, secure, and easy way to implement financial contracts that will be useful and survivable in the long term. There is plenty of uniqueness in Ergo but the most significant is probably Sigma protocols. These allow a true P2P system with privacy in mind. No one at the moment is able to build a trustless LETS system, multisig with no signers disclosure, trustless payment networks or has real ring signatures that preserve zero knowledge. Local Exchange Trading System - a local mutual credit association which members are allowed to create common credit money individually, with all the deals in the system written into a common ledger. To the best of our knowledge, this is the first implementation of such kind of community currency on top of a blockchain. LETS can be thought of as a mechanism to facilitate the velocity of trade, goods, and services out-with the existing monetary system, allowing us to create sustainable local economies. Smart contracts without gas fees. Ergo\u2019s native programming language \u2014 aka ErgoScript \u2014 enables the development of Turing complete contracts that completely bypass the need for any gas fee while providing other peripheral benefits such as estimation of script complexity before execution, a facet that helps in the active prevention of DoS attacks. Ergo.Meta - a unified set of design patterns for off-chain and sidechain solutions ErgoScript : a new advanced transactional language built from scratch by the team. Tutorials are available on the website /docs/AdvancedErgoScriptTutorial.pdf. It is a more advanced scripting language than Bitcoin while maintaining security and not introducing blockchain bloat problems. Scripting language in itself is non-Turing complete but applications ran on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper https://arxiv.org/pdf/1806.10116v1.pdf. Rigorous research and scientific approach : Ergo is based on original research, published at known peer-reviewed conferences. A list of scientific papers is available at here , but Ergo is not limited by research and it also implements other novel scientific ideas. Trustless Light Clients with Minimal Resource Requirements: Ergo block header supports NiPoPoWs that enable synchronizing network by downloading < 1Mb of data. This is further made possible by the fact Ergo state is authenticated as detailed in this paper from 2017 New Economic Model : Key feature of the new model is miners charge users a fee for any UTXO that remains unmoved for 4 years (\u201cstorage rent fee\u201d). This accomplishes stable mining revenue to secure the network, prevents \u201cstate bloat\u201d and enables a short release schedule \u2013 Ergo emission fully completes in just 8 years. Details in this paper Mined from Zero via PoW with no ICO or Pre-mine . It is about a hope to achieve a fair distribution of Ergs as possible to enhance decentralization. Decentralization First : Core commitment of Development team and community. Top item in \u201cErgo Vision\u201d section of white paper. Many of the above features\u2019 main purpose is to achieve this goal. Resiliency and Survivability : Decentralization First is to accomplish this goal. Ergo should be alive and operational for an indefinite amount of time and Contractual Money contracts on Ergo should be able to survive for at least the length of a person\u2019s lifetime despite a changing external environment. Privacy : Privacy is optional in Ergo, but it still beats a lot of privacy coins by default. You can actually put XMR on top, but Ergo itself can achieve privacy of early Monero if there are enough users of the mixers. Actually, it can be far better, as no inference scenarios are possible as described in this paper . Related: ErgoMixer Other : Ergo offers anyone the ability to issue their own tokens (non-native tokens) on the platform and leverage off its security and decentralization. Advanced on-chain governance is built with miners being able to vote on a number of parameters including simple items like block size \u2013 gradual changes only to ensure stability. Ergo follows a soft-forkability approach --- if an overwhelming majority of the network accepts a new feature, it is activated, however, old nodes which do not upgrade continue to operate normally and just skip over this feature validation. Thus disruptive hard forks should not be required in Ergo. Ergo mining will always be stable, unlike Bitcoin and other PoW currencies, in which mining may become unstable after the emission period. To achieve survivability, Ergo provides economic improvements in addition to the technical ones, most central of which is a storage fee component which plays an important role for Ergo\u2018s stability. Scalability The blocks in the Ergo Network are aimed to be produced at an interval of approx. 2 minutes. TPS itself doesn't matter much for Ergo in the long run since it has smart contracts in which you can chain hundreds of transactions within one. Ergo\u2019s solutions to transaction congestion are as follows: L0: A lot of efficiency improvements in the node have been completed starting from v4.0.8, 20-50x gains are still possible here. Quick bootstrapping using NiPoPoWs proofs and UTXO set snapshots are also planned L1: Ergo has an extension section in its code that allows the implementation of a wide variety of scaling solutions such as Sharding, Hydra, or BitcoinNG-style macroblocks. This even lets us do generic sidechains with velvet or soft forks. L2 (off-chain) - Ergo should be compatible with the Lightning Network, Rainbow Network, and many more. The implementation here will depend on the needs of the applications being built on Ergo. Ergo has stateless clients, NiPoPoWs - can put full nodes on Raspberry Pi's, make ultra-efficient SPV clients and other means to survive in the long-term even under the load. Storage rent helps to prevent spam & dust and stabilize mining income. Other benefits from having the storage rent fee include prevention of \"state bloat\", the building of an economy around the state (users must pay to keep unspent boxes in miners' memory for the long\u2010term) and a gradual return of any lost coins back into circulation. Partnerships / Business Development Yoroi dApp Connector | In Testing! Waves Partners with Ergo to foster Interoperability solutions | In Testing! Cryptocurrencycheckout: Supports both SigUSD and Ergo. Roadmap","title":"FAQ"},{"location":"About/faq/#basics","text":"What is the teams background? | Ergo is designed and implemented by a team of experienced developers and researchers, who hold publications and PhDs in cryptography, compiler theory, blockchain technology, and cryptographic e-cash. The team also has a solid background in core development with such cryptocurrencies and blockchain frameworks as Nxt, Scorex and Waves. Alexander 'kushti' Chepurnoy, was a co-founder of smartcontract.com (now Chainlink), a core developer at NXT (first PoS), and one of the first employees at IOHK, where he was a Research Fellow and Team Scorex Manager. The full team can be seen on Ergo's Hall of Fame . Why 'Ergo'? | \u201cErgo means \u201ctherefore\u201d in Latin, but \u201cwork\u201d in Greek. Initially, the name was chosen to point to the fact that the design of the cryptocurrency is ERGOnomical. What is the emission schedule? | Emission Schedule with a maximum supply of 97,739,925 Ergs, to be completed in 8 years after launch. When was Ergo launched? | July, 2019. The previous price spike was a different token (Ergo-First-Year-Token), if you view the chart by market-cap it is accurate. Where can I buy Erg? | KuCoin, CoinEx, TradeOgre, gate.io. Where can I store Erg? | Yoroi or the Android Wallet. Is there mobile support? | Android only currently, iOS in development Can we use a hardware wallet? | Ledger support underway. Workaround: You can move your Erg to waves.exchange and stake your erg through that. Can I stake ERG? | No, Ergo is a Proof of Work coin - you can however provide liquidity on either the CoinEx AMM pool (watch out for impermanent loss!), or SigmaUSD. However, dApp tokenisation is coming - A Solution for staking","title":"Basics"},{"location":"About/faq/#ergo-foundation","text":"What is the Ergo Foundation? | The Ergo Foundation is a community-driven entity focused on: Promoting non-breaking development of Ergo Platform protocol; Promoting the widespread adoption and use of Ergo Platform and its native token (ERG); Developing the ecosystem around the Ergo Platform; Promoting the use of Ergo Platform and blockchain technology for social good; Supporting truly decentralized infrastructure, and; Supporting privacy as a basic human right.","title":"Ergo Foundation"},{"location":"About/faq/#deep-dives","text":"Ergo: Road to Top 10 ergonaut.space Infographics \u201cIt's one of the most revolutionary cryptocurrencies ever built. Got so many crazy ideas like sigma protocols and pruning the blockchain and roller chains. All this crazy stuff. Even has a proof of no premine. So really a technological marvel in many respects, and it reflects about 8 years of knowledge that Alex has amassed as both a researcher and a developer. Super concise code and it blows my mind that the market cap is where it's at. It should be a top 10 coin or top 15 coin\" \u2014 Charles Hoskinson Get some perspective","title":"Deep Dives"},{"location":"About/faq/#proof-of-work","text":"Ergo was created for regular people, PoW allows for a fair start and true decentralistion. It's also widely studied, and has very high-security guarantees - which are essential for having useful contractual, programmable money that's ready today. Here's CH talking a bit about consensus Why Proof-of-Work? | It's tried and tested (the Lindy effect), and has some advantages over PoS. What about 51% attacks? | Not a significant problem, more pools are being added. Ergo's Efficiency and interplay with PoS - Discussion Can I mine ERG? | To mine, you will need a dedicated GPU (AMD/Intel), see this page on mining What will Erg bring to ADA?","title":"Proof of Work"},{"location":"About/faq/#features","text":"Storage Rent | After four years, miners can charge fees for unmoved erg. Stabilising miner income and preventing lost coins as we see in BTC. Sigma Protocols | Ergo\u2019s smart contracts and DeFi functionality are built on Sigma protocols \u2013 a powerful, flexible class of zero-knowledge proofs. Find out more about why they\u2019re so important, and how they put Ergo head and shoulders above the competition. eUTxO | Based on the UTXO model of Bitcoin, similar extended-UTXO model as Cardano, allowing interoperability. NiPoPoWs | Verify proof of work without downloading the headers. Enables light-clients during in places with poor internet - and light mining (not having to download the entire chain)","title":"Features"},{"location":"About/faq/#dapps","text":"Ergo already has several functional decentralised applications | sigmaverse.io ErgoMixer | the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space . SigmaUSD | DAI-like Stablecoin - without liquidations. AuctionHouse | Working NFT marketplace. Oracle-Pools | More efficient and programmable than using multiple single oracle data points such as in Chainlink\u2019s oracle design. We build hierarchies of confidence using oracle pools and pools of oracle pools in Ergo. It\u2019s faster, cheaper, and more beneficial to the end-user.","title":"dApps"},{"location":"About/faq/#in-development","text":"ErgoDex | Decentralised exchange that runs ontop ADA & ERG. ErgoFund | Crowdfunding on Ergo","title":"In-Development"},{"location":"About/faq/#use-cases","text":"Ergo is one of the most sophisticated protocols in the space with stateless clients, NiPoPoWS for light clients, and easy miner-voting on parameter changes (e.g, block size) Ergo aims to provide an efficient, secure, and easy way to implement financial contracts that will be useful and survivable in the long term. There is plenty of uniqueness in Ergo but the most significant is probably Sigma protocols. These allow a true P2P system with privacy in mind. No one at the moment is able to build a trustless LETS system, multisig with no signers disclosure, trustless payment networks or has real ring signatures that preserve zero knowledge. Local Exchange Trading System - a local mutual credit association which members are allowed to create common credit money individually, with all the deals in the system written into a common ledger. To the best of our knowledge, this is the first implementation of such kind of community currency on top of a blockchain. LETS can be thought of as a mechanism to facilitate the velocity of trade, goods, and services out-with the existing monetary system, allowing us to create sustainable local economies. Smart contracts without gas fees. Ergo\u2019s native programming language \u2014 aka ErgoScript \u2014 enables the development of Turing complete contracts that completely bypass the need for any gas fee while providing other peripheral benefits such as estimation of script complexity before execution, a facet that helps in the active prevention of DoS attacks. Ergo.Meta - a unified set of design patterns for off-chain and sidechain solutions ErgoScript : a new advanced transactional language built from scratch by the team. Tutorials are available on the website /docs/AdvancedErgoScriptTutorial.pdf. It is a more advanced scripting language than Bitcoin while maintaining security and not introducing blockchain bloat problems. Scripting language in itself is non-Turing complete but applications ran on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper https://arxiv.org/pdf/1806.10116v1.pdf. Rigorous research and scientific approach : Ergo is based on original research, published at known peer-reviewed conferences. A list of scientific papers is available at here , but Ergo is not limited by research and it also implements other novel scientific ideas. Trustless Light Clients with Minimal Resource Requirements: Ergo block header supports NiPoPoWs that enable synchronizing network by downloading < 1Mb of data. This is further made possible by the fact Ergo state is authenticated as detailed in this paper from 2017 New Economic Model : Key feature of the new model is miners charge users a fee for any UTXO that remains unmoved for 4 years (\u201cstorage rent fee\u201d). This accomplishes stable mining revenue to secure the network, prevents \u201cstate bloat\u201d and enables a short release schedule \u2013 Ergo emission fully completes in just 8 years. Details in this paper Mined from Zero via PoW with no ICO or Pre-mine . It is about a hope to achieve a fair distribution of Ergs as possible to enhance decentralization. Decentralization First : Core commitment of Development team and community. Top item in \u201cErgo Vision\u201d section of white paper. Many of the above features\u2019 main purpose is to achieve this goal. Resiliency and Survivability : Decentralization First is to accomplish this goal. Ergo should be alive and operational for an indefinite amount of time and Contractual Money contracts on Ergo should be able to survive for at least the length of a person\u2019s lifetime despite a changing external environment. Privacy : Privacy is optional in Ergo, but it still beats a lot of privacy coins by default. You can actually put XMR on top, but Ergo itself can achieve privacy of early Monero if there are enough users of the mixers. Actually, it can be far better, as no inference scenarios are possible as described in this paper . Related: ErgoMixer Other : Ergo offers anyone the ability to issue their own tokens (non-native tokens) on the platform and leverage off its security and decentralization. Advanced on-chain governance is built with miners being able to vote on a number of parameters including simple items like block size \u2013 gradual changes only to ensure stability. Ergo follows a soft-forkability approach --- if an overwhelming majority of the network accepts a new feature, it is activated, however, old nodes which do not upgrade continue to operate normally and just skip over this feature validation. Thus disruptive hard forks should not be required in Ergo. Ergo mining will always be stable, unlike Bitcoin and other PoW currencies, in which mining may become unstable after the emission period. To achieve survivability, Ergo provides economic improvements in addition to the technical ones, most central of which is a storage fee component which plays an important role for Ergo\u2018s stability.","title":"Use cases"},{"location":"About/faq/#scalability","text":"The blocks in the Ergo Network are aimed to be produced at an interval of approx. 2 minutes. TPS itself doesn't matter much for Ergo in the long run since it has smart contracts in which you can chain hundreds of transactions within one. Ergo\u2019s solutions to transaction congestion are as follows: L0: A lot of efficiency improvements in the node have been completed starting from v4.0.8, 20-50x gains are still possible here. Quick bootstrapping using NiPoPoWs proofs and UTXO set snapshots are also planned L1: Ergo has an extension section in its code that allows the implementation of a wide variety of scaling solutions such as Sharding, Hydra, or BitcoinNG-style macroblocks. This even lets us do generic sidechains with velvet or soft forks. L2 (off-chain) - Ergo should be compatible with the Lightning Network, Rainbow Network, and many more. The implementation here will depend on the needs of the applications being built on Ergo. Ergo has stateless clients, NiPoPoWs - can put full nodes on Raspberry Pi's, make ultra-efficient SPV clients and other means to survive in the long-term even under the load. Storage rent helps to prevent spam & dust and stabilize mining income. Other benefits from having the storage rent fee include prevention of \"state bloat\", the building of an economy around the state (users must pay to keep unspent boxes in miners' memory for the long\u2010term) and a gradual return of any lost coins back into circulation.","title":"Scalability"},{"location":"About/faq/#partnerships-business-development","text":"Yoroi dApp Connector | In Testing! Waves Partners with Ergo to foster Interoperability solutions | In Testing! Cryptocurrencycheckout: Supports both SigUSD and Ergo. Roadmap","title":"Partnerships / Business Development"},{"location":"About/format/","text":"Format Tutorials learning-oriented. Tutorial are lessons that take the reader by the hand through a series of steps to complete a project. Most important part of documentation, rarely done well. What matters? Learn by doing. Getting Started Inspiring Confidence Repeatability Immediate sense of achievement Concreteness, not abstraction Minimum necessary explanation No distractions How To Guides problem-oriented. Guides that take the user through a series of steps to achieve a common problem. What matters? A series of steps A focus on the goal Addressing a specific question A little flexibility Practical usability Good naming Explanations Understanding-orientated Explanations that clarify and illuminate a particular topic What Matters? Giving context Explaning why Multiple examples, alternative approaches Making Connections No instruction or technical description References Technical descriptions and how to operate it. What Matters? Structure Consistency Description Accuracy","title":"About ErgoDocs"},{"location":"About/format/#format","text":"","title":"Format"},{"location":"About/format/#tutorials","text":"learning-oriented. Tutorial are lessons that take the reader by the hand through a series of steps to complete a project. Most important part of documentation, rarely done well.","title":"Tutorials"},{"location":"About/format/#what-matters","text":"Learn by doing. Getting Started Inspiring Confidence Repeatability Immediate sense of achievement Concreteness, not abstraction Minimum necessary explanation No distractions","title":"What matters?"},{"location":"About/format/#how-to-guides","text":"problem-oriented. Guides that take the user through a series of steps to achieve a common problem.","title":"How To Guides"},{"location":"About/format/#what-matters_1","text":"A series of steps A focus on the goal Addressing a specific question A little flexibility Practical usability Good naming","title":"What matters?"},{"location":"About/format/#explanations","text":"Understanding-orientated Explanations that clarify and illuminate a particular topic","title":"Explanations"},{"location":"About/format/#what-matters_2","text":"Giving context Explaning why Multiple examples, alternative approaches Making Connections No instruction or technical description","title":"What Matters?"},{"location":"About/format/#references","text":"Technical descriptions and how to operate it.","title":"References"},{"location":"About/format/#what-matters_3","text":"Structure Consistency Description Accuracy","title":"What Matters?"},{"location":"dev/Integration/guide/","text":"This guide is for helping developers integrating Ergo into exchanges, wallets, pools wallets etc. Introduction Some quick facts useful for an integration: like Bitcoin, a transaction in Ergo has multiple inputs and outputs. Unspent outputs are single-use entities. However, Ergo is built from scratch thus scripts and transaction format are different. like in Bitcoin, there are some standard scripts in Ergo associated with addresses, e.g. P2PK addresses. There's an article on address scheme available: https://ergoplatform.org/en/blog/2019_07_24_ergo_address/ Ergo has inbuilt wallet API which is enough for most use-cases. API has Swagger interface (on 127.0.0.1:9053 by default in the mainnet, 127.0.0.1:9052 in the testnet) with descriptions and examples for API methods. How to set up a node: https://ergoplatform.org/en/blog/2019_12_02_how_to_setup/, https://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node Please run the node with -Xmx3G flag, e.g. java -jar -Xmx3G ergo-4.0.4.jar --mainnet -c mainnet.conf Node Wallet Node wallet has UI available @ 127.0.0.1:9053/panel by default on the mainnet (127.0.0.1:9052/panel on the testnet). Main methods: /wallet/init and /wallet/restore to create a wallet (and a secret mnemonic) and restore wallet from mnemonic /wallet/unlock to unlock the wallet (it is unlocked after init but locked after restart) /wallet/lock to lock the wallet /wallet/payment/send to send a simple payment /wallet/status to get wallet status /wallet/deriveNextKey to derive a new key according to EIP-3 (BIP 44 implementation for Ergo) /wallet/balances to get wallet balance (for all the addresses) /wallet/transactions to get wallet transactions (for all the addresses) Doing an external wallet If you are going to do wallet logic externally, you can do it with a library and also the block explorer. Please note, you need to consider mempool transactions to avoid double-spending generation . Available libraries are: ergo-wallet made in Java (sources are in Ergo node repository ) sigma-rust in Rust with WASM bindings for JavaScript/TypeScript ergo-ts in TypeScript ergo-golang in Go (still raw) Offline Signing Transaction assembly and offline signing demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/c040f244865a451b94df01032c7a3456 Transaction assembly and signing in Rust https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/tx_builder.rs#L552-L592 https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/signing.rs#L133-L161 Transaction assembly and signing in JavaScript https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/bindings/ergo-lib-wasm/tests/test_transaction.js#L9-L69 Composing transaction outside the node To get unspent UTXOs for some address, please use transactions/boxes/byAddress/unspent Explorer API method: https://api.ergoplatform.com/transactions/boxes/byAddress/unspent/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M . You need to exclude UTXOs spent in the mempool! Use /transactions/unconfirmed/byAddress Explorer API method for that: https://api.ergoplatform.com/transactions/unconfirmed/byAddress/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M Broadcasting transaction To broadcast a transaction made outside the node, the easiest way is to serialize it into JSON, in Java it could be like: Json json = JsonCodecsWrapper.ergoLikeTransactionEncoder().apply(tx); System.out.println(json.toString()); and then send this json via POST request to the public explorer https://api.ergoplatform.com/api/v0/transactions/send , your private explorer or a node with open API (POST to http://{node_ip}:9053/transactions ) Address generation Secret seed and derived addresses generation demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/70dcfa841dfb504721f09c911b0fc53d Own Testnet and Explorer Infrastructure You can use ergo-bootstrap to install Explorer backend easily (and so not rely on public ones). To start your own testnet, use the following node: ergo { networkType = \"testnet\" node { mining = true offlineGeneration = true useExternalMiner = false } } scorex { network { bindAddress = \"0.0.0.0:9020\" nodeName = \"ergo-testnet-4.0.4\" knownPeers = [] } restApi { # Hex-encoded Blake2b256 hash of an API key. Should be 64-chars long Base16 string. # Below is hash corresponding to API_KEY = \"hello\" (with no quotes) apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } } and then the node will CPU-mine its own chain. Any suggestions for improvements are welcomed! Please send them to team@ergoplatform.org or #development channel in Discord https://discord.gg/kj7s7nb","title":"Integration"},{"location":"dev/Integration/guide/#introduction","text":"Some quick facts useful for an integration: like Bitcoin, a transaction in Ergo has multiple inputs and outputs. Unspent outputs are single-use entities. However, Ergo is built from scratch thus scripts and transaction format are different. like in Bitcoin, there are some standard scripts in Ergo associated with addresses, e.g. P2PK addresses. There's an article on address scheme available: https://ergoplatform.org/en/blog/2019_07_24_ergo_address/ Ergo has inbuilt wallet API which is enough for most use-cases. API has Swagger interface (on 127.0.0.1:9053 by default in the mainnet, 127.0.0.1:9052 in the testnet) with descriptions and examples for API methods. How to set up a node: https://ergoplatform.org/en/blog/2019_12_02_how_to_setup/, https://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node Please run the node with -Xmx3G flag, e.g. java -jar -Xmx3G ergo-4.0.4.jar --mainnet -c mainnet.conf","title":"Introduction"},{"location":"dev/Integration/guide/#node-wallet","text":"Node wallet has UI available @ 127.0.0.1:9053/panel by default on the mainnet (127.0.0.1:9052/panel on the testnet). Main methods: /wallet/init and /wallet/restore to create a wallet (and a secret mnemonic) and restore wallet from mnemonic /wallet/unlock to unlock the wallet (it is unlocked after init but locked after restart) /wallet/lock to lock the wallet /wallet/payment/send to send a simple payment /wallet/status to get wallet status /wallet/deriveNextKey to derive a new key according to EIP-3 (BIP 44 implementation for Ergo) /wallet/balances to get wallet balance (for all the addresses) /wallet/transactions to get wallet transactions (for all the addresses)","title":"Node Wallet"},{"location":"dev/Integration/guide/#doing-an-external-wallet","text":"If you are going to do wallet logic externally, you can do it with a library and also the block explorer. Please note, you need to consider mempool transactions to avoid double-spending generation . Available libraries are: ergo-wallet made in Java (sources are in Ergo node repository ) sigma-rust in Rust with WASM bindings for JavaScript/TypeScript ergo-ts in TypeScript ergo-golang in Go (still raw)","title":"Doing an external wallet"},{"location":"dev/Integration/guide/#offline-signing","text":"Transaction assembly and offline signing demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/c040f244865a451b94df01032c7a3456 Transaction assembly and signing in Rust https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/tx_builder.rs#L552-L592 https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/ergo-lib/src/wallet/signing.rs#L133-L161 Transaction assembly and signing in JavaScript https://github.com/ergoplatform/sigma-rust/blob/d70bea875792c4e383bfdd71754338695bdb37f8/bindings/ergo-lib-wasm/tests/test_transaction.js#L9-L69","title":"Offline Signing"},{"location":"dev/Integration/guide/#composing-transaction-outside-the-node","text":"To get unspent UTXOs for some address, please use transactions/boxes/byAddress/unspent Explorer API method: https://api.ergoplatform.com/transactions/boxes/byAddress/unspent/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M . You need to exclude UTXOs spent in the mempool! Use /transactions/unconfirmed/byAddress Explorer API method for that: https://api.ergoplatform.com/transactions/unconfirmed/byAddress/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M","title":"Composing transaction outside the node"},{"location":"dev/Integration/guide/#broadcasting-transaction","text":"To broadcast a transaction made outside the node, the easiest way is to serialize it into JSON, in Java it could be like: Json json = JsonCodecsWrapper.ergoLikeTransactionEncoder().apply(tx); System.out.println(json.toString()); and then send this json via POST request to the public explorer https://api.ergoplatform.com/api/v0/transactions/send , your private explorer or a node with open API (POST to http://{node_ip}:9053/transactions )","title":"Broadcasting transaction"},{"location":"dev/Integration/guide/#address-generation","text":"Secret seed and derived addresses generation demo using ergo-wallet and Java is provided in https://gist.github.com/kushti/70dcfa841dfb504721f09c911b0fc53d","title":"Address generation"},{"location":"dev/Integration/guide/#own-testnet-and-explorer-infrastructure","text":"You can use ergo-bootstrap to install Explorer backend easily (and so not rely on public ones). To start your own testnet, use the following node: ergo { networkType = \"testnet\" node { mining = true offlineGeneration = true useExternalMiner = false } } scorex { network { bindAddress = \"0.0.0.0:9020\" nodeName = \"ergo-testnet-4.0.4\" knownPeers = [] } restApi { # Hex-encoded Blake2b256 hash of an API key. Should be 64-chars long Base16 string. # Below is hash corresponding to API_KEY = \"hello\" (with no quotes) apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } } and then the node will CPU-mine its own chain. Any suggestions for improvements are welcomed! Please send them to team@ergoplatform.org or #development channel in Discord https://discord.gg/kj7s7nb","title":"Own Testnet and Explorer Infrastructure"},{"location":"dev/Languages/csharp/","text":"C Tutorials How-to Guides Ergo with C# 101 Explanations References","title":"C#"},{"location":"dev/Languages/csharp/#c","text":"","title":"C"},{"location":"dev/Languages/csharp/#tutorials","text":"","title":"Tutorials"},{"location":"dev/Languages/csharp/#how-to-guides","text":"Ergo with C# 101","title":"How-to Guides"},{"location":"dev/Languages/csharp/#explanations","text":"","title":"Explanations"},{"location":"dev/Languages/csharp/#references","text":"","title":"References"},{"location":"dev/Languages/java/","text":"Tutorials See AppKit","title":"Java"},{"location":"dev/Languages/java/#tutorials","text":"See AppKit","title":"Tutorials"},{"location":"dev/Languages/rust/","text":"Rust sigma-rust is an alternative and simple implementation of ErgoTree interpreter and transaction building tools. The goal for the Rust version is to be on par with Scala version feature-wise. Now Rust version is still significantly behind. Also the goal for the Rust version is to have bindings for web, iOS and Android. The Scala version will continue to be the primary choice for JVM ecosystem with Rust version covering the rest. Contributing A list of \" good first \" issues is available on GitHub - @greenhat on Discord is ready to assist anyone who is interested. The sigma-rust GitHub repo is here . There is an issues tab with labeled tasks anyone can pick up. If you are working on something, leave a comment so others know. - contributing References This document describes the high-level architecture of ErgoScript compiler and ErgoTree interpreter. Rust port of AVL tree from scrypto package. Ergo Utilities | simplify writing off-chain code in Rust.","title":"Rust"},{"location":"dev/Languages/rust/#rust","text":"sigma-rust is an alternative and simple implementation of ErgoTree interpreter and transaction building tools. The goal for the Rust version is to be on par with Scala version feature-wise. Now Rust version is still significantly behind. Also the goal for the Rust version is to have bindings for web, iOS and Android. The Scala version will continue to be the primary choice for JVM ecosystem with Rust version covering the rest.","title":"Rust"},{"location":"dev/Languages/rust/#contributing","text":"A list of \" good first \" issues is available on GitHub - @greenhat on Discord is ready to assist anyone who is interested. The sigma-rust GitHub repo is here . There is an issues tab with labeled tasks anyone can pick up. If you are working on something, leave a comment so others know. - contributing","title":"Contributing"},{"location":"dev/Languages/rust/#references","text":"This document describes the high-level architecture of ErgoScript compiler and ErgoTree interpreter. Rust port of AVL tree from scrypto package. Ergo Utilities | simplify writing off-chain code in Rust.","title":"References"},{"location":"dev/Languages/scala/","text":"Scala Ergo's primary language is Scala. Similarily, the scripting language used by ergo - ergoscript , is based on Scala. Learn Tutorials, How to Guides and Explanations found in the relevent sections - See ErgoScript - See AppKit References Sigmastate-Interpreter | The Sigmastate-Interpreter is a ErgoScript compiler and ErgoTree Interpreter implementation for Ergo blockchain's Sigma Language For development of Ergo applications using JVM languages a better alternative is to use Appkit . ScoreX , the open-source, modular blockchain & cryptocurrency framework. Scrypto | Scrypto is an open source cryptographic toolkit designed to make it easier and safer for developers to use cryptography in their applications based on Scorex This library is used internally in Ergo Node and ergo-wallet , the public interfaces are subject to change.","title":"Scala"},{"location":"dev/Languages/scala/#scala","text":"Ergo's primary language is Scala. Similarily, the scripting language used by ergo - ergoscript , is based on Scala.","title":"Scala"},{"location":"dev/Languages/scala/#learn","text":"Tutorials, How to Guides and Explanations found in the relevent sections - See ErgoScript - See AppKit","title":"Learn"},{"location":"dev/Languages/scala/#references","text":"Sigmastate-Interpreter | The Sigmastate-Interpreter is a ErgoScript compiler and ErgoTree Interpreter implementation for Ergo blockchain's Sigma Language For development of Ergo applications using JVM languages a better alternative is to use Appkit . ScoreX , the open-source, modular blockchain & cryptocurrency framework. Scrypto | Scrypto is an open source cryptographic toolkit designed to make it easier and safer for developers to use cryptography in their applications based on Scorex This library is used internally in Ergo Node and ergo-wallet , the public interfaces are subject to change.","title":"References"},{"location":"dev/ergo/a/","text":"diff readjustment leads to timewarp attacks etc. Ergo is already using epoch length of ~1.5 days (with normal block rate), not Bitcoin's 2 weeks. However, more epochs considered, but retargeting function is non-linear also, so may adjust sooner than linear function in certain popular scenarios. coin hopping was one of the motivations there Our algo will adjust slowly yes, but it is also preventing from adversarial hopping.","title":"A"},{"location":"dev/ergo/apps/","text":"Applications Check out sigmaverse.io - your portal to the Ergo Universe Live dApps ErgoDex Beta live on Ergo ErgoLabs EIP-0014: Decentalized Exchange Contracts Single-Chain Swap Contracts (DEX basis) by Alex Chepurnoy SigmaUSD sigmausd.io , The first UTxO-based stable coin - an instantiation of the AgeUSD protocol . Its economic model designed in partnership between IOHK, Ergo, and Emurgo maintains the conservative settings for collateral reserves and avoids the need for liquidations. Along with that, it supports a fully decentralised stablecoin emission setup. The UI for the front-end is available at anon-real/sigma-usd Ergo Summit 2021 - The IOHK Perspective - Designing the AgeUSD StableCoin Overview Video (with diagrams) Building Ergo: How the AgeUSD stablecoin works Dexy Dexy: USD Simplest Stablecoin ErgoMixer Due to secret generation under the hood, must be run as a local application. ErgoMixer is the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space. Technical Slides: ZeroJoin: Combining Zerocoin and Coinjoin Video tutorial ErgoAuctions Ergo Auction House lets you buy and sell collectible tokens, art and much more. Source code v2 contracts Raffle ErgoRaffle GitHub in Development ErgoFund In development Ergo Crowdfunding CLI | Command-line tool which enables participating and interacting with crowdfunding campaigns on Ergo Scanner ZK Treasury | a tool for joint spendings with on-chain privacy Server Client 'A Collective Spending Appproach' ErgoProfitSharingDapp This service will provide a way for dapps to distribute gains among dapps' token holders. The first user of this service will be the ErgoMixer. Ergomixer's income (in ERG and other tokens) is currently received by its creator, aka 'anon2020s', since it has only one stakeholder at the moment. He has announced that he is willing to create and sell some tokens in the near future to obtain more stakeholders; let's call this token MIX. later, anyone having the MIX tokens can stake these tokens in the Profit Sharing contract and obtain the mixer's incomes proportional to their staked tokens. So, it is NOT a way to stake ERG at first. But, it CAN BE USED in the future in some creative services to provide ERG-staking. A solution for staking Ergo Profit Sharing dApp LETS Development starting soon. Tooling Zero-Knowledge In development Oracles v2 contracts in review. When external oracle data is posted on-chain, it needs to be encoded in a very precise way within a transaction. Furthermore, oracle pools have a bunch of different moving parts which require transactions to be issued to move between the different stages of the pool protocol. Oracle Core creates all of the complex transactions which posts the data on-chain & runs the oracle pool protocol on-chain (such as averaging datapoints). This comes bundled with Oracle Pool Bootstrap and a Connector Library . The ada-usd-oracle source can be seen here. Currently only the erg-usd-oracle is live as seen in the Oracle Pool List See this overview by Robert Kornacki. Resources eth/usd connector Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. Learn about data inputs and the truly novel innovations they bring to UTXO-based Blockchains Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. See also a forum topic with example v2 Oracle pool 2.0 contracts finalized (for initial draft). Tests for oracle pool 2.0 Articles Chainlink Oracles vs. Ergo Oracle Pools Oracle Pools - A New Oracle Model First steps towards interoperability with Cardano oracles Ergo Blockchain: Oracle Pool Governance Update The role of Ergo Oracles Misc ErgoFaucet.org Various utilities are listed on ergosites.github.io ergo.watch | Git ERGOHACK ERGOHACK I ErgoRaffle Ergo Index Fund Smart Pools Sigma Stamp Ergo Charts Simpler Joint Spending Tool ERGOHACK II ErgoLend Minotaur Wallet Ergopad Ergo Subpooling HYPO10USE: QUIDGAMES Ergo Audio Many more possible! Bonds based on Ergo (or the \u201cYield protocol\u201d) An ICO Example On Top Of Ergo A Local Exchange Trading System On Top Of Ergo A Trustless Local Exchange Trading System (E)mail Client for Limited or Blocked Internet LETS start the discussion ErgoFans | Decentralised content producer platform | Patreon/Onlyfans ErgoGigs | Decentralised gigs! (Fiverr) ErgoEarn | earn for learning (Coinbase Earn) ErgoStats | on-chain analysis (glassnode)","title":"Applications"},{"location":"dev/ergo/apps/#applications","text":"Check out sigmaverse.io - your portal to the Ergo Universe","title":"Applications"},{"location":"dev/ergo/apps/#live-dapps","text":"","title":"Live dApps"},{"location":"dev/ergo/apps/#ergodex","text":"Beta live on Ergo ErgoLabs EIP-0014: Decentalized Exchange Contracts Single-Chain Swap Contracts (DEX basis) by Alex Chepurnoy","title":"ErgoDex"},{"location":"dev/ergo/apps/#sigmausd","text":"sigmausd.io , The first UTxO-based stable coin - an instantiation of the AgeUSD protocol . Its economic model designed in partnership between IOHK, Ergo, and Emurgo maintains the conservative settings for collateral reserves and avoids the need for liquidations. Along with that, it supports a fully decentralised stablecoin emission setup. The UI for the front-end is available at anon-real/sigma-usd Ergo Summit 2021 - The IOHK Perspective - Designing the AgeUSD StableCoin Overview Video (with diagrams) Building Ergo: How the AgeUSD stablecoin works Dexy Dexy: USD Simplest Stablecoin","title":"SigmaUSD"},{"location":"dev/ergo/apps/#ergomixer","text":"Due to secret generation under the hood, must be run as a local application. ErgoMixer is the first working non-custodial, programmable, non-interactive mixer in the cryptocurrency space. Technical Slides: ZeroJoin: Combining Zerocoin and Coinjoin Video tutorial","title":"ErgoMixer"},{"location":"dev/ergo/apps/#ergoauctions","text":"Ergo Auction House lets you buy and sell collectible tokens, art and much more. Source code v2 contracts","title":"ErgoAuctions"},{"location":"dev/ergo/apps/#raffle","text":"ErgoRaffle GitHub","title":"Raffle"},{"location":"dev/ergo/apps/#in-development","text":"","title":"in Development"},{"location":"dev/ergo/apps/#ergofund","text":"In development Ergo Crowdfunding CLI | Command-line tool which enables participating and interacting with crowdfunding campaigns on Ergo Scanner ZK Treasury | a tool for joint spendings with on-chain privacy Server Client 'A Collective Spending Appproach'","title":"ErgoFund"},{"location":"dev/ergo/apps/#ergoprofitsharingdapp","text":"This service will provide a way for dapps to distribute gains among dapps' token holders. The first user of this service will be the ErgoMixer. Ergomixer's income (in ERG and other tokens) is currently received by its creator, aka 'anon2020s', since it has only one stakeholder at the moment. He has announced that he is willing to create and sell some tokens in the near future to obtain more stakeholders; let's call this token MIX. later, anyone having the MIX tokens can stake these tokens in the Profit Sharing contract and obtain the mixer's incomes proportional to their staked tokens. So, it is NOT a way to stake ERG at first. But, it CAN BE USED in the future in some creative services to provide ERG-staking. A solution for staking Ergo Profit Sharing dApp","title":"ErgoProfitSharingDapp"},{"location":"dev/ergo/apps/#lets","text":"Development starting soon.","title":"LETS"},{"location":"dev/ergo/apps/#tooling","text":"","title":"Tooling"},{"location":"dev/ergo/apps/#zero-knowledge","text":"In development","title":"Zero-Knowledge"},{"location":"dev/ergo/apps/#oracles","text":"v2 contracts in review. When external oracle data is posted on-chain, it needs to be encoded in a very precise way within a transaction. Furthermore, oracle pools have a bunch of different moving parts which require transactions to be issued to move between the different stages of the pool protocol. Oracle Core creates all of the complex transactions which posts the data on-chain & runs the oracle pool protocol on-chain (such as averaging datapoints). This comes bundled with Oracle Pool Bootstrap and a Connector Library . The ada-usd-oracle source can be seen here. Currently only the erg-usd-oracle is live as seen in the Oracle Pool List See this overview by Robert Kornacki. Resources eth/usd connector Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. Learn about data inputs and the truly novel innovations they bring to UTXO-based Blockchains Ergo oracles | simple command-line tool to launch oracles. Inbuilt implementations for USD/ERG, EUR/ERG, BTC/ERG, AUG/ERG (gold) prices delivery. See also a forum topic with example v2 Oracle pool 2.0 contracts finalized (for initial draft). Tests for oracle pool 2.0 Articles Chainlink Oracles vs. Ergo Oracle Pools Oracle Pools - A New Oracle Model First steps towards interoperability with Cardano oracles Ergo Blockchain: Oracle Pool Governance Update The role of Ergo Oracles","title":"Oracles"},{"location":"dev/ergo/apps/#misc","text":"ErgoFaucet.org Various utilities are listed on ergosites.github.io ergo.watch | Git","title":"Misc"},{"location":"dev/ergo/apps/#ergohack","text":"ERGOHACK I ErgoRaffle Ergo Index Fund Smart Pools Sigma Stamp Ergo Charts Simpler Joint Spending Tool ERGOHACK II ErgoLend Minotaur Wallet Ergopad Ergo Subpooling HYPO10USE: QUIDGAMES Ergo Audio Many more possible! Bonds based on Ergo (or the \u201cYield protocol\u201d) An ICO Example On Top Of Ergo A Local Exchange Trading System On Top Of Ergo A Trustless Local Exchange Trading System (E)mail Client for Limited or Blocked Internet LETS start the discussion ErgoFans | Decentralised content producer platform | Patreon/Onlyfans ErgoGigs | Decentralised gigs! (Fiverr) ErgoEarn | earn for learning (Coinbase Earn) ErgoStats | on-chain analysis (glassnode)","title":"ERGOHACK"},{"location":"dev/ergo/eutxo/","text":"UTXO has many advantages over the account-based model used by Ethereum. It provides superior: Privacy, as UTXOs are one-time objects making it possible to formalise privacy leaks. Scalability, as parallel transaction processing is more straightforward. UTXOs are also more friendly to known stateless client solutions. Interoperability, as off-chain and sidechain protocols. One-time objects are simpler to work with from an off-chain point of view. Transaction Cost Predictability, where the only on-chain action is validating the smart contracts. As a result, the transaction cost is significantly lower and most importantly, the transaction cost is predictable, eliminating the need for \u2018gas.\u2019 ErgoScript is built considering Bitcoin\u2019s security and privacy and the purpose of making all kinds of complex financial contracts accessible to everyone. However Bitcoin\u2019s design doesn\u2019t allow loops, and building complex smart contracts on top of it isn\u2019t possible. ErgoScript allows for self-replication, therefore it can be used to create Turing-Complete processes in a blockchain. Another approach to creating smart contracts in blockchain is the Account-Based model, like on Ethereum. Ethereum\u2019s design facilitates smart contract opeld coins, so the unspent transaction output (UTXO) show us which private key holds which coiration by processing smart contracts as accounts. In Bitcoin, there aren\u2019t accounts that hons. Coins are in a set of addresses represented with a single UTXO. It\u2019s also easier to include privacy schemes in this model than the Account Based model. Therefore, Ergo developed Bitcoin\u2019s UTXO model to the extended UTXO model by introducing readable UTXO design. This enables smart contracts to use UTXOs as data inputs without changing them. Therefore nodes are checking transactions, rather than balances. In comparison, in Ethereum\u2019s Account model, nodes do this by checking all accounts to validate the system. Side by side, the UTXO model is more scalable but it\u2019s also more complicated to build User Interface tools. The account model provides easier access to developers but codes are heavier on the blockchain which can lead to network congestion. Furthermore, UTXO allows for parallel computation and it\u2019s easier to compute atomic swaps in a non-custodial manner. https://ergoplatform.org/en/blog/2021-10-04-off-chain-logic-and-eutxo/ https://ergoplatform.org/en/blog/2021-09-26-the-utxo-alliance/","title":"Eutxo"},{"location":"dev/ergo/multi/","text":"Multi-Stage Contracts So you\u2019ve heard about smart contracts, but what are multi-stage contracts? Multi-stage contracts refer to smart contracts that are operating on a stateful level. Because Ergo uses the UTXO model, it is possible to process parallelized actions on top of smart contracts. For a blockchain to contain smart contracts, it should have loops. These loops can later refer to themselves and check whether an operation is working or not. Bitcoin\u2019s UTXO design is very primitive, and it doesn\u2019t contain Turing-complete smart contracts. Ethereum has this capability, but it\u2019s a primitive version of a Turing-complete language. Ergo Blockchain provides a different approach to multi-stage contracts, empowered by the extended UTXO model. Permitting a lighter network and broader use cases. Multi-Stage Contracts","title":"Multi-Stage Contracts"},{"location":"dev/ergo/multi/#multi-stage-contracts","text":"So you\u2019ve heard about smart contracts, but what are multi-stage contracts? Multi-stage contracts refer to smart contracts that are operating on a stateful level. Because Ergo uses the UTXO model, it is possible to process parallelized actions on top of smart contracts. For a blockchain to contain smart contracts, it should have loops. These loops can later refer to themselves and check whether an operation is working or not. Bitcoin\u2019s UTXO design is very primitive, and it doesn\u2019t contain Turing-complete smart contracts. Ethereum has this capability, but it\u2019s a primitive version of a Turing-complete language. Ergo Blockchain provides a different approach to multi-stage contracts, empowered by the extended UTXO model. Permitting a lighter network and broader use cases. Multi-Stage Contracts","title":"Multi-Stage Contracts"},{"location":"dev/ergo/protocol/","text":"The Ergo Protocol Ergo is a Resilient Platform for Contractual Money . Designed with the main focus to provide an efficient, secure, and easy way to implement financial contracts. Ergo builds advanced cryptographic features and radically new DeFi functionality on the rock-solid foundations laid by a decade of blockchain theory and development. It complements tried and tested principles with the latest peer-reviewed academic research into cryptography, consensus models, and digital currencies. With a research-driven but practical development model, Ergo has prioritized useful features without compromising on security. Extended support of light nodes makes Ergo friendly for end-users, allowing them to run contracts on common devices such as mobile phones without centralized intermediaries. To be useful in the long-term, we use widely-researched solutions with high-security guarantees while also preventing performance degradation over time with a new economic model. All cryptocurrencies rely on contributions from the scientific research community. Ergo brings it in its core! The Manifesto Cryptocurrency should provide tools to enrich ordinary people. The small businesses that are getting not much above making ends meet, not depersonalized big financial capital. This is what inspired me. This is my dream. Proof-of-Work Ergo uses Autolykos as the underlying PoW algorithm. Autolykos v2 (the current version of PoW) is a memory-hard ASIC-resistant PoW algorithm oriented towards GPUs. eUTXO The platform's smart contracts are built on the extended UTXO (eUTXO) model with a unique data input concept, offering a radically different approach to provide robust, flexible cryptography and easy, safe scripting on privacy-centric Sigma Protocols (non-interactive zero-knowledge proofs). Ergo is a UTXO based blockchain with Proof-of-Work consensus. In this aspect, it is similar to Bitcoin. Ergo uses standard Elliptic Curve Cryptography with the same curve as Bitcoin ( Secp256k1 ). Unlike Bitcoin and similar to Cardano, Ergo uses a so-called \"extended-UTXO model,\" which implies UTXOs with the ability to contain arbitrary data and sophisticated scripts. Due to this, Ergo supports advanced financial contracts similar to those in Ethereum's account-based model. ErgoScript Ergo provides advanced programming abilities for financial contracts using a high-level language called ErgoScript. As a simple example, the below script allows only Alice to spend a box before a certain height and only Bob to spend the box after that. if (HEIGHT < 100000) alicePubKey else bobPubKey The scripting language in itself is non-Turing complete, but applications run on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper . Sigma Protocols The cryptographic part of ErgoScript is based on Sigma Protocols and naturally supports threshold m-of-n signatures, ring signatures, and more. Keeping all this in mind, we expect ErgoScript and Ergo's design to be uniquely useful as Contractual Money with countless possible applications. NIPoPoWs Non-Interactive Proofs of Proof of Work ( NIPoPoWs ) are essential for two reasons: Light Clients and Side Chains. These two components are essential for clients and nodes to facilitate easier onboarding to the blockchain. A decentralized network is inherently inefficient because of the randomness mechanism in a synchronous network; that is to say, every time a transaction (TX) occurs on the network, a couple of random nodes must process the TX to prove and secure its reliability. When put into perspective, that is an enormous task on a global scale. There can be billions of transactions, and it is plausible that many of those are from contributors operating with low bandwidth. Storage Rent Another unique feature of Ergo is the concept of storage-rent, which is the ability of miners to take out a small amount of Ergs from boxes that have remained unspent for four or more years (the box is spent, and a new box is created with the lower value). This allows Ergo to avoid long-term bloat of the UTXO set.","title":"The Ergo Protocol"},{"location":"dev/ergo/protocol/#the-ergo-protocol","text":"Ergo is a Resilient Platform for Contractual Money . Designed with the main focus to provide an efficient, secure, and easy way to implement financial contracts. Ergo builds advanced cryptographic features and radically new DeFi functionality on the rock-solid foundations laid by a decade of blockchain theory and development. It complements tried and tested principles with the latest peer-reviewed academic research into cryptography, consensus models, and digital currencies. With a research-driven but practical development model, Ergo has prioritized useful features without compromising on security. Extended support of light nodes makes Ergo friendly for end-users, allowing them to run contracts on common devices such as mobile phones without centralized intermediaries. To be useful in the long-term, we use widely-researched solutions with high-security guarantees while also preventing performance degradation over time with a new economic model. All cryptocurrencies rely on contributions from the scientific research community. Ergo brings it in its core!","title":"The Ergo Protocol"},{"location":"dev/ergo/protocol/#the-manifesto","text":"Cryptocurrency should provide tools to enrich ordinary people. The small businesses that are getting not much above making ends meet, not depersonalized big financial capital. This is what inspired me. This is my dream.","title":"The Manifesto"},{"location":"dev/ergo/protocol/#proof-of-work","text":"Ergo uses Autolykos as the underlying PoW algorithm. Autolykos v2 (the current version of PoW) is a memory-hard ASIC-resistant PoW algorithm oriented towards GPUs.","title":"Proof-of-Work"},{"location":"dev/ergo/protocol/#eutxo","text":"The platform's smart contracts are built on the extended UTXO (eUTXO) model with a unique data input concept, offering a radically different approach to provide robust, flexible cryptography and easy, safe scripting on privacy-centric Sigma Protocols (non-interactive zero-knowledge proofs). Ergo is a UTXO based blockchain with Proof-of-Work consensus. In this aspect, it is similar to Bitcoin. Ergo uses standard Elliptic Curve Cryptography with the same curve as Bitcoin ( Secp256k1 ). Unlike Bitcoin and similar to Cardano, Ergo uses a so-called \"extended-UTXO model,\" which implies UTXOs with the ability to contain arbitrary data and sophisticated scripts. Due to this, Ergo supports advanced financial contracts similar to those in Ethereum's account-based model.","title":"eUTXO"},{"location":"dev/ergo/protocol/#ergoscript","text":"Ergo provides advanced programming abilities for financial contracts using a high-level language called ErgoScript. As a simple example, the below script allows only Alice to spend a box before a certain height and only Bob to spend the box after that. if (HEIGHT < 100000) alicePubKey else bobPubKey The scripting language in itself is non-Turing complete, but applications run on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper .","title":"ErgoScript"},{"location":"dev/ergo/protocol/#sigma-protocols","text":"The cryptographic part of ErgoScript is based on Sigma Protocols and naturally supports threshold m-of-n signatures, ring signatures, and more. Keeping all this in mind, we expect ErgoScript and Ergo's design to be uniquely useful as Contractual Money with countless possible applications.","title":"Sigma Protocols"},{"location":"dev/ergo/protocol/#nipopows","text":"Non-Interactive Proofs of Proof of Work ( NIPoPoWs ) are essential for two reasons: Light Clients and Side Chains. These two components are essential for clients and nodes to facilitate easier onboarding to the blockchain. A decentralized network is inherently inefficient because of the randomness mechanism in a synchronous network; that is to say, every time a transaction (TX) occurs on the network, a couple of random nodes must process the TX to prove and secure its reliability. When put into perspective, that is an enormous task on a global scale. There can be billions of transactions, and it is plausible that many of those are from contributors operating with low bandwidth.","title":"NIPoPoWs"},{"location":"dev/ergo/protocol/#storage-rent","text":"Another unique feature of Ergo is the concept of storage-rent, which is the ability of miners to take out a small amount of Ergs from boxes that have remained unspent for four or more years (the box is spent, and a new box is created with the lower value). This allows Ergo to avoid long-term bloat of the UTXO set.","title":"Storage Rent"},{"location":"dev/ergo/sigma/","text":"Ergo aims to provide an efficient, secure, and easy way to implement financial contracts that will be useful and survivable in the long term. There is plenty of uniqueness in Ergo but the most significant is probably Sigma protocols. These allow a true P2P system with privacy in mind. No one else at the moment is able to build a trustless LETS system, multisig with no signers disclosure, trustless payment networks or has real ring signatures that preserve zero knowledge. https://ergoplatform.org/en/blog/2020_03_16_ergo_sigma/ The overwhelming majority of successful public blockchain use\u2010cases are related to financial applications. Ergo extends Bitcoin's way of writing contracts by attaching a guard script (together with additional custom data) to every coin. For example, in addition to regular protection by some m\u2010of\u2010n signature, Ergo allows specifying the possible recipients of these coins, which may also be a contract with similar complex conditions. This \"chaining\" approach enables the implementation of secure and efficient contracts of arbitrary complexity. This, along with Ergo's focus on sustainability, makes it uniquely valuable as contractual money. Quick privacy overview in response to the top comment in the previous stickied thread. I\u2019d like to see the privacy features get talked about a bit more. Seems many have no idea about them. I've linked to some relevant Discord discussions so make sure to join first. Good practice to start with an excerpt from the Ergo Manifesto Privacy must remain an option to protect the individual. It does not have to be forced; let people make their own choices. Privacy is the ability to create barriers and erect boundaries to create a space and for the individual. It is up to each what borders and boundaries they choose to make. Civilization exists under a continuous tension between what is best for society and what is best for the individual. The only real entities in a community are individuals. All collectives, associations, and governments stem from individual participation and interaction. Ergo utilizes the eUTXO model for enhanced privacy & scalability options while also employing expressive smart contracts for DeFi applications. DarkFund0 - ZK Fund for privacy applications | sponsors new developments in regards with privacy and private DeFi - 4000 ERG up for grabs! Zero-Knowledge Proof Intro Let\u2019s say someone picks up a phone in a bar. You can prove it\u2019s yours by hiding the screen, entering the unlock code and showing the unlocked screen to the person who found it. This is a simple example of a zero-knowledge proof: you have proven you own the phone without giving away any sensitive information. In cryptography, most practical problems are associated with secrets. The most popular application lies in digital signatures, used by millions of people around the world every day. Essentially, these involve saying: \u2018This message proves I know the private key associated with this public key \u2013 but I\u2019m not revealing the private key itself\u2019. Sigma protocols ErgoScript is the language used to specify the conditions under which currency can be spent. The language supports a type of non-interactive zero-knowledge proofs called \u03a3-protocols and is flexible enough to allow for ring-signatures, multisignatures, multiple currencies, atomic swaps, self-replicating scripts, and long-term computation. The overwhelming majority of successful public blockchain use\u2010cases are related to financial applications. Ergo extends Bitcoin\u2019s way of writing contracts by attaching a guard script (together with additional custom data) to every coin. For example, in addition to regular protection by some m\u2010of\u2010n signature, Ergo allows specifying the possible recipients of these coins, which may another contract with similar complex conditions. This \"chaining\" approach allows the implementation of secure and efficient contracts of arbitrary complexity. Keeping all this in mind, we expect ErgoScript and Ergo\u2019s design to be uniquely useful as Contractual Money. Let's say you want to create a 'ring spending contract', where either of us can make a transaction from the same address, but we don't want anyone else to know which one of us is spending the funds. That's not possible with Bitcoin. While Ethereum can, it would be expensive and complicated \u2013 especially with a ring size of 10 or 20 members, required for robust privacy. With Ergo, this kind of application can be created quickly, thanks to the integration of Sigma protocols in the core. This enables self-sovereign application-level privacy: trustless scripts that can be used to access mixers or other functionality without any third parties required. val ringScript = s\"\"\" { atLeast( 3, Coll( PK(\"9f8ZQt1Sue6W5ACdMSPRzsHj3jjiZkbYy3CEtB4BisxEyk4RsNk\"), PK(\"9hFWPyhCJcw4KQyCGu4yAGfC1ieRAKyFg24FKjLJK2uDgA873uq\"), PK(\"9fdVP2jca1e5nCTT6q9ijZLssGj6v4juY8gEAxUhp7YTuSsLspS\"), PK(\"9gAKeRu1W4Dh6adWXnnYmfqjCTnxnSMtym2LPPMPErCkusCd6F3\"), PK(\"9gmNsqrqdSppLUBqg2UzREmmivgqh1r3jmNcLAc53hk3YCvAGWE\") ) ) } This an example 3-out-of-5 threshold signature which can be compiled to a P2S address sending ergs to resulting address (protected by the threshold sig) Here is a good intro to making a signature Use Cases When combined with a blockchain, these composable proofs enable some very powerful use cases. The logic for proofs can include conditions based on blockchain state. For example, \u2018If the deadline block height has been reached, Alice can provide knowledge of a secret key for a refund. OR a ring signature from Alice and Bob is required to spend coins.\u2019 Or \u2018If this account holds a minimum of 100 ERG, Alice OR Bob can remove funds above that amount.\u2019 It\u2019s relatively easy to swap coins or custom tokens trustlessly across any Bitcoin-like blockchains. But beyond that, Ergo allows partial swaps. Just like on a regular exchange, orders can be partially filled, if that\u2019s what the trader wants. This means it\u2019s possible to build a fully-fledged decentralised exchange (DEX) that enables cross-chain trading: a totally trustless version of existing crypto exchanges. There\u2019s no need for any gateways, token wrapping or other potential bottlenecks or points of failure. ErgoMixer ErgoMixer is a state of the art (and worlds first) non-interactive and non-custodial token mixer and the first real implementation of Sigma protocols on Ergo. Mac/Windows applications are available! . Check out this page on ergonaut.space for more information including research papers / presentations; and these discussions in Discords. Tornado Cash vs ErgoMixer anon2020s explaining the logic which guarantees the anonymity Lots more possible, many still undiscovered! A Simpler Collective-Spending Approach for Everyone! trustless prediction markets and on-chain insurance Trustless LETS \"I think global mutual credit system (trustless, so collateralized) can be perfectly combined with ErgoFund, so funds collected can be used to open credit-line basically to spend money for services in the mutual credit system\" \"So at the same time off the peg ring and threshold signatures, where from k-out-of-n signatures, it could not be concluded which k signers were real, so you have i think first zero knowledge multisig with no signers disclosure in cryptocurrency at the same time(on app level).\" \"You have to look more into the base at the moment to see future possibilities, at the base you have multisig with no signers disclosure, then new features like covert address, multi hop withdrawals discovered slowly thanks to contracts possibilities, mixer can be just run locally at the same time. You can build Monero on top of Ergo, will it have better privacy guarantees? it is yet to be discovered. But you can think of private order books for example at the same time, similar to a simple and interesting payment network. I think that combining these things with NYM in the future can have more sense for scalable privacy.\" 'Optional' Privacy? A Rich smart-contract language and simplicity are the priority in Ergo, and smart-contracts make privacy a lot harder. There are plenty of reasons to want optional privacy - transparent ledgers are a feature for many use-cases. e.g. charities that want everyone to have full access to the flow of funds. The ability to operate with privacy or with transparency is a feature. There's also strong arguments for optional privacy for adoption and regulation. ErgoMixer is non-interactive so works with the blockchain alone, no off-chain coordination with others (and trusted coordinator) needed. In future, privacy by default could be enabled for every transaction in Ergo. Maybe the community will do it someday or maybe integrating mix-nets and on other novel ideas on the application layer will be sufficient. \"With non-optional privacy you can't have (efficient) powerful contracts. Even more, even for simple payments formalizing (in order to minimize with guarantee) leakage is hard, for arbitrary contracts not feasible at all I guess\"","title":"Sigma Protocols"},{"location":"dev/ergo/sigma/#zero-knowledge-proof-intro","text":"Let\u2019s say someone picks up a phone in a bar. You can prove it\u2019s yours by hiding the screen, entering the unlock code and showing the unlocked screen to the person who found it. This is a simple example of a zero-knowledge proof: you have proven you own the phone without giving away any sensitive information. In cryptography, most practical problems are associated with secrets. The most popular application lies in digital signatures, used by millions of people around the world every day. Essentially, these involve saying: \u2018This message proves I know the private key associated with this public key \u2013 but I\u2019m not revealing the private key itself\u2019.","title":"Zero-Knowledge Proof Intro"},{"location":"dev/ergo/sigma/#sigma-protocols","text":"ErgoScript is the language used to specify the conditions under which currency can be spent. The language supports a type of non-interactive zero-knowledge proofs called \u03a3-protocols and is flexible enough to allow for ring-signatures, multisignatures, multiple currencies, atomic swaps, self-replicating scripts, and long-term computation. The overwhelming majority of successful public blockchain use\u2010cases are related to financial applications. Ergo extends Bitcoin\u2019s way of writing contracts by attaching a guard script (together with additional custom data) to every coin. For example, in addition to regular protection by some m\u2010of\u2010n signature, Ergo allows specifying the possible recipients of these coins, which may another contract with similar complex conditions. This \"chaining\" approach allows the implementation of secure and efficient contracts of arbitrary complexity. Keeping all this in mind, we expect ErgoScript and Ergo\u2019s design to be uniquely useful as Contractual Money. Let's say you want to create a 'ring spending contract', where either of us can make a transaction from the same address, but we don't want anyone else to know which one of us is spending the funds. That's not possible with Bitcoin. While Ethereum can, it would be expensive and complicated \u2013 especially with a ring size of 10 or 20 members, required for robust privacy. With Ergo, this kind of application can be created quickly, thanks to the integration of Sigma protocols in the core. This enables self-sovereign application-level privacy: trustless scripts that can be used to access mixers or other functionality without any third parties required. val ringScript = s\"\"\" { atLeast( 3, Coll( PK(\"9f8ZQt1Sue6W5ACdMSPRzsHj3jjiZkbYy3CEtB4BisxEyk4RsNk\"), PK(\"9hFWPyhCJcw4KQyCGu4yAGfC1ieRAKyFg24FKjLJK2uDgA873uq\"), PK(\"9fdVP2jca1e5nCTT6q9ijZLssGj6v4juY8gEAxUhp7YTuSsLspS\"), PK(\"9gAKeRu1W4Dh6adWXnnYmfqjCTnxnSMtym2LPPMPErCkusCd6F3\"), PK(\"9gmNsqrqdSppLUBqg2UzREmmivgqh1r3jmNcLAc53hk3YCvAGWE\") ) ) } This an example 3-out-of-5 threshold signature which can be compiled to a P2S address sending ergs to resulting address (protected by the threshold sig) Here is a good intro to making a signature","title":"Sigma protocols"},{"location":"dev/ergo/sigma/#use-cases","text":"When combined with a blockchain, these composable proofs enable some very powerful use cases. The logic for proofs can include conditions based on blockchain state. For example, \u2018If the deadline block height has been reached, Alice can provide knowledge of a secret key for a refund. OR a ring signature from Alice and Bob is required to spend coins.\u2019 Or \u2018If this account holds a minimum of 100 ERG, Alice OR Bob can remove funds above that amount.\u2019 It\u2019s relatively easy to swap coins or custom tokens trustlessly across any Bitcoin-like blockchains. But beyond that, Ergo allows partial swaps. Just like on a regular exchange, orders can be partially filled, if that\u2019s what the trader wants. This means it\u2019s possible to build a fully-fledged decentralised exchange (DEX) that enables cross-chain trading: a totally trustless version of existing crypto exchanges. There\u2019s no need for any gateways, token wrapping or other potential bottlenecks or points of failure.","title":"Use Cases"},{"location":"dev/ergo/sigma/#ergomixer","text":"ErgoMixer is a state of the art (and worlds first) non-interactive and non-custodial token mixer and the first real implementation of Sigma protocols on Ergo. Mac/Windows applications are available! . Check out this page on ergonaut.space for more information including research papers / presentations; and these discussions in Discords. Tornado Cash vs ErgoMixer anon2020s explaining the logic which guarantees the anonymity","title":"ErgoMixer"},{"location":"dev/ergo/sigma/#lots-more-possible-many-still-undiscovered","text":"A Simpler Collective-Spending Approach for Everyone! trustless prediction markets and on-chain insurance Trustless LETS \"I think global mutual credit system (trustless, so collateralized) can be perfectly combined with ErgoFund, so funds collected can be used to open credit-line basically to spend money for services in the mutual credit system\" \"So at the same time off the peg ring and threshold signatures, where from k-out-of-n signatures, it could not be concluded which k signers were real, so you have i think first zero knowledge multisig with no signers disclosure in cryptocurrency at the same time(on app level).\" \"You have to look more into the base at the moment to see future possibilities, at the base you have multisig with no signers disclosure, then new features like covert address, multi hop withdrawals discovered slowly thanks to contracts possibilities, mixer can be just run locally at the same time. You can build Monero on top of Ergo, will it have better privacy guarantees? it is yet to be discovered. But you can think of private order books for example at the same time, similar to a simple and interesting payment network. I think that combining these things with NYM in the future can have more sense for scalable privacy.\"","title":"Lots more possible, many still undiscovered!"},{"location":"dev/ergo/sigma/#optional-privacy","text":"A Rich smart-contract language and simplicity are the priority in Ergo, and smart-contracts make privacy a lot harder. There are plenty of reasons to want optional privacy - transparent ledgers are a feature for many use-cases. e.g. charities that want everyone to have full access to the flow of funds. The ability to operate with privacy or with transparency is a feature. There's also strong arguments for optional privacy for adoption and regulation. ErgoMixer is non-interactive so works with the blockchain alone, no off-chain coordination with others (and trusted coordinator) needed. In future, privacy by default could be enabled for every transaction in Ergo. Maybe the community will do it someday or maybe integrating mix-nets and on other novel ideas on the application layer will be sufficient. \"With non-optional privacy you can't have (efficient) powerful contracts. Even more, even for simple payments formalizing (in order to minimize with guarantee) leakage is hard, for arbitrary contracts not feasible at all I guess\"","title":"'Optional' Privacy?"},{"location":"dev/node/node-config/","text":"Wallets Linux Mac Windows HOME environment variable is not often set in Windows. Please replace ${HOME} with ${HOMEPATH} or ${APPDATA} in your configuration file. You should also remember that environment variables names are case sensitive in Windows. Pi How to setup an Ergo node on a Raspberry Pi Node Config File !!!Note!!! This guide is outdated and should be actualized to current config format Actual for version 1.6.1 Below you can find a complete Ergo Node configuration file. This is the default configuration shipped with the application. It is possible to overwrite any parameters by providing an additional configuration file. You can pass an additional configuration file by providing the path to it as the first command line parameter when starting Ergo Node application. ergo { # Directory to keep data directory = ${user.dir}\"/ergo/data\" # Settings for node view holder regime. See papers.yellow.ModifiersProcessing.md node { # State type. Possible options are: # \"utxo\" - keep full utxo set, that allows to validate arbitrary block and generate ADProofs # \"digest\" - keep state root hash only and validate transactions via ADProofs stateType = \"utxo\" # Download block transactions and verify them (requires BlocksToKeep == 0 if disabled) verifyTransactions = true # Number of last blocks to keep with transactions and ADproofs, for all other blocks only header will be stored. # Keep all blocks from genesis if negative blocksToKeep = -1 # Download PoPoW proof on node bootstrap PoPoWBootstrap = false # Minimal suffix size for PoPoW proof (may be pre-defined constant or settings parameter) minimalSuffix = 10 # Is the node is doing mining mining = false # If true, a node generates blocks being offline. The only really useful case for it probably is to start a new # blockchain offlineGeneration = false # Delay for miner after succesful block creation miningDelay = 5s # Number of state snapshot diffs to keep. Defines maximum rollback depth keepVersions = 200 } testing { # Whether to turn on transaction generator transactionGeneration = false # Max number of transactions generated per a new block received maxTransactionsPerBlock = 100 } cache { # Number of recently used modifiers that will be kept in memory modifiersCacheSize = 1000 # Number of recently used indexes that will be kept in memory indexesCacheSize = 10000 } # Chain-specific settings. Change only if you are going to launch a new chain! chain { # Network address prefix, currently reserved values are 0x00 (money chain mainnet) and 0x20 (32 in decimal, # money chain testnet) addressPrefix = 16 # Monetary config for chain monetary { # number of blocks reward won't change (525600 (2 years) for mainnet, 10080 (14 days) for testnet) fixedRatePeriod = 10080 # number of coins issued every block during fixedRatePeriod (75 Ergo) fixedRate = 7500000000 # number of blocks between reward reduction (64800 (90 days) for mainnet, 2160 (3 days) for testnet) epochLength = 2160 # number of coins reward decrease every epochs (3 Ergo) oneEpochReduction = 300000000 # Base16 representation of state roothash after genesis afterGenesisStateDigestHex = \"a8f724cef6f8a247a63fba1b713def858d97258f7cd5d7ed71489a474790db5501\" } # Desired time interval between blocks blockInterval = 2m # length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block epochLength = 256 # Number of last epochs that will be used for difficulty recalculation useLastEpochs = 8 # Proof-of-Work algorithm and its parameters. Possible options are \"fake\" and \"equihash\". powScheme { powType = \"equihash\" n = 96 # used by Equihash k = 5 # used by Equihash } # Defines an id of the genesis block. Other genesis blocks will be considered invalid. # genesisId = \"ab19bb59871e86507defb9a7769841b1130aad4d8c1ea8b0e01e0dee9e97a27e\" } wallet { # Seed the wallet private keys are derived from seed = \"C3FAFMC27697FAF29E9887F977BB5994\" # How many Schorr secret keys (w for the g^w public key) to generate dlogSecretsNumber = 4 # Interval to re-scan uncertain boxes. When a block arrives, its transaction outputs are to be scanned, and if # certain bytes are found in the output script (e.g. public key bytes), the box is to be put to a queue of a boxes # which are potentially wallet's. But to be sure, script execution is needed, which could be costly to do in a bulk. # So we check from a queue only one box per \"scanningInterval\". scanningInterval = 1s } } scorex { network { bindAddress = \"0.0.0.0:9006\" maxInvObjects = 400 nodeName = \"ergo-testnet1\" knownPeers = [\"178.128.162.150:9006\", \"78.46.93.239:9006\", \"209.97.136.204:9006\", \"209.97.138.187:9006\", \"209.97.134.210:9006\", \"88.198.13.202:9006\"] syncInterval = 15s syncStatusRefresh = 30s syncIntervalStable = 20s syncTimeout = 5s syncStatusRefreshStable = 1m deliveryTimeout = 8s maxDeliveryChecks = 2 appVersion = 0.2.1 agentName = \"ergoref\" maxModifiersCacheSize = 512 maxPacketSize = 2048576 } restApi { bindAddress = \"0.0.0.0:9052\" } } Ergo configuration section Root configuration section ergo holds essential application parameters and other configuration subsections. There is also another one root section scorex that holds the parameters inherited from the Scorex project . Using parameter directory it is possible to set a path to the base application directory. It is also possible to use environment variables to override configuration parameters. For example, by default the base directory is being constructed relatively to the user's HOME environment variable. Please do not enclose references to environment variables into quotation marks, otherwise they will be handled as strings and won't be resolved. Network settings In scorex.network section P2P network related settings could be set. Using declaredAddress parameter you can set the external IP address and port number of the node. It's necessary to work behind NAT in most cloud hosting, where the machine does not interface directly with the external address. If you do not specify it, then your node connects to the P2P network, but it won't listen to incoming connections so other nodes will not be able to connect. Other nodes are connected to your node using these data. The format of this parameter is \"[ip-address]:[port]\". Using parameter bindAddress you can set the IP address of local network interface on which Ergo Node will accept incoming connections. By default, node binds to \"0.0.0.0\" that means that it will listen on all available network adapters. Note about Internet Address settings Internet Address settings have <ip-adderss>:<port> format. Note the <port> part at the very end of the address after the colon. For the bindAddress setting port part is used to set the network port number to which other Ergo nodes will connect. Please ensure that the port is reachable from outside, otherwise your node will have only outgoing connections to P2P network. If the given port is taken by other application, your node won't start. Parameter nodeName could be used to set the name of your node visible to other participants of the P2P network. The name transmitted during initial handshake. In the default configuration, this parameter is commented out, which leads to random name generation. The knownPeers parameter stores the list of bootstrap nodes to which your node will establish outgoing connections while initializing. Note about time settings All time span parameters are set in milliseconds. You can also use duration units to shorten their values. Supported units are: * s, second, seconds * m, minute, minutes * h, hour, hours * d, day, days For usage examples see the default configuration file above. Use maxConnections parameter to set the maximum number of simultaneous connections handled by the node. Parameter connectionTimeout could be used to change the network communication timeout. Using handshakeTimeout parameter it is possible to set time period to wait for reply during handshake. In case of no reply the peer will be blacklisted. Using parameters that starts with upnp you can configure the UPnP settings. Actually, those settings are useful only if you ran your Ergo node on the home network where the node could ask your router to establish a tunnel. By default, this functionality is disabled. Use upnpEnabled parameter to enable this functionality. Wallet settings In wallet section you can configure the wallet built in Ergo node. Use dlogSecretsNumber parameter to specify how many Schorr secret keys (w for the g^w public key) to generate. Use scanningInterval parameter to set an interval of re-scaning uncertain boxes. Using seed parameter you could recreate an existing walled on a new node. If you don't have any existing wallet comment out this parameter and start the node. During the first run, the application will create a new wallet with a random seed for you. In this case, the seed will be displayed in the application log. Attention! The wallet is a critical part of your node. You should better store wallet's file in a safe and protected location. Don't forget to backup your wallet's file. It's recommended to remove the seed from the configuration file immediately after the start of the node. If an attacker gains access to this seed string, he has access to all your funds on all your addresses! Blockchain settings At ergo.chain you can select or custom the blockchain parameters. Use blockInterval parameter to set desired time interval between blocks. Parameter epochLength used to set the length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block useLastEpochs parameter stores a number of last epochs that will be used for difficulty recalculation. You can change the PoW algo or related parameters using powScheme section. Node settings In section ergo.node it is possible to configure parameters of the node regime. Use enable parameter to enable or disable block generation on the node. By default, it's disabled. Node with disabled offlineGeneration parameter will start mining as soon as it connects to the first peer in the P2P network. Setting this parameter to true will enable off-line generation. Using miningDelay parameter you can tune your node's mining delay after finding a new block. REST API settings In section scorex.rest-api you can set the node's REST API parameters. Parameter bindAddress could be used to select network interface on which REST API will accept incoming connections. The :<port> part could be used to change the port number, which REST API will listen for connections. Attention! For the better security, do not change bindAddress from \"127.0.0.1\" if you do not know what you're doing! For the external access you should use Nginx's proxy_pass module or SSH port-forwarding instead. Use api-key-hash parameter to set the hash of your API key. The API key is used to protect calls of critical API methods. Remember, that in this parameter you should provide the hash of API key, but during REST calls you should provide API key itself. You can use blake2b to produce the hash of your API key. Attention! API key is transmitted in the HTTP header as unprotected plain text! An attacker could intercept it in network transit and use it to transfer your money to any address! So you have to protect the transmission using HTTPS or use SSH port forwarding. Parameter corsAllowedOrigin could be used to enable or disable CORS support in REST API. CORS allows to safely resolve queries to other domains outside the one running the node. It's necessary for Swagger and Lite client. You can read about it here .","title":"Mobile"},{"location":"dev/node/node-config/#wallets","text":"","title":"Wallets"},{"location":"dev/node/node-config/#linux","text":"","title":"Linux"},{"location":"dev/node/node-config/#mac","text":"","title":"Mac"},{"location":"dev/node/node-config/#windows","text":"HOME environment variable is not often set in Windows. Please replace ${HOME} with ${HOMEPATH} or ${APPDATA} in your configuration file. You should also remember that environment variables names are case sensitive in Windows.","title":"Windows"},{"location":"dev/node/node-config/#pi","text":"How to setup an Ergo node on a Raspberry Pi","title":"Pi"},{"location":"dev/node/node-config/#node-config-file","text":"!!!Note!!! This guide is outdated and should be actualized to current config format","title":"Node Config File"},{"location":"dev/node/node-config/#actual-for-version-161","text":"Below you can find a complete Ergo Node configuration file. This is the default configuration shipped with the application. It is possible to overwrite any parameters by providing an additional configuration file. You can pass an additional configuration file by providing the path to it as the first command line parameter when starting Ergo Node application. ergo { # Directory to keep data directory = ${user.dir}\"/ergo/data\" # Settings for node view holder regime. See papers.yellow.ModifiersProcessing.md node { # State type. Possible options are: # \"utxo\" - keep full utxo set, that allows to validate arbitrary block and generate ADProofs # \"digest\" - keep state root hash only and validate transactions via ADProofs stateType = \"utxo\" # Download block transactions and verify them (requires BlocksToKeep == 0 if disabled) verifyTransactions = true # Number of last blocks to keep with transactions and ADproofs, for all other blocks only header will be stored. # Keep all blocks from genesis if negative blocksToKeep = -1 # Download PoPoW proof on node bootstrap PoPoWBootstrap = false # Minimal suffix size for PoPoW proof (may be pre-defined constant or settings parameter) minimalSuffix = 10 # Is the node is doing mining mining = false # If true, a node generates blocks being offline. The only really useful case for it probably is to start a new # blockchain offlineGeneration = false # Delay for miner after succesful block creation miningDelay = 5s # Number of state snapshot diffs to keep. Defines maximum rollback depth keepVersions = 200 } testing { # Whether to turn on transaction generator transactionGeneration = false # Max number of transactions generated per a new block received maxTransactionsPerBlock = 100 } cache { # Number of recently used modifiers that will be kept in memory modifiersCacheSize = 1000 # Number of recently used indexes that will be kept in memory indexesCacheSize = 10000 } # Chain-specific settings. Change only if you are going to launch a new chain! chain { # Network address prefix, currently reserved values are 0x00 (money chain mainnet) and 0x20 (32 in decimal, # money chain testnet) addressPrefix = 16 # Monetary config for chain monetary { # number of blocks reward won't change (525600 (2 years) for mainnet, 10080 (14 days) for testnet) fixedRatePeriod = 10080 # number of coins issued every block during fixedRatePeriod (75 Ergo) fixedRate = 7500000000 # number of blocks between reward reduction (64800 (90 days) for mainnet, 2160 (3 days) for testnet) epochLength = 2160 # number of coins reward decrease every epochs (3 Ergo) oneEpochReduction = 300000000 # Base16 representation of state roothash after genesis afterGenesisStateDigestHex = \"a8f724cef6f8a247a63fba1b713def858d97258f7cd5d7ed71489a474790db5501\" } # Desired time interval between blocks blockInterval = 2m # length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block epochLength = 256 # Number of last epochs that will be used for difficulty recalculation useLastEpochs = 8 # Proof-of-Work algorithm and its parameters. Possible options are \"fake\" and \"equihash\". powScheme { powType = \"equihash\" n = 96 # used by Equihash k = 5 # used by Equihash } # Defines an id of the genesis block. Other genesis blocks will be considered invalid. # genesisId = \"ab19bb59871e86507defb9a7769841b1130aad4d8c1ea8b0e01e0dee9e97a27e\" } wallet { # Seed the wallet private keys are derived from seed = \"C3FAFMC27697FAF29E9887F977BB5994\" # How many Schorr secret keys (w for the g^w public key) to generate dlogSecretsNumber = 4 # Interval to re-scan uncertain boxes. When a block arrives, its transaction outputs are to be scanned, and if # certain bytes are found in the output script (e.g. public key bytes), the box is to be put to a queue of a boxes # which are potentially wallet's. But to be sure, script execution is needed, which could be costly to do in a bulk. # So we check from a queue only one box per \"scanningInterval\". scanningInterval = 1s } } scorex { network { bindAddress = \"0.0.0.0:9006\" maxInvObjects = 400 nodeName = \"ergo-testnet1\" knownPeers = [\"178.128.162.150:9006\", \"78.46.93.239:9006\", \"209.97.136.204:9006\", \"209.97.138.187:9006\", \"209.97.134.210:9006\", \"88.198.13.202:9006\"] syncInterval = 15s syncStatusRefresh = 30s syncIntervalStable = 20s syncTimeout = 5s syncStatusRefreshStable = 1m deliveryTimeout = 8s maxDeliveryChecks = 2 appVersion = 0.2.1 agentName = \"ergoref\" maxModifiersCacheSize = 512 maxPacketSize = 2048576 } restApi { bindAddress = \"0.0.0.0:9052\" } }","title":"Actual for version 1.6.1"},{"location":"dev/node/node-config/#ergo-configuration-section","text":"Root configuration section ergo holds essential application parameters and other configuration subsections. There is also another one root section scorex that holds the parameters inherited from the Scorex project . Using parameter directory it is possible to set a path to the base application directory. It is also possible to use environment variables to override configuration parameters. For example, by default the base directory is being constructed relatively to the user's HOME environment variable. Please do not enclose references to environment variables into quotation marks, otherwise they will be handled as strings and won't be resolved.","title":"Ergo configuration section"},{"location":"dev/node/node-config/#network-settings","text":"In scorex.network section P2P network related settings could be set. Using declaredAddress parameter you can set the external IP address and port number of the node. It's necessary to work behind NAT in most cloud hosting, where the machine does not interface directly with the external address. If you do not specify it, then your node connects to the P2P network, but it won't listen to incoming connections so other nodes will not be able to connect. Other nodes are connected to your node using these data. The format of this parameter is \"[ip-address]:[port]\". Using parameter bindAddress you can set the IP address of local network interface on which Ergo Node will accept incoming connections. By default, node binds to \"0.0.0.0\" that means that it will listen on all available network adapters. Note about Internet Address settings Internet Address settings have <ip-adderss>:<port> format. Note the <port> part at the very end of the address after the colon. For the bindAddress setting port part is used to set the network port number to which other Ergo nodes will connect. Please ensure that the port is reachable from outside, otherwise your node will have only outgoing connections to P2P network. If the given port is taken by other application, your node won't start. Parameter nodeName could be used to set the name of your node visible to other participants of the P2P network. The name transmitted during initial handshake. In the default configuration, this parameter is commented out, which leads to random name generation. The knownPeers parameter stores the list of bootstrap nodes to which your node will establish outgoing connections while initializing. Note about time settings All time span parameters are set in milliseconds. You can also use duration units to shorten their values. Supported units are: * s, second, seconds * m, minute, minutes * h, hour, hours * d, day, days For usage examples see the default configuration file above. Use maxConnections parameter to set the maximum number of simultaneous connections handled by the node. Parameter connectionTimeout could be used to change the network communication timeout. Using handshakeTimeout parameter it is possible to set time period to wait for reply during handshake. In case of no reply the peer will be blacklisted. Using parameters that starts with upnp you can configure the UPnP settings. Actually, those settings are useful only if you ran your Ergo node on the home network where the node could ask your router to establish a tunnel. By default, this functionality is disabled. Use upnpEnabled parameter to enable this functionality. Wallet settings In wallet section you can configure the wallet built in Ergo node. Use dlogSecretsNumber parameter to specify how many Schorr secret keys (w for the g^w public key) to generate. Use scanningInterval parameter to set an interval of re-scaning uncertain boxes. Using seed parameter you could recreate an existing walled on a new node. If you don't have any existing wallet comment out this parameter and start the node. During the first run, the application will create a new wallet with a random seed for you. In this case, the seed will be displayed in the application log. Attention! The wallet is a critical part of your node. You should better store wallet's file in a safe and protected location. Don't forget to backup your wallet's file. It's recommended to remove the seed from the configuration file immediately after the start of the node. If an attacker gains access to this seed string, he has access to all your funds on all your addresses! Blockchain settings At ergo.chain you can select or custom the blockchain parameters. Use blockInterval parameter to set desired time interval between blocks. Parameter epochLength used to set the length of an epoch in difficulty recalculation. 1 means difficulty recalculation every block useLastEpochs parameter stores a number of last epochs that will be used for difficulty recalculation. You can change the PoW algo or related parameters using powScheme section. Node settings In section ergo.node it is possible to configure parameters of the node regime. Use enable parameter to enable or disable block generation on the node. By default, it's disabled. Node with disabled offlineGeneration parameter will start mining as soon as it connects to the first peer in the P2P network. Setting this parameter to true will enable off-line generation. Using miningDelay parameter you can tune your node's mining delay after finding a new block. REST API settings In section scorex.rest-api you can set the node's REST API parameters. Parameter bindAddress could be used to select network interface on which REST API will accept incoming connections. The :<port> part could be used to change the port number, which REST API will listen for connections. Attention! For the better security, do not change bindAddress from \"127.0.0.1\" if you do not know what you're doing! For the external access you should use Nginx's proxy_pass module or SSH port-forwarding instead. Use api-key-hash parameter to set the hash of your API key. The API key is used to protect calls of critical API methods. Remember, that in this parameter you should provide the hash of API key, but during REST calls you should provide API key itself. You can use blake2b to produce the hash of your API key. Attention! API key is transmitted in the HTTP header as unprotected plain text! An attacker could intercept it in network transit and use it to transfer your money to any address! So you have to protect the transmission using HTTPS or use SSH port forwarding. Parameter corsAllowedOrigin could be used to enable or disable CORS support in REST API. CORS allows to safely resolve queries to other domains outside the one running the node. It's necessary for Swagger and Lite client. You can read about it here .","title":"Network settings"},{"location":"dev/node/run/","text":"How to set up and configure a full Ergo node This tutorial explains how to install and run a full Ergo node. It does not cover mining. Windows users can also watch the video tutorial. Node security There are a few important aspects of node usage that your wallet and money's safety depends on: * An Ergo node requires storing security-critical parameters in the configuration file. You should never make this file public. * An Ergo node provides a REST API for interacting with the built-in wallet. Sensitive API methods require a security token, which should never be sent over untrusted channels. * Access to the Ergo REST API must be restricted to known hosts. In particular, the API must not be accessible from the Internet. Prerequisites To run an Ergo node you need a JDK/JRE version >= 9 installed on your system. We recommend either version 9 or 11. One way to do this is to install Oracle Java SE . Note that Oracle JDK/JRE <= 8 is no longer supported . The next step is to download the latest Ergo client release jar file and create a node configuration file. Note that instead of downloading the precompiled Ergo jar, you can clone the repository and compile the jar from the source using SBT by issuing the sbt assembly command. Create a dedicated folder (such as ~/ergo ) for running the node. Denote by ergo_folder the folder where the jar is kept. Running the node for the first time Create a configuration file ergo.conf with the following text in ergo_folder . ergo { node { mining = false } } Open a command prompt and cd to ergo_folder . Then issue the following command to run the node for the first time: java -jar ergo-<release>.jar --mainnet -c ergo.conf The node will start syncing immediately after this. Wait for a few minutes for the API to start and go to the next step. Note: You can use any name for the file instead of ergo.conf . All configuration parameters are to be passed through this file and you only need to rewrite parameters that you want to change from the default values. The above config file actually has the default values. Compute the hash of your secret First, select a secret to protect your API. Then go to http://127.0.0.1:9053/swagger#/utils/hashBlake2b and call the API to compute the hash of your secret. Refer to the image below. Copy the response containing the hash for use in the next step (see below image). In our example, the secret is hello whose hash corresponds to 324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf . IMPORTANT You must use a different and strong secret. Update config file with API key hash Edit the config file ergo.conf and paste the hash copied in the previous step. The file should look as follows: ergo { node { mining = false } } scorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string 'hello' # replace with your actual hash apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } } Initialize wallet Restart the node and go to http://127.0.0.1:9053/panel to access the panel. Then set the API key secret from the previous step. Note that you need to set the secret and not the hash from the config file. In our example, this is the string hello . Click on Initialize wallet . After the pop-up opens, there are two ways to proceed depending on your scenario. If this is the first time you are running the node then you need to initialize it with a new mnemonic sentence. If you had created a wallet earlier and would like to obtain the same address (possibly because there are funds stored in it), then you have to restore the wallet using the mnemonic sentence you had saved earlier. Follow one of the below steps depending on your situation. Initialize wallet from scratch In the pop-up that opens, you must enter a wallet password. The mnemonic password is optional. After you click send, the wallet will return a mnemonic sentence as shown below. You must copy this sentence and save it in a safe place. This sentence will be needed to restore the wallet on a different computer. Restore wallet from earlier Copy the mnemonic sentence from earlier paste it into the \"Mnemonic\" field in the Restore-wallet form. Enter a secure wallet password. Leave the Mnemonic password empty (it is only for advanced users). Refer to the figure below. After the wallet has been successfully restored from the mnemonic sentence, you will see a confirmation as shown in the figure below. Get wallet addresses This is a test to ensure you have set up the node properly. It will return the current addresses in the wallet. In the panel at http://127.0.0.1:9053/panel click on the Wallet tab on the left and then on Get all wallet addresses to view the addresses currently maintained by the wallet. It should return at least one address if the node is set correctly. Check if the node is synced While the node is syncing, the panel will show \"Active synchronization\" (see the image below). After the node is fully synced, the text will change to \"Node is synced\", as shown below. Check wallet balance Once the node is synced, use the wallet API in the panel to see your balance, as shown below. Sending funds If there is a non-zero balance, you can send Ergs to any other address using the panel as shown below: View the Swagger UI A Swagger UI is available at http://127.0.0.1:9053/swagger . You had already used it earlier to compute the hash of your secret. You can also use this UI to make API calls for advanced operations that are not (yet) available in the panel. Some examples of this are: Creating non-standard transactions with registers and context variables. Creating transactions that issue tokens. Creating transactions that use certain boxes as inputs. A future article will discuss each of these operations in detail. Note that most methods in the API are protected and you would need to use your secret (from earlier) to access these methods. The following images show the process of setting this secret in the Swagger UI. Navigate to the top of the page and click the \"Authorize\" button. Enter your secret in the form that pops-up as shown in the figure below. After the password is entered and you have clicked \"Authorize\", you will be shown the popup below: Now navigate to http://127.0.0.1:9053/swagger#/wallet/walletAddresses in the same tab where you entered the password and click on \"Try it out\". You should see the same list of addresses as you saw earlier from the panel.","title":"First Run"},{"location":"dev/node/run/#how-to-set-up-and-configure-a-full-ergo-node","text":"This tutorial explains how to install and run a full Ergo node. It does not cover mining. Windows users can also watch the video tutorial.","title":"How to set up and configure a full Ergo node"},{"location":"dev/node/run/#node-security","text":"There are a few important aspects of node usage that your wallet and money's safety depends on: * An Ergo node requires storing security-critical parameters in the configuration file. You should never make this file public. * An Ergo node provides a REST API for interacting with the built-in wallet. Sensitive API methods require a security token, which should never be sent over untrusted channels. * Access to the Ergo REST API must be restricted to known hosts. In particular, the API must not be accessible from the Internet.","title":"Node security"},{"location":"dev/node/run/#prerequisites","text":"To run an Ergo node you need a JDK/JRE version >= 9 installed on your system. We recommend either version 9 or 11. One way to do this is to install Oracle Java SE . Note that Oracle JDK/JRE <= 8 is no longer supported . The next step is to download the latest Ergo client release jar file and create a node configuration file. Note that instead of downloading the precompiled Ergo jar, you can clone the repository and compile the jar from the source using SBT by issuing the sbt assembly command. Create a dedicated folder (such as ~/ergo ) for running the node. Denote by ergo_folder the folder where the jar is kept.","title":"Prerequisites"},{"location":"dev/node/run/#running-the-node-for-the-first-time","text":"Create a configuration file ergo.conf with the following text in ergo_folder . ergo { node { mining = false } } Open a command prompt and cd to ergo_folder . Then issue the following command to run the node for the first time: java -jar ergo-<release>.jar --mainnet -c ergo.conf The node will start syncing immediately after this. Wait for a few minutes for the API to start and go to the next step. Note: You can use any name for the file instead of ergo.conf . All configuration parameters are to be passed through this file and you only need to rewrite parameters that you want to change from the default values. The above config file actually has the default values.","title":"Running the node for the first time"},{"location":"dev/node/run/#compute-the-hash-of-your-secret","text":"First, select a secret to protect your API. Then go to http://127.0.0.1:9053/swagger#/utils/hashBlake2b and call the API to compute the hash of your secret. Refer to the image below. Copy the response containing the hash for use in the next step (see below image). In our example, the secret is hello whose hash corresponds to 324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf . IMPORTANT You must use a different and strong secret.","title":"Compute the hash of your secret"},{"location":"dev/node/run/#update-config-file-with-api-key-hash","text":"Edit the config file ergo.conf and paste the hash copied in the previous step. The file should look as follows: ergo { node { mining = false } } scorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string 'hello' # replace with your actual hash apiKeyHash = \"324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\" } }","title":"Update config file with API key hash"},{"location":"dev/node/run/#initialize-wallet","text":"Restart the node and go to http://127.0.0.1:9053/panel to access the panel. Then set the API key secret from the previous step. Note that you need to set the secret and not the hash from the config file. In our example, this is the string hello . Click on Initialize wallet . After the pop-up opens, there are two ways to proceed depending on your scenario. If this is the first time you are running the node then you need to initialize it with a new mnemonic sentence. If you had created a wallet earlier and would like to obtain the same address (possibly because there are funds stored in it), then you have to restore the wallet using the mnemonic sentence you had saved earlier. Follow one of the below steps depending on your situation.","title":"Initialize wallet"},{"location":"dev/node/run/#initialize-wallet-from-scratch","text":"In the pop-up that opens, you must enter a wallet password. The mnemonic password is optional. After you click send, the wallet will return a mnemonic sentence as shown below. You must copy this sentence and save it in a safe place. This sentence will be needed to restore the wallet on a different computer.","title":"Initialize wallet from scratch"},{"location":"dev/node/run/#restore-wallet-from-earlier","text":"Copy the mnemonic sentence from earlier paste it into the \"Mnemonic\" field in the Restore-wallet form. Enter a secure wallet password. Leave the Mnemonic password empty (it is only for advanced users). Refer to the figure below. After the wallet has been successfully restored from the mnemonic sentence, you will see a confirmation as shown in the figure below.","title":"Restore wallet from earlier"},{"location":"dev/node/run/#get-wallet-addresses","text":"This is a test to ensure you have set up the node properly. It will return the current addresses in the wallet. In the panel at http://127.0.0.1:9053/panel click on the Wallet tab on the left and then on Get all wallet addresses to view the addresses currently maintained by the wallet. It should return at least one address if the node is set correctly.","title":"Get wallet addresses"},{"location":"dev/node/run/#check-if-the-node-is-synced","text":"While the node is syncing, the panel will show \"Active synchronization\" (see the image below). After the node is fully synced, the text will change to \"Node is synced\", as shown below.","title":"Check if the node is synced"},{"location":"dev/node/run/#check-wallet-balance","text":"Once the node is synced, use the wallet API in the panel to see your balance, as shown below.","title":"Check wallet balance"},{"location":"dev/node/run/#sending-funds","text":"If there is a non-zero balance, you can send Ergs to any other address using the panel as shown below:","title":"Sending funds"},{"location":"dev/node/run/#view-the-swagger-ui","text":"A Swagger UI is available at http://127.0.0.1:9053/swagger . You had already used it earlier to compute the hash of your secret. You can also use this UI to make API calls for advanced operations that are not (yet) available in the panel. Some examples of this are: Creating non-standard transactions with registers and context variables. Creating transactions that issue tokens. Creating transactions that use certain boxes as inputs. A future article will discuss each of these operations in detail. Note that most methods in the API are protected and you would need to use your secret (from earlier) to access these methods. The following images show the process of setting this secret in the Swagger UI. Navigate to the top of the page and click the \"Authorize\" button. Enter your secret in the form that pops-up as shown in the figure below. After the password is entered and you have clicked \"Authorize\", you will be shown the popup below: Now navigate to http://127.0.0.1:9053/swagger#/wallet/walletAddresses in the same tab where you entered the password and click on \"Try it out\". You should see the same list of addresses as you saw earlier from the panel.","title":"View the Swagger UI"},{"location":"dev/p2p/p2p-handshake/","text":"Handshaking To establish a connection with another peer, handshake messages exchange is needed in the first place. This document describes handshaking procedure and messages format. Peer Feature Every peer can have one or more peer features. A peer feature describes some properties of a peer. Features are embedded into a handshake message and remain unchanged during the connection. Features are optional by default: a peer can add new ones, and if another peer is not recognizing it, the feature will be skipped. Feature format is arbitrary. Any number of features can be added to the handshake, only handshake message has size limit (8 KB). The only feature the reference client supported before 3.3.7 is \"mode feature\" (describing operating regime of the peer). Since 3.3.7, a new feature describing network magic and (pseudorandom) session id added Handshake Format Length Field Name Details 6-8 Time Reported handshake time (VLQ-encoded, 6 bytes now, 8 bytes max) 1 Agent name length Length of agent name string (unsigned byte) 0-255 Agent name Agent name (e.g. \"Cypra wallet\") in UTF-8 encoding, 255 bytes max 3 Network protocol version Protocol version (e.g. [0, 1, 1] 1 Peer name length Length of peer name string 0-255 Peer name Peer name (e.g. \"kushti's node\") in UTF-8 encoding, 255 bytes max 1 Public node flag Flag indicating whether the node has a public address (0 or 1) (1) Public address length Length of public address (*) Public address Public IP address bytes, IPv4 of IPv6, 4 or 6 bytes, see Note 2 (4) Public address port Public address port 1 Number of peer features How many features are encoded further (unsigned byte) * Features Serialized features, one after another (specified below) For client capabilities (Mode feature): | Length | Field Name | Details | | :------------ | :------------------------------------- | :----------- | |1 | Feature id | for mode feature = 16 | |1-2 | Feature body length | Length of feature description (VLQ-encoded, up to 2 bytes)| |1 | State type | State representation, 0 = utxo, 1 = digest | |1 | Whether the peer verifying transactions | 1 = transactions being verified, 0 = not verified | |1 | Whether the node bootstrapped via NiPoPoW | 1 if yes, 0 if no (then following field is missed) | |(4) | Nipopow suffix length | Suffix length for NiPoPoW bootstrapping | |1-4 | How many block kept | signed integer (ZigZag then VLQ encoded), if -1 then all the blocks are stored | For session peer feature introduced in 3.3.7: Length Field Name Details 1 Feature id for session feature = 3 1-2 Feature body length Length of feature description (VLQ-encoded, up to 2 bytes) 4 Network magic Network magic bytes, see notes 8 Session id 64 bits long random session id Notes: 1. For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). 2. For IPv4 or IP6 address bytes, \"The result is in network byte order: the highest order byte of the address is in \"getAddress()[0]\". Please check Inet4Address.getAddress() or Inet4Address.getAddress() in Java's JDK for details. 3. For reference client, session id is currently used only to avoid connections to self Handshake Procedure A peer is sending a handshake message, another replies. If there's no handshake got within \"handshakeTimeout\", then connection is dropped. Default value for handshakeTimeout = 30s","title":"P2P Handshaking"},{"location":"dev/p2p/p2p-handshake/#handshaking","text":"To establish a connection with another peer, handshake messages exchange is needed in the first place. This document describes handshaking procedure and messages format.","title":"Handshaking"},{"location":"dev/p2p/p2p-handshake/#peer-feature","text":"Every peer can have one or more peer features. A peer feature describes some properties of a peer. Features are embedded into a handshake message and remain unchanged during the connection. Features are optional by default: a peer can add new ones, and if another peer is not recognizing it, the feature will be skipped. Feature format is arbitrary. Any number of features can be added to the handshake, only handshake message has size limit (8 KB). The only feature the reference client supported before 3.3.7 is \"mode feature\" (describing operating regime of the peer). Since 3.3.7, a new feature describing network magic and (pseudorandom) session id added","title":"Peer Feature"},{"location":"dev/p2p/p2p-handshake/#handshake-format","text":"Length Field Name Details 6-8 Time Reported handshake time (VLQ-encoded, 6 bytes now, 8 bytes max) 1 Agent name length Length of agent name string (unsigned byte) 0-255 Agent name Agent name (e.g. \"Cypra wallet\") in UTF-8 encoding, 255 bytes max 3 Network protocol version Protocol version (e.g. [0, 1, 1] 1 Peer name length Length of peer name string 0-255 Peer name Peer name (e.g. \"kushti's node\") in UTF-8 encoding, 255 bytes max 1 Public node flag Flag indicating whether the node has a public address (0 or 1) (1) Public address length Length of public address (*) Public address Public IP address bytes, IPv4 of IPv6, 4 or 6 bytes, see Note 2 (4) Public address port Public address port 1 Number of peer features How many features are encoded further (unsigned byte) * Features Serialized features, one after another (specified below) For client capabilities (Mode feature): | Length | Field Name | Details | | :------------ | :------------------------------------- | :----------- | |1 | Feature id | for mode feature = 16 | |1-2 | Feature body length | Length of feature description (VLQ-encoded, up to 2 bytes)| |1 | State type | State representation, 0 = utxo, 1 = digest | |1 | Whether the peer verifying transactions | 1 = transactions being verified, 0 = not verified | |1 | Whether the node bootstrapped via NiPoPoW | 1 if yes, 0 if no (then following field is missed) | |(4) | Nipopow suffix length | Suffix length for NiPoPoW bootstrapping | |1-4 | How many block kept | signed integer (ZigZag then VLQ encoded), if -1 then all the blocks are stored | For session peer feature introduced in 3.3.7: Length Field Name Details 1 Feature id for session feature = 3 1-2 Feature body length Length of feature description (VLQ-encoded, up to 2 bytes) 4 Network magic Network magic bytes, see notes 8 Session id 64 bits long random session id Notes: 1. For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). 2. For IPv4 or IP6 address bytes, \"The result is in network byte order: the highest order byte of the address is in \"getAddress()[0]\". Please check Inet4Address.getAddress() or Inet4Address.getAddress() in Java's JDK for details. 3. For reference client, session id is currently used only to avoid connections to self","title":"Handshake Format"},{"location":"dev/p2p/p2p-handshake/#handshake-procedure","text":"A peer is sending a handshake message, another replies. If there's no handshake got within \"handshakeTimeout\", then connection is dropped. Default value for handshakeTimeout = 30s","title":"Handshake Procedure"},{"location":"dev/p2p/p2p-protocol/","text":"Handshake First of all, nodes are doing handshaking by sending each other handshake messages. Handshaking details are provided in dedicated P2P Handshaking doc Message format Every message in P2P protocol has the following format: Length Field Name Details 4 Magic bytes Network-specific magic bytes, see Note 1. 1 Message code One byte describing message type 4 Message body length Length of handshake body (specified below), as signed 32-bit integer 4 Handshake body checksum First four bytes of blake2b(message body) * Message body Message body (specified below) Notes: 1. For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). 2. No VLQ and ZigZag encoding is used for message length (for historical reasons), bytes are coming in big-endian order. [TODO: provide descriptions for possible values of message body] Syncing","title":"P2P Protocol"},{"location":"dev/p2p/p2p-protocol/#handshake","text":"First of all, nodes are doing handshaking by sending each other handshake messages. Handshaking details are provided in dedicated P2P Handshaking doc","title":"Handshake"},{"location":"dev/p2p/p2p-protocol/#message-format","text":"Every message in P2P protocol has the following format: Length Field Name Details 4 Magic bytes Network-specific magic bytes, see Note 1. 1 Message code One byte describing message type 4 Message body length Length of handshake body (specified below), as signed 32-bit integer 4 Handshake body checksum First four bytes of blake2b(message body) * Message body Message body (specified below) Notes: 1. For the testnet, magic bytes are [2, 0, 0, 1] (in decimal). For mainnet, [1, 0, 2, 4] (in decimal). 2. No VLQ and ZigZag encoding is used for message length (for historical reasons), bytes are coming in big-endian order. [TODO: provide descriptions for possible values of message body]","title":"Message format"},{"location":"dev/p2p/p2p-protocol/#syncing","text":"","title":"Syncing"},{"location":"dev/protocol/address/","text":"Addresses In today's article, we will have a closer look into the Ergo address formatting. In addition to that, we will explain how they work specifically, as well as what makes them preferable to other types of blockchain addresses. Let's start at the very beginning. The moment you install any cryptocurrency wallet, you automatically create an address with it. Very loosely speaking, you can compare a wallet to a traditional bank account and an address to the matching account number. It is precisely one of these alphanumeric addresses needed to either send money from person A to person B, receive money, or withdraw your mining rewards . If you want to start using the Ergo wallet and dive deeper into its functions, check out the the following link . Now, what exactly are addresses? Addresses are short strings that correspond to specific scripts and are used to protect a box ( this post that core developer kushti published on our forum explains very well what a \"box\" is). Unlike a (hex-encoded) binary representation of a script, an Ergo address use a Base58-encoding and therefore have some advantageous characteristics to it which the binary representation does not offer: We can quickly check the integrity of an address via an integrated checksum (which is a \"small-sized datum derived from a block of digital data to detect errors that may have been introduced during its transmission or storage\" according to Wikipedia). A prefix of the address shows you the network and address type. In particular, the network prefix prevents you from mistakenly sending mainnet tokens to the testnet address. The address uses an encoding (namely, Base58 as mentioned) that avoids similarly-looking characters and is friendly to double-clicking and line-breaking in emails. An address encodes network type, address type, checksum, and enough information to correspond with particular scripts. Let's look at the prefix byte, which contains information about the network and address types: Possible network types are: Mainnet - 0x00 Testnet - 0x10 Address types are (semantics described below): 0x01 - Pay-to-PublicKey(P2PK) address 0x02 - Pay-to-Script-Hash(P2SH) 0x03 - Pay-to-Script(P2S) For an address type, we form content bytes as follows: P2PK - serialized (compressed) public key P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes P2S - serialized script (this is where mining rewards go!) For example, sending 10 Ergs to a P2PK address usually means that a corresponding transaction will contain a box in which 10 Ergs are locked by a public key encoded in the P2PK address. Similarly, in the case of a P2S address, the box will be locked by a script encoded in the address. In the most complicated case of a P2SH script, the box will be protected by a special predefined script that takes the first 192 bits of Blake2b256 hash value for a script shown by an input spending the box. Here is an example of how particular addresses are going to look on the testnet: 3 - P2PK ( 3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN ) ? - P2SH ( rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB ) ? - P2S ( Ms7smJwLGbUAjuWQ ) And here is how what they look like on the mainnet: 9 - P2PK ( 9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA ) ? - P2SH ( 8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg ) ? - P2S ( 4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ ) In summary: Prefix byte = network type + address type (for example, P2S script on the testnet starts with 0x13 before Base58) checksum = leftmost_4_bytes (blake2b256 (prefix byte || content bytes)) address = prefix byte || content bytes || checksum","title":"Adresses"},{"location":"dev/protocol/address/#addresses","text":"In today's article, we will have a closer look into the Ergo address formatting. In addition to that, we will explain how they work specifically, as well as what makes them preferable to other types of blockchain addresses. Let's start at the very beginning. The moment you install any cryptocurrency wallet, you automatically create an address with it. Very loosely speaking, you can compare a wallet to a traditional bank account and an address to the matching account number. It is precisely one of these alphanumeric addresses needed to either send money from person A to person B, receive money, or withdraw your mining rewards . If you want to start using the Ergo wallet and dive deeper into its functions, check out the the following link . Now, what exactly are addresses? Addresses are short strings that correspond to specific scripts and are used to protect a box ( this post that core developer kushti published on our forum explains very well what a \"box\" is). Unlike a (hex-encoded) binary representation of a script, an Ergo address use a Base58-encoding and therefore have some advantageous characteristics to it which the binary representation does not offer: We can quickly check the integrity of an address via an integrated checksum (which is a \"small-sized datum derived from a block of digital data to detect errors that may have been introduced during its transmission or storage\" according to Wikipedia). A prefix of the address shows you the network and address type. In particular, the network prefix prevents you from mistakenly sending mainnet tokens to the testnet address. The address uses an encoding (namely, Base58 as mentioned) that avoids similarly-looking characters and is friendly to double-clicking and line-breaking in emails. An address encodes network type, address type, checksum, and enough information to correspond with particular scripts. Let's look at the prefix byte, which contains information about the network and address types: Possible network types are: Mainnet - 0x00 Testnet - 0x10 Address types are (semantics described below): 0x01 - Pay-to-PublicKey(P2PK) address 0x02 - Pay-to-Script-Hash(P2SH) 0x03 - Pay-to-Script(P2S) For an address type, we form content bytes as follows: P2PK - serialized (compressed) public key P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes P2S - serialized script (this is where mining rewards go!) For example, sending 10 Ergs to a P2PK address usually means that a corresponding transaction will contain a box in which 10 Ergs are locked by a public key encoded in the P2PK address. Similarly, in the case of a P2S address, the box will be locked by a script encoded in the address. In the most complicated case of a P2SH script, the box will be protected by a special predefined script that takes the first 192 bits of Blake2b256 hash value for a script shown by an input spending the box. Here is an example of how particular addresses are going to look on the testnet: 3 - P2PK ( 3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN ) ? - P2SH ( rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB ) ? - P2S ( Ms7smJwLGbUAjuWQ ) And here is how what they look like on the mainnet: 9 - P2PK ( 9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA ) ? - P2SH ( 8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg ) ? - P2S ( 4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ ) In summary: Prefix byte = network type + address type (for example, P2S script on the testnet starts with 0x13 before Base58) checksum = leftmost_4_bytes (blake2b256 (prefix byte || content bytes)) address = prefix byte || content bytes || checksum","title":"Addresses"},{"location":"dev/protocol/autolykos/","text":"Autolykos Security of Proof-of-Work blockchains relies on multiple miners trying to produce new blocks by participating in a PoW puzzle lottery , and the network is secure if the majority of them are honest. However, the reality becomes much more complicated than the original one-CPU-one-vote idea from the Bitcoin whitepaper. The first threat to decentralization came from mining pools \u2013 miners tend to unite in mining pools. Regardless of the PoW algorithm number of pools controlling more then 50% of computational power is usually quite small: 4 pools in Bitcoin, 2 in Ethereum, 3 in ZCash, etc. This problem led to the notion of non-outsourceable puzzles. These are the puzzles constructed in such a way that if a mining pool outsources the puzzle toa miner, miner can recover pool\u2019s private key and steal the reward witha non-negligible probability. However the existing solutions either have too large solution size (kilobyte is already on the edge of acceptability fordistributed ledgers) or very specific and can not be modified or extendedin any way without breaking non-outsourceability. The second threat to cryptocurrencies decentralization is that ASIC-equipped miners are able to find PoW solutions orders of magnitude fasterand more efficiently than miners equipped with the commodity hardware. In order to reduce the disparity between the ASICs and regular hardware,memory-bound computations where proposed in. The most interesting practical examples are two asymmetric memory-hard PoW schemes which require significantly less memory to verify a solution than to find it. Despite the fact that ASICs already exist for both of them, they remain the only asymmetric memory-hard PoW algorithms in use. Autolykos v.2 is briefly described at Overview of Ergo PoW called Autolykos (2019) Autolykos: The Ergo Platform PoW Puzzle v.2 Autolykos v.2 is following Autolykos v.1, but with certain modifications made: non-outsourceability switched off. It turns out (based on more than 1 year of non-outsourceable PoW experience) that non-outsourceable PoW is not attractive to small miners. now algorithm is trying to bind an efficient solving procedure with a single table of ~2 GB (initially), which is significantly reducing memory optimizations possibilities table size (memory requirements of a solving algorithm) grows with time The table depends solely on the block height, so there is no penalization for recalculating block candidate for the same height Basic Ideas: Like Autlykos-1, based on k-sum problem, so a miner needs to finds k (k=32) out of N (2^n = 2^26) elements, and hash of their sum must be less than target value (inverse of difficulty) k indexes are pseudorandom values derived from block candidate and nonce N elements are derived from block height and constants just, unlike Autolykos v.1, so miners can recalculate block candidates easily now (so only indexes are depending on them) Indexes calculation also involving the same table (which elements are last 31 bytes of H(i | | h | | M ), where i is in [0, N), h is block height, M is padding to slow down hash calculation (8kb of constant data). So algorithm trying to make mining efficient for ones who store the table which size is 2^26 * 31 = 2,080,374,784 bytes initially (about 2GB). Thus algo now is friendly to all the GPUs basically. Also, table size (N value) is growing with time as follows. Until block 614,400, N = 2^{26} = 67,108,864 elements (31 bytes each). From this block, and until block 4,198,400, every 51,200 blocks N is increased by 5 percent. Since block 4,198,400, value of N is fixed and equals to 2,143,944,600. Test vectors for N values are provided in the paper. (https://www.docdroid.net/mcoitvK/ergopow-pdf) https://eprint.iacr.org/2020/044.pdf 51% Attack Mining pools offer a buffer against such network attacks as the hash rate is distributed across thousands of individual miners. The memory hardened aspect of ergo also makes this vector of attack more expensive as there is no ASIC support to rent. With the collective rentable rigs at the moment this isnt a viable path to a 51% attack. In theory, someone could build a massive GPU farm to try to launch such an attack. If a bad actor can rent a warehouse of ASIC and mine on a small chain with 51% attacks are a viable option... if there is an offramp. Usually, this attack is done for profit and there is massive dumping that occurs on an exchange as it is occuring. Meaning the attacker is going to dump tokens on an exchange then \"double-spend\" them back into their wallet. The current exchange situation doesn't provide the liquidity for a viable offramp. The rentable ASIC support isn't an option. So is it possible, in theory, yes, practical or likely I dont think so at all. Ethereum classic is perhaps a bad example, as it shares the same mining algorithm as Eth. One could buy more than 100% existing hashrate of eth classic on NiceHash. It's not the same case for Ergo. Ergo also believes in the 'Good Miner' principle, In the case of Bitcoin - it was a good thing 51% existed. Autolykos v1 originally had non-outsourcability built-in, however, it became apparent that with smart contracts it's basically impossible to prevent pools, so they turned it off so that not only larger players were able to take advantage of the loophole. Ergo is now focusing on memory hardness in an attempt to keep mining as fair as possible, which should help prevent ASICs mining at least. There are also some improvements for pooling, e.g. Stratum 2 protocol \u201cBypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts\u201d https://ia.cr/2020/044 was presented by Alex Chepurnoy at WTSC workshop associated with Financial Cryptography and Data Security 2020 in Malaysia It's also discussed here on 'Unblocked with Robert Kornacki' (14:45)","title":"Autolykos"},{"location":"dev/protocol/autolykos/#autolykos","text":"Security of Proof-of-Work blockchains relies on multiple miners trying to produce new blocks by participating in a PoW puzzle lottery , and the network is secure if the majority of them are honest. However, the reality becomes much more complicated than the original one-CPU-one-vote idea from the Bitcoin whitepaper. The first threat to decentralization came from mining pools \u2013 miners tend to unite in mining pools. Regardless of the PoW algorithm number of pools controlling more then 50% of computational power is usually quite small: 4 pools in Bitcoin, 2 in Ethereum, 3 in ZCash, etc. This problem led to the notion of non-outsourceable puzzles. These are the puzzles constructed in such a way that if a mining pool outsources the puzzle toa miner, miner can recover pool\u2019s private key and steal the reward witha non-negligible probability. However the existing solutions either have too large solution size (kilobyte is already on the edge of acceptability fordistributed ledgers) or very specific and can not be modified or extendedin any way without breaking non-outsourceability. The second threat to cryptocurrencies decentralization is that ASIC-equipped miners are able to find PoW solutions orders of magnitude fasterand more efficiently than miners equipped with the commodity hardware. In order to reduce the disparity between the ASICs and regular hardware,memory-bound computations where proposed in. The most interesting practical examples are two asymmetric memory-hard PoW schemes which require significantly less memory to verify a solution than to find it. Despite the fact that ASICs already exist for both of them, they remain the only asymmetric memory-hard PoW algorithms in use. Autolykos v.2 is briefly described at Overview of Ergo PoW called Autolykos (2019) Autolykos: The Ergo Platform PoW Puzzle","title":"Autolykos"},{"location":"dev/protocol/autolykos/#v2","text":"Autolykos v.2 is following Autolykos v.1, but with certain modifications made: non-outsourceability switched off. It turns out (based on more than 1 year of non-outsourceable PoW experience) that non-outsourceable PoW is not attractive to small miners. now algorithm is trying to bind an efficient solving procedure with a single table of ~2 GB (initially), which is significantly reducing memory optimizations possibilities table size (memory requirements of a solving algorithm) grows with time The table depends solely on the block height, so there is no penalization for recalculating block candidate for the same height Basic Ideas: Like Autlykos-1, based on k-sum problem, so a miner needs to finds k (k=32) out of N (2^n = 2^26) elements, and hash of their sum must be less than target value (inverse of difficulty) k indexes are pseudorandom values derived from block candidate and nonce N elements are derived from block height and constants just, unlike Autolykos v.1, so miners can recalculate block candidates easily now (so only indexes are depending on them) Indexes calculation also involving the same table (which elements are last 31 bytes of H(i | | h | | M ), where i is in [0, N), h is block height, M is padding to slow down hash calculation (8kb of constant data). So algorithm trying to make mining efficient for ones who store the table which size is 2^26 * 31 = 2,080,374,784 bytes initially (about 2GB). Thus algo now is friendly to all the GPUs basically. Also, table size (N value) is growing with time as follows. Until block 614,400, N = 2^{26} = 67,108,864 elements (31 bytes each). From this block, and until block 4,198,400, every 51,200 blocks N is increased by 5 percent. Since block 4,198,400, value of N is fixed and equals to 2,143,944,600. Test vectors for N values are provided in the paper. (https://www.docdroid.net/mcoitvK/ergopow-pdf) https://eprint.iacr.org/2020/044.pdf","title":"v.2"},{"location":"dev/protocol/autolykos/#51-attack","text":"Mining pools offer a buffer against such network attacks as the hash rate is distributed across thousands of individual miners. The memory hardened aspect of ergo also makes this vector of attack more expensive as there is no ASIC support to rent. With the collective rentable rigs at the moment this isnt a viable path to a 51% attack. In theory, someone could build a massive GPU farm to try to launch such an attack. If a bad actor can rent a warehouse of ASIC and mine on a small chain with 51% attacks are a viable option... if there is an offramp. Usually, this attack is done for profit and there is massive dumping that occurs on an exchange as it is occuring. Meaning the attacker is going to dump tokens on an exchange then \"double-spend\" them back into their wallet. The current exchange situation doesn't provide the liquidity for a viable offramp. The rentable ASIC support isn't an option. So is it possible, in theory, yes, practical or likely I dont think so at all. Ethereum classic is perhaps a bad example, as it shares the same mining algorithm as Eth. One could buy more than 100% existing hashrate of eth classic on NiceHash. It's not the same case for Ergo. Ergo also believes in the 'Good Miner' principle, In the case of Bitcoin - it was a good thing 51% existed. Autolykos v1 originally had non-outsourcability built-in, however, it became apparent that with smart contracts it's basically impossible to prevent pools, so they turned it off so that not only larger players were able to take advantage of the loophole. Ergo is now focusing on memory hardness in an attempt to keep mining as fair as possible, which should help prevent ASICs mining at least. There are also some improvements for pooling, e.g. Stratum 2 protocol \u201cBypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts\u201d https://ia.cr/2020/044 was presented by Alex Chepurnoy at WTSC workshop associated with Financial Cryptography and Data Security 2020 in Malaysia It's also discussed here on 'Unblocked with Robert Kornacki' (14:45)","title":"51% Attack"},{"location":"dev/protocol/box/","text":"Box A UTXO is short for unspent transaction output. We can also consider spent transaction outputs (UTXOs that have been spent). In Ergo, a transaction output (whether spent or unspent) is called a box. A box, at the minimum, has four pieces of information. The value in NanoErgs (1 Erg = 1000000000 NanoErgs). The guard script (like scriptPubKey of Bitcoin). This is also called the \"smart contract.\" Additional assets (tokens) are stored in this box. Creation info of the box (txId, the identifier of the transaction that created the box along with an output index). It also contains a \"maxCreation\" height parameter defined by the box creator (this is not the creation height; its use is to create \"payment channels easily\"). These are stored in the first four registers (numbered R0-R3) of the box. In addition, a box can have six optional registers (R4-R9) to store custom data for use in smart contracts. Registers must be densely packed; that is, we cannot sandwich empty registers between non-empty ones. The optional registers can contain data of any of the following types: Int, Long with the usual semantics of Scala. BigInt, which is a 256-bit integer (i.e., all computation is done modulo 2^256). GroupElement, a point on the Secp256k1 curve represented in compressed format. Coll[Byte], a collection of bytes, semantically similar to Array[Byte] in Scala. Collection of the above, i.e., Coll[Int], Coll[GroupElement], Coll[Coll[Byte]], etc. A boxId is calculated based on the contents of all the registers. This boxId uniquely defines a box and can be considered equivalent to Bitcoin's (txId, vOut) pairs. Note that Ergo txId depends only on the message and not on signatures (similar to Bitcoin SegWit transactions). Hence, a txId is available even before signing. Similar to Bitcoin, Ergo supports chained transactions (i.e., spending of boxes with 0 confirmations). Anatomy of an Ergo transaction Articles UTXO Model Transaction Off-chain Logic and eUTXO An Ergo transaction consists of: One or more Input boxes (source of funds). These boxes must already exist and will be destroyed. The guard script in each of these boxes will be evaluated and must return true for the transaction to be considered valid, One or more Output boxes (destination of funds). These boxes will be created. Zero or more Data-Inputs boxes. These are additional boxes whose data can be referenced and used by smart contracts of the inputs. The guard script in these boxes will not be evaluated. Data inputs are unique to Ergo and not yet present in other extended-UTXO systems. Multiple transactions can share a data-input box, and it will store only a single reference to the box in the block. We can also spend a data-input box in the same transaction as long as it existed before the transaction was applied. As an example, the box with id d2b9b6536287b242f436436ce5a1e4a117d7b4843a13ce3abe3168bff99924a1 was used as both an input and a data-input in this transaction. While the use of data-inputs may not be immediately apparent, they play a major role in making Ergo more friendly to DeFi applications where we want to refer to a box without needing (or having the ability) to spend it such as in decentralized order-books (DEX). For instance, the above transaction used a \"timestamping service\" to timestamp a box provided as data input. A script in Ergo can refer to other boxes in the transaction. For instance, the code snippet INPUTS(0).value > 10000 && OUTPUTS(1).value > 20000 in any of the inputs boxes would enforce that the first input and the second output boxes must have a value greater than 10000 and 20000, respectively.","title":"Box"},{"location":"dev/protocol/box/#box","text":"A UTXO is short for unspent transaction output. We can also consider spent transaction outputs (UTXOs that have been spent). In Ergo, a transaction output (whether spent or unspent) is called a box. A box, at the minimum, has four pieces of information. The value in NanoErgs (1 Erg = 1000000000 NanoErgs). The guard script (like scriptPubKey of Bitcoin). This is also called the \"smart contract.\" Additional assets (tokens) are stored in this box. Creation info of the box (txId, the identifier of the transaction that created the box along with an output index). It also contains a \"maxCreation\" height parameter defined by the box creator (this is not the creation height; its use is to create \"payment channels easily\"). These are stored in the first four registers (numbered R0-R3) of the box. In addition, a box can have six optional registers (R4-R9) to store custom data for use in smart contracts. Registers must be densely packed; that is, we cannot sandwich empty registers between non-empty ones. The optional registers can contain data of any of the following types: Int, Long with the usual semantics of Scala. BigInt, which is a 256-bit integer (i.e., all computation is done modulo 2^256). GroupElement, a point on the Secp256k1 curve represented in compressed format. Coll[Byte], a collection of bytes, semantically similar to Array[Byte] in Scala. Collection of the above, i.e., Coll[Int], Coll[GroupElement], Coll[Coll[Byte]], etc. A boxId is calculated based on the contents of all the registers. This boxId uniquely defines a box and can be considered equivalent to Bitcoin's (txId, vOut) pairs. Note that Ergo txId depends only on the message and not on signatures (similar to Bitcoin SegWit transactions). Hence, a txId is available even before signing. Similar to Bitcoin, Ergo supports chained transactions (i.e., spending of boxes with 0 confirmations).","title":"Box"},{"location":"dev/protocol/box/#anatomy-of-an-ergo-transaction","text":"Articles UTXO Model Transaction Off-chain Logic and eUTXO An Ergo transaction consists of: One or more Input boxes (source of funds). These boxes must already exist and will be destroyed. The guard script in each of these boxes will be evaluated and must return true for the transaction to be considered valid, One or more Output boxes (destination of funds). These boxes will be created. Zero or more Data-Inputs boxes. These are additional boxes whose data can be referenced and used by smart contracts of the inputs. The guard script in these boxes will not be evaluated. Data inputs are unique to Ergo and not yet present in other extended-UTXO systems. Multiple transactions can share a data-input box, and it will store only a single reference to the box in the block. We can also spend a data-input box in the same transaction as long as it existed before the transaction was applied. As an example, the box with id d2b9b6536287b242f436436ce5a1e4a117d7b4843a13ce3abe3168bff99924a1 was used as both an input and a data-input in this transaction. While the use of data-inputs may not be immediately apparent, they play a major role in making Ergo more friendly to DeFi applications where we want to refer to a box without needing (or having the ability) to spend it such as in decentralized order-books (DEX). For instance, the above transaction used a \"timestamping service\" to timestamp a box provided as data input. A script in Ergo can refer to other boxes in the transaction. For instance, the code snippet INPUTS(0).value > 10000 && OUTPUTS(1).value > 20000 in any of the inputs boxes would enforce that the first input and the second output boxes must have a value greater than 10000 and 20000, respectively.","title":"Anatomy of an Ergo transaction"},{"location":"dev/protocol/nipopow/","text":"NiPoPoWs Several years have been spent researching and developing secure protocols that allow for efficient SPV clients. The two best-known and most reliable protocols are NiPoPoWs and FlyClient. Ergo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. You can explore this technology in full on nipopows.com Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) are short stand-alone strings that a computer program can inspect to verify that an event happened on a proof-of-work-based blockchain without connecting to the blockchain network and without downloading all block headers. For example, these proofs can illustrate that a cryptocurrency payment was made. Light Clients You might want to run a full node. If you're a miner, this will require that you download the entire blockchain because you'll need the whole UTXO (unspent outputs) set to mine new blocks. But you can still run a full node without that UTXO set \u2013 vastly reducing the specification and expense of the hardware needed. Blocks In Ergo, just like Bitcoin, Ethereum, and other blockchains, blocks are broken into sections. In Bitcoin, there's simply a block header and the transactions themselves. But in Ergo, we have some extra sections that enable new functionality: Header Transactions Extensions Proofs of UTXO transformation The 'extension' section contains certain mandatory fields (including links for NiPoPoW, once per 1,024 block epoch) and parameters for miner voting, such as current block size. It can also contain arbitrary fields. What this means in practice is that different types of nodes and clients can download only those sections of the blocks they need \u2013 reducing the demands for storage, bandwidth, and CPU cycles. Lite full nodes While miners need to download everything, lite full nodes only need the transactions and proofs. This means they have a cryptographic guarantee of transactions without holding the complete UTXO set itself. Lite full nodes check the proofs generated by full nodes (including miners) who hold the whole blockchain, guaranteeing ledger validity. In Ethereum, these nodes are called Stateless Clients. For Ergo, it means you can run a full node and maintain the network with a device as simple as a Raspberry Pi with 512 MB RAM. This provides the ideal balance between ensuring the network's security and placing an unnecessary burden on users who wish to do so \u2013 improving decentralisation and democratising participation in the Ergo network and community. Light Clients Light Clients (aka SPV ) are essential when considering the hurdles cryptocurrency faces with mass adoption. Most crypto users do not have the necessary tools to run a full node. Running a full node means having a strong processor with high electricity wattage and more than a hundred gigabytes of memory to store the entire blockchain. Light clients are useful because they enable verification with a limited supply of data providers (nodes) and significantly reduce the amount of data storage and bandwidth needed for everyday users. The use of light clients with the implementation of NIPoPoWs makes it possible to interact with the blockchain through block headers by using only a couple of kilobytes. Verifying whether a transaction happened on the blockchain becomes simplified. NIPoPoWs can help people interact with the blockchain by using more efficient and convenient mobile wallets. NIPoPoWs allow very efficient mobile wallets to be created. SPV wallets are already very lightweight compared to full nodes because they only require the download of block headers, not the whole blockchain. NIPoPoW wallets need to download only a small sample of block headers, around 250, when SPV clients need to download half a million block headers. The sample needed changes but doesn't grow much in size as the blockchain grows larger over the years, even after decades of data has been accumulated. This enables Ergo to build a mobile SPV client that requires around just 100KB of block headers to be downloaded. A super-efficient Ergo wallet with SPV security is in development, so stay tuned for more updates! Building Ergo: SPV security SPV Security _ There's often tension in the crypto world between security and convenience. That trade-off is unacceptable if we want these technologies to be widely used. Here's how Ergo addresses one common and critical issue._ We all know that the most secure way to use Bitcoin, or any crypto, is to download a copy of the blockchain and run a full node yourself. That way, every time you or anyone else makes a transaction, your client checks the blockchain to ensure it's valid. You don't have to trust anyone else. A full Bitcoin node checks all the blocks in the blockchain (using headers) and makes sure there are no fraudulent transactions. It's a very secure way of using crypto \u2013 but there's a problem. It requires significant bandwidth, storage, and processing power. That kind of commodity hardware is expensive, and using a full node to validate and make transactions is in any case unsuitable for mobile devices. This is particularly true for Bitcoin, where the blockchain is over 270 GB and counting . SPV Simplified Payment Verification (SPV) is designed to address this problem, as described in the Bitcoin white paper : It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it and blocks added after it further confirms the network has accepted it. Satoshi notes that this is not a perfect solution and is vulnerable to an attacker overpowering the network and fooling SPV users. Moreover, while SPV mode is intended for resource-limited devices, even this 'lite' approach is not always feasible. Ethereum's headers alone total around 5 GB to download. Thus Ethereum mobile clients do not validate chain validity and so blindly have to trust third parties. There are proposals to reduce the requirements for SPV mode by checking just a few random headers instead of all of them. But it's hard to do that securely. Efficient SPV Several years have been spent researching and developing secure protocols that allow for efficient SPV clients. The two best-known and most reliable protocols are NiPoPoWs and FlyClient. Ergo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. You can explore this technology in full on this dedicated website: https://nipopows.com : Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) are short stand-alone strings that a computer program can inspect to verify that an event happened on a proof-of-work-based blockchain without connecting to the blockchain network and without downloading all block headers. For example, these proofs can illustrate that a cryptocurrency payment was made. NIPoPoWs allow very efficient mobile wallets to be created. SPV wallets are already very lightweight compared to full nodes because they only require the download of block headers, not the whole blockchain. NIPoPoW wallets need to download only a tiny sample of block headers, around 250 when SPV clients need to download half a million block headers. The sample needed changes but doesn't grow much in size as the blockchain grows more extensive over the years, even after accumulated decades of data. This enables us to build a mobile SPV client that requires around just 100KB of block headers to be downloaded. A super-efficient Ergo wallet with SPV security is in development, so stay tuned for more updates! Log-Space Mining Dionysis Zindros explains the technical landscape of Non-Interactive Proofs of Proof-of-Work. Dionysis takes a diligent approach for the Ergo Cast with a detailed rundown of what Non-Interactive Proofs of Proof-of-Work truly are. Furthermore, Dionysis evaluates the operation, implementation, and impact that his primitive delivers upon. Furthermore, we unveil a brand-new piece of research that -as of yet- has never been shared publicly: log-space mining. NiPoPoWs & Log-Space Mining \u2013 Ergo Cast Episode #5 This article is based on a recently published article by IOHK. For an additional resource, please see the following video. Whether it is Ergo, Bitcoin, or another PoW consensus model, miners must constantly maintain the blockchain. In addition to using computational resources, miners also use storage resources that maintain all blockchain data from the genesis block. A new miner's problem: Is downloading all the data from the genesis block strictly necessary? Why is it not possible to download only the most relevant blocks to maintain the network? The block headers of the blockchain should be enough to access the necessary data. NIPoPoWs (Non-Interactive Proofs of Proof of Work) can be integrated to form interlinked block header sets that will reduce historical data storage. When needing to access key blocks in the blockchain, miners should be able to efficiently do this from the headers of the old blocks. That is because each new block must indicate all of the current networks. As new blocks are created, a set of new block headers can be enough to check for the current UTXO set. Since the new blocks contain the data of old stringed block header sets, it enables light mining by eliminating the need to download all the blockchain data. What are we trying to optimize by stringing old PoW history and compiling it into a snapshot? If we say C=old blocks and K=new blocks, then included blocks in the snapshot can be growing when K=new blocks are constant, and C=old blocks are linear. But it can also be shrinking depending on the smart contract applications. The problem of maintaining heavy loads of data by the miners can be solved by bootstrapping through NIPoPoWs. NIPoPoW Implementation Instead of accessing all of the blocks, superblocks (or light-clients) are enough to verify all of the blocks. This is accomplished by maintaining the historical data of the blockchain through smart contracts. The introduction of these superblock clients on NIPoPoWs can be done via 'velvet' or soft forks, and after that \"light\" miners can bootstrap through \"online\" mining. NIPoPoWs enable smart contracts to maintain historical data so that new \"light\" miners can work in a so-called \"online\" fashion. This is the main idea of Logarithmic Space Mining, where instead of saving all the blockchain data locally on nodes, the unnecessary part of it can be compiled into the blockchain itself. New miners do not need to carry the historical data, and as they continue to mine, new \"light\" miners will help other \"light\" miners bootstrap. There will be no need to carry old historical data, and old miners can abandon historical data for lighter mining. This is how the whole miner population can abandon old blocks and make the system much more efficient. Sidechains Another implementation is cross-chain communication with Proof of Stake networks. PoS networks such as Cardano can interact with Ergo through NIPoPoW integration. Such verification schemes can erase the need for centralized DAO structures and create new non-interactive cross-chain operations. To put it simply, NiPoPoWs act as sidechains. Two or more separate chains can integrate through NiPoPoWs without the need for change in other chains. Such integration would erase the need for, for example, \"Wrapped Tokens,\" tokens that rely on DAO governance. NIPoPoW is a robust tool in creating blockchain networks and provides easier access to clients. They're also helpful in enhancing scalability by creating Layer 2 organizations. Side chains , on the other hand, are a completely different component of blockchain. They are beneficial for various elements such as private chains, scalability improvement, and cross-chain interoperability. Kushti mentioned that he will release a sidechain \"cookbook,\" entitled Ergo-Meta, in the following months. One application of NIPoPoWs that we have described in a previous article deals with logarithmic space mining . Logarithmic space mining allows for \"light miners.\" Similar to light clients, light miners can bootstrap with block headers without downloading the whole blockchain. It is also possible to store just a few necessary blocks to verify the whole blockchain in a blockchain. This essentially eradicates the need for miners to store all of the blockchains. Integrating logarithmic space mining in Ergo is possible via velvet (soft) forks, therefore preventing the need for painful hard forks. Another application of NIPoPoWs was proposed in the first ErgoHack by a team called SmartPools. SmartPools' proposal aims to increase the Nakamoto Coefficient , a metric for calculating the decentralization of the given network. In our case, the proposal aims to increase the decentralization of the Ergo Platform by bootstrapping mining entities with collateralized smart contracts. The purpose here is to provide returns for non-miner investors and prevent big GPU farms from taking control of the system. The most well-known example of NIPoPoWs is the implementation of the second layer blockchain. Second layers are helpful in interacting with different blockchains by increasing scalability and creating private sidechains for enterprise-grade applications. Second layers create blockchains on top of the primary blockchain for different use cases. Because transactions can happen on these second layers without constant synchronous updates, the network load can be lowered substantially by keeping everything on the main chain all the time. The Ergo blockchain has supported NIPoPoWs since its genesis, yet their use cases are still in their infancy. We continue to develop this field of research with our partners at IOHK and EMURGO , and we expect their application to increase with continued contributions from the community developers. Sidechains: Why These Researchers Think They Solved a Key Piece of the Puzzle","title":"NiPoPoWS"},{"location":"dev/protocol/nipopow/#nipopows","text":"Several years have been spent researching and developing secure protocols that allow for efficient SPV clients. The two best-known and most reliable protocols are NiPoPoWs and FlyClient. Ergo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. You can explore this technology in full on nipopows.com Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) are short stand-alone strings that a computer program can inspect to verify that an event happened on a proof-of-work-based blockchain without connecting to the blockchain network and without downloading all block headers. For example, these proofs can illustrate that a cryptocurrency payment was made.","title":"NiPoPoWs"},{"location":"dev/protocol/nipopow/#light-clients","text":"You might want to run a full node. If you're a miner, this will require that you download the entire blockchain because you'll need the whole UTXO (unspent outputs) set to mine new blocks. But you can still run a full node without that UTXO set \u2013 vastly reducing the specification and expense of the hardware needed. Blocks In Ergo, just like Bitcoin, Ethereum, and other blockchains, blocks are broken into sections. In Bitcoin, there's simply a block header and the transactions themselves. But in Ergo, we have some extra sections that enable new functionality: Header Transactions Extensions Proofs of UTXO transformation The 'extension' section contains certain mandatory fields (including links for NiPoPoW, once per 1,024 block epoch) and parameters for miner voting, such as current block size. It can also contain arbitrary fields. What this means in practice is that different types of nodes and clients can download only those sections of the blocks they need \u2013 reducing the demands for storage, bandwidth, and CPU cycles. Lite full nodes While miners need to download everything, lite full nodes only need the transactions and proofs. This means they have a cryptographic guarantee of transactions without holding the complete UTXO set itself. Lite full nodes check the proofs generated by full nodes (including miners) who hold the whole blockchain, guaranteeing ledger validity. In Ethereum, these nodes are called Stateless Clients. For Ergo, it means you can run a full node and maintain the network with a device as simple as a Raspberry Pi with 512 MB RAM. This provides the ideal balance between ensuring the network's security and placing an unnecessary burden on users who wish to do so \u2013 improving decentralisation and democratising participation in the Ergo network and community.","title":"Light Clients"},{"location":"dev/protocol/nipopow/#light-clients_1","text":"Light Clients (aka SPV ) are essential when considering the hurdles cryptocurrency faces with mass adoption. Most crypto users do not have the necessary tools to run a full node. Running a full node means having a strong processor with high electricity wattage and more than a hundred gigabytes of memory to store the entire blockchain. Light clients are useful because they enable verification with a limited supply of data providers (nodes) and significantly reduce the amount of data storage and bandwidth needed for everyday users. The use of light clients with the implementation of NIPoPoWs makes it possible to interact with the blockchain through block headers by using only a couple of kilobytes. Verifying whether a transaction happened on the blockchain becomes simplified. NIPoPoWs can help people interact with the blockchain by using more efficient and convenient mobile wallets. NIPoPoWs allow very efficient mobile wallets to be created. SPV wallets are already very lightweight compared to full nodes because they only require the download of block headers, not the whole blockchain. NIPoPoW wallets need to download only a small sample of block headers, around 250, when SPV clients need to download half a million block headers. The sample needed changes but doesn't grow much in size as the blockchain grows larger over the years, even after decades of data has been accumulated. This enables Ergo to build a mobile SPV client that requires around just 100KB of block headers to be downloaded. A super-efficient Ergo wallet with SPV security is in development, so stay tuned for more updates! Building Ergo: SPV security","title":"Light Clients"},{"location":"dev/protocol/nipopow/#spv-security","text":"_ There's often tension in the crypto world between security and convenience. That trade-off is unacceptable if we want these technologies to be widely used. Here's how Ergo addresses one common and critical issue._ We all know that the most secure way to use Bitcoin, or any crypto, is to download a copy of the blockchain and run a full node yourself. That way, every time you or anyone else makes a transaction, your client checks the blockchain to ensure it's valid. You don't have to trust anyone else. A full Bitcoin node checks all the blocks in the blockchain (using headers) and makes sure there are no fraudulent transactions. It's a very secure way of using crypto \u2013 but there's a problem. It requires significant bandwidth, storage, and processing power. That kind of commodity hardware is expensive, and using a full node to validate and make transactions is in any case unsuitable for mobile devices. This is particularly true for Bitcoin, where the blockchain is over 270 GB and counting .","title":"SPV Security"},{"location":"dev/protocol/nipopow/#spv","text":"Simplified Payment Verification (SPV) is designed to address this problem, as described in the Bitcoin white paper : It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it and blocks added after it further confirms the network has accepted it. Satoshi notes that this is not a perfect solution and is vulnerable to an attacker overpowering the network and fooling SPV users. Moreover, while SPV mode is intended for resource-limited devices, even this 'lite' approach is not always feasible. Ethereum's headers alone total around 5 GB to download. Thus Ethereum mobile clients do not validate chain validity and so blindly have to trust third parties. There are proposals to reduce the requirements for SPV mode by checking just a few random headers instead of all of them. But it's hard to do that securely.","title":"SPV"},{"location":"dev/protocol/nipopow/#efficient-spv","text":"Several years have been spent researching and developing secure protocols that allow for efficient SPV clients. The two best-known and most reliable protocols are NiPoPoWs and FlyClient. Ergo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. You can explore this technology in full on this dedicated website: https://nipopows.com : Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) are short stand-alone strings that a computer program can inspect to verify that an event happened on a proof-of-work-based blockchain without connecting to the blockchain network and without downloading all block headers. For example, these proofs can illustrate that a cryptocurrency payment was made. NIPoPoWs allow very efficient mobile wallets to be created. SPV wallets are already very lightweight compared to full nodes because they only require the download of block headers, not the whole blockchain. NIPoPoW wallets need to download only a tiny sample of block headers, around 250 when SPV clients need to download half a million block headers. The sample needed changes but doesn't grow much in size as the blockchain grows more extensive over the years, even after accumulated decades of data. This enables us to build a mobile SPV client that requires around just 100KB of block headers to be downloaded. A super-efficient Ergo wallet with SPV security is in development, so stay tuned for more updates!","title":"Efficient SPV"},{"location":"dev/protocol/nipopow/#log-space-mining","text":"Dionysis Zindros explains the technical landscape of Non-Interactive Proofs of Proof-of-Work. Dionysis takes a diligent approach for the Ergo Cast with a detailed rundown of what Non-Interactive Proofs of Proof-of-Work truly are. Furthermore, Dionysis evaluates the operation, implementation, and impact that his primitive delivers upon. Furthermore, we unveil a brand-new piece of research that -as of yet- has never been shared publicly: log-space mining. NiPoPoWs & Log-Space Mining \u2013 Ergo Cast Episode #5 This article is based on a recently published article by IOHK. For an additional resource, please see the following video. Whether it is Ergo, Bitcoin, or another PoW consensus model, miners must constantly maintain the blockchain. In addition to using computational resources, miners also use storage resources that maintain all blockchain data from the genesis block. A new miner's problem: Is downloading all the data from the genesis block strictly necessary? Why is it not possible to download only the most relevant blocks to maintain the network? The block headers of the blockchain should be enough to access the necessary data. NIPoPoWs (Non-Interactive Proofs of Proof of Work) can be integrated to form interlinked block header sets that will reduce historical data storage. When needing to access key blocks in the blockchain, miners should be able to efficiently do this from the headers of the old blocks. That is because each new block must indicate all of the current networks. As new blocks are created, a set of new block headers can be enough to check for the current UTXO set. Since the new blocks contain the data of old stringed block header sets, it enables light mining by eliminating the need to download all the blockchain data. What are we trying to optimize by stringing old PoW history and compiling it into a snapshot? If we say C=old blocks and K=new blocks, then included blocks in the snapshot can be growing when K=new blocks are constant, and C=old blocks are linear. But it can also be shrinking depending on the smart contract applications. The problem of maintaining heavy loads of data by the miners can be solved by bootstrapping through NIPoPoWs. NIPoPoW Implementation Instead of accessing all of the blocks, superblocks (or light-clients) are enough to verify all of the blocks. This is accomplished by maintaining the historical data of the blockchain through smart contracts. The introduction of these superblock clients on NIPoPoWs can be done via 'velvet' or soft forks, and after that \"light\" miners can bootstrap through \"online\" mining. NIPoPoWs enable smart contracts to maintain historical data so that new \"light\" miners can work in a so-called \"online\" fashion. This is the main idea of Logarithmic Space Mining, where instead of saving all the blockchain data locally on nodes, the unnecessary part of it can be compiled into the blockchain itself. New miners do not need to carry the historical data, and as they continue to mine, new \"light\" miners will help other \"light\" miners bootstrap. There will be no need to carry old historical data, and old miners can abandon historical data for lighter mining. This is how the whole miner population can abandon old blocks and make the system much more efficient.","title":"Log-Space Mining"},{"location":"dev/protocol/nipopow/#sidechains","text":"Another implementation is cross-chain communication with Proof of Stake networks. PoS networks such as Cardano can interact with Ergo through NIPoPoW integration. Such verification schemes can erase the need for centralized DAO structures and create new non-interactive cross-chain operations. To put it simply, NiPoPoWs act as sidechains. Two or more separate chains can integrate through NiPoPoWs without the need for change in other chains. Such integration would erase the need for, for example, \"Wrapped Tokens,\" tokens that rely on DAO governance. NIPoPoW is a robust tool in creating blockchain networks and provides easier access to clients. They're also helpful in enhancing scalability by creating Layer 2 organizations. Side chains , on the other hand, are a completely different component of blockchain. They are beneficial for various elements such as private chains, scalability improvement, and cross-chain interoperability. Kushti mentioned that he will release a sidechain \"cookbook,\" entitled Ergo-Meta, in the following months. One application of NIPoPoWs that we have described in a previous article deals with logarithmic space mining . Logarithmic space mining allows for \"light miners.\" Similar to light clients, light miners can bootstrap with block headers without downloading the whole blockchain. It is also possible to store just a few necessary blocks to verify the whole blockchain in a blockchain. This essentially eradicates the need for miners to store all of the blockchains. Integrating logarithmic space mining in Ergo is possible via velvet (soft) forks, therefore preventing the need for painful hard forks. Another application of NIPoPoWs was proposed in the first ErgoHack by a team called SmartPools. SmartPools' proposal aims to increase the Nakamoto Coefficient , a metric for calculating the decentralization of the given network. In our case, the proposal aims to increase the decentralization of the Ergo Platform by bootstrapping mining entities with collateralized smart contracts. The purpose here is to provide returns for non-miner investors and prevent big GPU farms from taking control of the system. The most well-known example of NIPoPoWs is the implementation of the second layer blockchain. Second layers are helpful in interacting with different blockchains by increasing scalability and creating private sidechains for enterprise-grade applications. Second layers create blockchains on top of the primary blockchain for different use cases. Because transactions can happen on these second layers without constant synchronous updates, the network load can be lowered substantially by keeping everything on the main chain all the time. The Ergo blockchain has supported NIPoPoWs since its genesis, yet their use cases are still in their infancy. We continue to develop this field of research with our partners at IOHK and EMURGO , and we expect their application to increase with continued contributions from the community developers. Sidechains: Why These Researchers Think They Solved a Key Piece of the Puzzle","title":"Sidechains"},{"location":"dev/protocol/utxo-state/","text":"Model Transaction As the Ergo ecosystem grows, our community can now enjoy the functions for several of our key dApps. Ergo has a stablecoin protocol where users can mint SigUSD and SigRSV tokens. Ergo Auction House offers the ability to mint NFTs and ErgoDEX (Beta) allows you to swap tokens and provide liquidity. These are the very first, unique and complex DeFi dApps on the UTXO model - a model that Bitcoin pioneered. It has often been debated whether the UTXO model can express rich smart contracts, much like the Accounts model. That is why Ergo Platform built the ErgoScript language from scratch in an effort to progress on Bitcoin\u2019s legacy. For an in-depth comparison about UTXO and Accounts models, please read our previous blog post: Ergo: Advancing on Bitcoin As an Ergonaut, you may have experienced some confusion if you have checked the explorer to view your transaction details. The UTXO model is essentially different from the Accounts model via the use of \u201cboxes'' for data-keeping. In the Accounts model, there is a single account where you receive your coins. In the UTXO model however, every tx (transaction) creates a new box and your balance is the sum of all the boxes linked to your addresses. To be clear, your Yoroi private key can consist of more than one box in a single address to hold your coins. As you generate a new address, you will create a secondary box to hold your coins. After it is created, you can send funds to this new address and your funds will be seen as one with your private key. You can create an infinite number of new boxes to hold your coins. As such, every receiving and spending action will also create an additional unique box. This feature can create misconceptions by the user at first glance. When you make a transaction, the network scans your \u201cboxes\u201d to verify if you have your tokens and then initiates the transaction. Things get complex after this point because you can not guess which boxes are going to be spent. Imagine you have three different receiving addresses. You received a couple of coins in each of them and you want to spend some of your coins. In a Yoroi wallet, you can hold any Ergo native coins such as SigRSV or SigUSD. When you initiate a transaction that accesses the boxes of these coins, you will see that they are taken away and then redeposited. Recently, an Ergonaut raised the following question : \u201cI just created a Yoroi Nightly wallet. I transferred 31 Erg from my main Yoroi wallet to the Yoroi Nightly wallet. The transaction shows 31 Erg plus a small fee, 0.0011. But it also says +92,000 SigRSV. My balance shows no change in SigRSV. What is the meaning of the +92,000 SigRSV in the transaction?\u201d Let\u2019s take a look of the details of this particular transaction : To make a transaction of 31 ERG, the wallet selected three of the boxes with ERG: A box containing 0.029595 ERG that was received on 07/19/21 A second box containing 19.76 ERG that was received on 07/19/21 A third box containing 208.26 ERG that was received on 06/09/21 On the left section of the image above, you will see approximately 228 ERG taken while on the right section you will see 31 ERG sent and 197 ERG redeposited to your wallet. So your wallet used three of your boxes to spend the desired amount. This action includes all the assets in that box to the transaction. After the desired amount is spent, your funds are simply refunded to your address in a newly created UTXO box or boxes. Spending any coin in a box therefore means spending the whole box and creating a new UTXO box, which is why you see your tokens are taken away and then redeposited. The selection of which boxes to spend is a secret of the wallet\u2019s random selection strategy. Whatever coins are in the selected boxes, be it SigRSV, SigUSD or NFT, will be displayed as in the example. To sum up: The Accounts model contains a single box and this box is not spent. It remains the same so non-related coins will remain unaffected. The UTXO model on the other hand contains a set of boxes that represents the total amount of the users balance and the unspent transaction output has to change with each spending transaction. You may see a long list of tokens when swapping just 5 SigRSV as below: This is just how UTXO model Transaction works - its storage is different from the Accounts model. In the UTXO model, coins will be stored in one-use UTXO boxes and not in long-living accounts.","title":"UTXO State"},{"location":"dev/protocol/utxo-state/#model-transaction","text":"As the Ergo ecosystem grows, our community can now enjoy the functions for several of our key dApps. Ergo has a stablecoin protocol where users can mint SigUSD and SigRSV tokens. Ergo Auction House offers the ability to mint NFTs and ErgoDEX (Beta) allows you to swap tokens and provide liquidity. These are the very first, unique and complex DeFi dApps on the UTXO model - a model that Bitcoin pioneered. It has often been debated whether the UTXO model can express rich smart contracts, much like the Accounts model. That is why Ergo Platform built the ErgoScript language from scratch in an effort to progress on Bitcoin\u2019s legacy. For an in-depth comparison about UTXO and Accounts models, please read our previous blog post: Ergo: Advancing on Bitcoin As an Ergonaut, you may have experienced some confusion if you have checked the explorer to view your transaction details. The UTXO model is essentially different from the Accounts model via the use of \u201cboxes'' for data-keeping. In the Accounts model, there is a single account where you receive your coins. In the UTXO model however, every tx (transaction) creates a new box and your balance is the sum of all the boxes linked to your addresses. To be clear, your Yoroi private key can consist of more than one box in a single address to hold your coins. As you generate a new address, you will create a secondary box to hold your coins. After it is created, you can send funds to this new address and your funds will be seen as one with your private key. You can create an infinite number of new boxes to hold your coins. As such, every receiving and spending action will also create an additional unique box. This feature can create misconceptions by the user at first glance. When you make a transaction, the network scans your \u201cboxes\u201d to verify if you have your tokens and then initiates the transaction. Things get complex after this point because you can not guess which boxes are going to be spent. Imagine you have three different receiving addresses. You received a couple of coins in each of them and you want to spend some of your coins. In a Yoroi wallet, you can hold any Ergo native coins such as SigRSV or SigUSD. When you initiate a transaction that accesses the boxes of these coins, you will see that they are taken away and then redeposited. Recently, an Ergonaut raised the following question : \u201cI just created a Yoroi Nightly wallet. I transferred 31 Erg from my main Yoroi wallet to the Yoroi Nightly wallet. The transaction shows 31 Erg plus a small fee, 0.0011. But it also says +92,000 SigRSV. My balance shows no change in SigRSV. What is the meaning of the +92,000 SigRSV in the transaction?\u201d Let\u2019s take a look of the details of this particular transaction : To make a transaction of 31 ERG, the wallet selected three of the boxes with ERG: A box containing 0.029595 ERG that was received on 07/19/21 A second box containing 19.76 ERG that was received on 07/19/21 A third box containing 208.26 ERG that was received on 06/09/21 On the left section of the image above, you will see approximately 228 ERG taken while on the right section you will see 31 ERG sent and 197 ERG redeposited to your wallet. So your wallet used three of your boxes to spend the desired amount. This action includes all the assets in that box to the transaction. After the desired amount is spent, your funds are simply refunded to your address in a newly created UTXO box or boxes. Spending any coin in a box therefore means spending the whole box and creating a new UTXO box, which is why you see your tokens are taken away and then redeposited. The selection of which boxes to spend is a secret of the wallet\u2019s random selection strategy. Whatever coins are in the selected boxes, be it SigRSV, SigUSD or NFT, will be displayed as in the example.","title":"Model Transaction"},{"location":"dev/protocol/utxo-state/#to-sum-up","text":"The Accounts model contains a single box and this box is not spent. It remains the same so non-related coins will remain unaffected. The UTXO model on the other hand contains a set of boxes that represents the total amount of the users balance and the unspent transaction output has to change with each spending transaction. You may see a long list of tokens when swapping just 5 SigRSV as below: This is just how UTXO model Transaction works - its storage is different from the Accounts model. In the UTXO model, coins will be stored in one-use UTXO boxes and not in long-living accounts.","title":"To sum up:"},{"location":"dev/stack/back-end/","text":"Back-end This page provides an overview of the tools used to interact with the Ergo blockchain. Developers can use these tools to read data from the blockchain, compute using that data and optionally create transactions to be broadcast. Each tool requires the developer to \"program\" in some language. Users of AppKit will usually write Scala code (although AppKit supports many other languages). HDF users will need to write Rust code. JDE users will have to write JSON. JDE Ergo JDE Tutorials How-to Guides Example: Minting Reserve Coins Writing JDE Scripts Using the web service Explanations References Sample Scripts Syntax Headless dApp Framework Ergo Headless dApp Framework . The premier Rust framework for developing Ergo Headless dApps. The Ergo HDF provides developers with the very first portable UTXO-based headless dApp development framework on any blockchain. Tutorials Math Bounty Headless dApp - Getting Started Writing Your First Action Math Bounty Headless dApp - Finishing The Headless dApp Math Bounty Headless dApp - Writing A CLI Frontend For Creating Bounties Explanations Understanding The Ergo Headless dApp Framework Appkit AppKit provides methods for the following Fetch data from Ergo Explorer API Interact with Ergo Node, both public and private methods Build transactions and sign them Helper methods to handle cryptographics like calculating PK addresses from secrets Appkit: A Library for Polyglot Development of Ergo Applications has an idiomatic Java API and is written in Java/Scala. It is a thin wrapper around core components provided by the ErgoScript interpreter and Ergo protocol implementations which are written in Scala. It is published on maven repository and cross compiled to both Java 7 and Java 8+ jars. Using Appkit Ergo applications can be written in one of the languages supported by GraalVM (i.e. Java, JavaScript, C/C++, Python, Ruby, R) and using this library applications can communicate with Ergo nodes via unified API and programming model provided by Appkit. In addition Appkit based Ergo applications can be compiled into native code using native-image ahead of time compiler and then executed without Java VM with very fast startup time and lower runtime memory overhead compared to a Java VM. This is attractive option for high-performance low-latency microservices. Tutorials Tutorial starting with Appkit on Gradle projects AppKit by Example (Video) Appkit Examples How-to Guides Ergo Android | Example Android application which demonstrates how Ergo Appkit can be used to develop Ergo applications running on Android. Explanations AppKit Introduction . References ErgoTool | A Command Line Interface for Ergo based on Appkit and GraalVM native-image. Read the introduction and overview .","title":"Backend"},{"location":"dev/stack/back-end/#back-end","text":"This page provides an overview of the tools used to interact with the Ergo blockchain. Developers can use these tools to read data from the blockchain, compute using that data and optionally create transactions to be broadcast. Each tool requires the developer to \"program\" in some language. Users of AppKit will usually write Scala code (although AppKit supports many other languages). HDF users will need to write Rust code. JDE users will have to write JSON.","title":"Back-end"},{"location":"dev/stack/back-end/#jde","text":"Ergo JDE","title":"JDE"},{"location":"dev/stack/back-end/#tutorials","text":"","title":"Tutorials"},{"location":"dev/stack/back-end/#how-to-guides","text":"Example: Minting Reserve Coins Writing JDE Scripts Using the web service","title":"How-to Guides"},{"location":"dev/stack/back-end/#explanations","text":"","title":"Explanations"},{"location":"dev/stack/back-end/#references","text":"Sample Scripts Syntax","title":"References"},{"location":"dev/stack/back-end/#headless-dapp-framework","text":"Ergo Headless dApp Framework . The premier Rust framework for developing Ergo Headless dApps. The Ergo HDF provides developers with the very first portable UTXO-based headless dApp development framework on any blockchain.","title":"Headless dApp Framework"},{"location":"dev/stack/back-end/#tutorials_1","text":"Math Bounty Headless dApp - Getting Started Writing Your First Action Math Bounty Headless dApp - Finishing The Headless dApp Math Bounty Headless dApp - Writing A CLI Frontend For Creating Bounties","title":"Tutorials"},{"location":"dev/stack/back-end/#explanations_1","text":"Understanding The Ergo Headless dApp Framework","title":"Explanations"},{"location":"dev/stack/back-end/#appkit","text":"AppKit provides methods for the following Fetch data from Ergo Explorer API Interact with Ergo Node, both public and private methods Build transactions and sign them Helper methods to handle cryptographics like calculating PK addresses from secrets Appkit: A Library for Polyglot Development of Ergo Applications has an idiomatic Java API and is written in Java/Scala. It is a thin wrapper around core components provided by the ErgoScript interpreter and Ergo protocol implementations which are written in Scala. It is published on maven repository and cross compiled to both Java 7 and Java 8+ jars. Using Appkit Ergo applications can be written in one of the languages supported by GraalVM (i.e. Java, JavaScript, C/C++, Python, Ruby, R) and using this library applications can communicate with Ergo nodes via unified API and programming model provided by Appkit. In addition Appkit based Ergo applications can be compiled into native code using native-image ahead of time compiler and then executed without Java VM with very fast startup time and lower runtime memory overhead compared to a Java VM. This is attractive option for high-performance low-latency microservices.","title":"Appkit"},{"location":"dev/stack/back-end/#tutorials_2","text":"Tutorial starting with Appkit on Gradle projects AppKit by Example (Video) Appkit Examples","title":"Tutorials"},{"location":"dev/stack/back-end/#how-to-guides_1","text":"Ergo Android | Example Android application which demonstrates how Ergo Appkit can be used to develop Ergo applications running on Android.","title":"How-to Guides"},{"location":"dev/stack/back-end/#explanations_2","text":"AppKit Introduction .","title":"Explanations"},{"location":"dev/stack/back-end/#references_1","text":"ErgoTool | A Command Line Interface for Ergo based on Appkit and GraalVM native-image. Read the introduction and overview .","title":"References"},{"location":"dev/stack/ergoscript/","text":"Ergo provides advanced programming abilities for financial contracts using a high-level language called ErgoScript. As a simple example, the below script allows only Alice to spend a box before a certain height and only Bob to spend the box after that. if (HEIGHT < 100000) alicePubKey else bobPubKey The scripting language in itself is non-Turing complete, but applications run on the platform can be made to be Turing complete as demonstrated in this peer-reviewed paper . Proxy Contracts Outsourcing transaction generation to an external service/dApp can be useful or even needed in various circumstances. For example, avoiding wallet limitations to generate any transaction on behalf of the user - Ergo Assembler is designed for this purpose. Another example is to scale dApps to be able to fulfill many requests without double-spending or data invalidation - SigmaUSD dApp can use proxy contracts to avoid bank double-spending and ERG/USD oracle data invalidation. EIP-0017 Learn Tutorials (Video) Learn ErgoScript By Example Via The Ergo Playground with Robert Kornacki Advanced ErgoScript Tutorial ErgoScript tutorial How-to Guides Explanations ErgoScript Design patterns SigmaState Protocols References A Quick Primer on ErgoScript ErgoScript Language Description FlowCards A Declarative Framework for Development of Ergo dApps https://ergoplatform.org/en/blog/2020_04_29_flow_cards/","title":"ErgoScript"},{"location":"dev/stack/ergoscript/#proxy-contracts","text":"Outsourcing transaction generation to an external service/dApp can be useful or even needed in various circumstances. For example, avoiding wallet limitations to generate any transaction on behalf of the user - Ergo Assembler is designed for this purpose. Another example is to scale dApps to be able to fulfill many requests without double-spending or data invalidation - SigmaUSD dApp can use proxy contracts to avoid bank double-spending and ERG/USD oracle data invalidation. EIP-0017","title":"Proxy Contracts"},{"location":"dev/stack/ergoscript/#learn","text":"","title":"Learn"},{"location":"dev/stack/ergoscript/#tutorials","text":"(Video) Learn ErgoScript By Example Via The Ergo Playground with Robert Kornacki Advanced ErgoScript Tutorial ErgoScript tutorial","title":"Tutorials"},{"location":"dev/stack/ergoscript/#how-to-guides","text":"","title":"How-to Guides"},{"location":"dev/stack/ergoscript/#explanations","text":"ErgoScript Design patterns SigmaState Protocols","title":"Explanations"},{"location":"dev/stack/ergoscript/#references","text":"A Quick Primer on ErgoScript ErgoScript Language Description","title":"References"},{"location":"dev/stack/ergoscript/#flowcards","text":"A Declarative Framework for Development of Ergo dApps https://ergoplatform.org/en/blog/2020_04_29_flow_cards/","title":"FlowCards"},{"location":"dev/stack/front-end/","text":"Front-end Ergo JS Template The Ergo JS Template aims to serve as an entry point to Ergo dApp Development Bootstrapped with Create React App. It contains ergo-ts and ergo-lib libraries as dependencies and some examples to present how to use these libraries. Explanations The following examples can be seen on the Ergo JS Template repository Interacting with the explorer Encoding different data types Decoding fields (registers) of tokens References ergo-ts with support of tokens and complex transactions ergo-js with basic transaction operations Other Examples The Ergo Raffle documentation provides a detailed description of their implmenetion. hypo10use/quid-games (Angular)","title":"Frontend"},{"location":"dev/stack/front-end/#front-end","text":"","title":"Front-end"},{"location":"dev/stack/front-end/#ergo-js-template","text":"The Ergo JS Template aims to serve as an entry point to Ergo dApp Development Bootstrapped with Create React App. It contains ergo-ts and ergo-lib libraries as dependencies and some examples to present how to use these libraries.","title":"Ergo JS Template"},{"location":"dev/stack/front-end/#explanations","text":"The following examples can be seen on the Ergo JS Template repository Interacting with the explorer Encoding different data types Decoding fields (registers) of tokens","title":"Explanations"},{"location":"dev/stack/front-end/#references","text":"ergo-ts with support of tokens and complex transactions ergo-js with basic transaction operations","title":"References"},{"location":"dev/stack/front-end/#other-examples","text":"The Ergo Raffle documentation provides a detailed description of their implmenetion. hypo10use/quid-games (Angular)","title":"Other Examples"},{"location":"dev/start/api/","text":"An Ergo node provides a REST API accessible via HTTP. The full API specification (in OpenAPI format) is available here . Accessing the API Once the node is running, the API can be accessed at 127.0.0.1:9052 . You can also use Swagger to make API requests by going to 127.0.0.1:9052/swagger . To access protected API routes (such as for wallet), you must provide your secret phrase in the request headers [api_key, Content-Type] , or click the Authorize button in swagger and enter your secret phrase there. Setting an API key For accessing any protected methods you must configure apiKeyHash parameter in the node configuration file: scorex.restApi.apiKeyHash = \"replace_this_with_your_unique_api_key_hash\" The parameter is the hex-encoded Blake2b256 hash of your secret phrase that will be used to authenticate your API requests. You can use this Python script or any other script to securely generate the secret and the blake2b256 hash of it. The secret phrase acts as an API key and can be any string but please ensure that it remains secret and is not sent to any untrusted services. The following REST API endpoint also provides a (non-protected) method to compute the hash: /utils/hashBlake2b","title":"Api"},{"location":"dev/start/api/#accessing-the-api","text":"Once the node is running, the API can be accessed at 127.0.0.1:9052 . You can also use Swagger to make API requests by going to 127.0.0.1:9052/swagger . To access protected API routes (such as for wallet), you must provide your secret phrase in the request headers [api_key, Content-Type] , or click the Authorize button in swagger and enter your secret phrase there.","title":"Accessing the API"},{"location":"dev/start/api/#setting-an-api-key","text":"For accessing any protected methods you must configure apiKeyHash parameter in the node configuration file: scorex.restApi.apiKeyHash = \"replace_this_with_your_unique_api_key_hash\" The parameter is the hex-encoded Blake2b256 hash of your secret phrase that will be used to authenticate your API requests. You can use this Python script or any other script to securely generate the secret and the blake2b256 hash of it. The secret phrase acts as an API key and can be any string but please ensure that it remains secret and is not sent to any untrusted services. The following REST API endpoint also provides a (non-protected) method to compute the hash: /utils/hashBlake2b","title":"Setting an API key"},{"location":"dev/start/dApp-dev/","text":"","title":"dApp dev"},{"location":"dev/start/resources/","text":"Resources Explorer Explorer Mainnet explorer Testnet Testnet explorer Using Ergo-Testnet Testnet Faucet API API Docs Node API Explorer API Misc. Resources Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo. Basic Tutorials ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Resources"},{"location":"dev/start/resources/#resources","text":"","title":"Resources"},{"location":"dev/start/resources/#explorer","text":"Explorer Mainnet explorer","title":"Explorer"},{"location":"dev/start/resources/#testnet","text":"Testnet explorer Using Ergo-Testnet Testnet Faucet","title":"Testnet"},{"location":"dev/start/resources/#api","text":"API Docs Node API Explorer API","title":"API"},{"location":"dev/start/resources/#misc-resources","text":"Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo.","title":"Misc. Resources"},{"location":"dev/start/resources/#basic-tutorials","text":"ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Basic Tutorials"},{"location":"dev/start/start/","text":"Welcome To Smart Money Ergo Blockchain is a financial smart contract platform that is built on the UTXO model. Its language, \u201cErgoScript,\u201d is a rich language that supports Multi-Stage Contracts based on Scala. Even if you don\u2019t know Scala, you can get used to it easily by checking ErgoScript (or ErgoTree directly) to understand the logic behind it. The first thing you can do to navigate around the Ergo Ecosystem is to go to the main page and click the \u201cDevelopers\u201d button on the top bar and scroll to \u201cContribute to Ergo\u201d. Scroll down on the page and you will a section entitled \u201cOverview,\u201d which contains a variety of guides to help you get started. To begin, take a look at the tutorials. There you can see the ErgoScript overview and application ideas using ErgoScript. Once you get an idea of the extended UTXO model and programming on top of Ergo, check ErgoScript on the right and download the latest library. After checking ErgoTree, the ErgoScript Whitepaper, ErgoScript Tutorials and downloading the latest library, you can start trying for yourself. If you want to get to know some real use cases, check the Ergo GitHub Wiki page. On the right panel, you can read various smart contract applications. To build from scratch, check Ergo Github and get familiar with simple functions. Developer Tools are handy to build your own libraries. Furthermore, you can check these topics to enhance your knowledge. Protocol UTXO State Autolykos NiPoPow Data Model Box Transaction BlockP2P Protocol overview Network messages Handshaking Modifiers exchange Node Node architecture Node API Light modes NiPoPow State snapshots History pruning Digest state Wallet: Addresses Hierarchical keys Smart Contracts Core principles ErgoScript You can search the terms in Ergo Github and navigate yourself. Here is another starting page to get you covered on Awesome Ergo . It\u2019s wonderful if you followed this far. If you\u2019re new to Ergo, first we advise checking the community page ergonaut.space and see what Ergo is made of! Where to start? The dApp Development page provides a broad overview on creating your first decentralised app. See the Backend page for an overview of the tools available to interact with the blockchain. This is also broken down on a per-language basis. dApp Development For most developers, Appkit is the best entry point unless you're wanting to dive straight into ErgoScript smart-contract development. System Architecture Below is a example system architecture diagram highlighting the main components of a decentralised application (dApp) Front-end | The user-interface built in your framework of choice. For payments, we have the Yoroi dApp connector, proxy contracts, or Ergo-Pay. REST | A REST ful API to interact with the backend Backend | Perform the off-chain logic Database (Optional) Contract | Where the magic happens, the on-chain validation of the off-chain logic. Resources Explorer Explorer Mainnet explorer Testnet Testnet explorer Using Ergo-Testnet Testnet Faucet API API Docs Node API Explorer API Misc. Resources Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo. Basic Tutorials ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Where to start?"},{"location":"dev/start/start/#where-to-start","text":"The dApp Development page provides a broad overview on creating your first decentralised app. See the Backend page for an overview of the tools available to interact with the blockchain. This is also broken down on a per-language basis.","title":"Where to start?"},{"location":"dev/start/start/#dapp-development","text":"For most developers, Appkit is the best entry point unless you're wanting to dive straight into ErgoScript smart-contract development. System Architecture Below is a example system architecture diagram highlighting the main components of a decentralised application (dApp) Front-end | The user-interface built in your framework of choice. For payments, we have the Yoroi dApp connector, proxy contracts, or Ergo-Pay. REST | A REST ful API to interact with the backend Backend | Perform the off-chain logic Database (Optional) Contract | Where the magic happens, the on-chain validation of the off-chain logic.","title":"dApp Development"},{"location":"dev/start/start/#resources","text":"","title":"Resources"},{"location":"dev/start/start/#explorer","text":"Explorer Mainnet explorer","title":"Explorer"},{"location":"dev/start/start/#testnet","text":"Testnet explorer Using Ergo-Testnet Testnet Faucet","title":"Testnet"},{"location":"dev/start/start/#api","text":"API Docs Node API Explorer API","title":"API"},{"location":"dev/start/start/#misc-resources","text":"Test vectors: Ergo transaction serialization Signature scheme Utilities Miner rewards script | Simple command-line tool to find miner rewards not spent and form withdrawing transaction requests for them Ergo P2S Playground | A web-based tool to quickly get the address corresponding to some script Resources ErgoWiki | The official ergoplatform GitHub wiki ergosites.github.io | Resource page which links to various websites and utilities. ergohack.io | Your introduction to developing on Ergo.","title":"Misc. Resources"},{"location":"dev/start/start/#basic-tutorials","text":"ergotutorials.com Ergo API basic query Create mini web for your NFT.","title":"Basic Tutorials"},{"location":"miners/mining/","text":"","title":"Mining"}]}